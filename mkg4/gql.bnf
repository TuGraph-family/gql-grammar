<GQL-program> ::=<program activity> [ <session close command> ] | <session close command>
<program activity> ::=<session activity> | <transaction activity>
<session activity> ::=<session activity command>...
<session activity command> ::=<session set command> | <session reset command>
<transaction activity> ::=<start transaction command> [ <procedure specification> [ <end transaction command> ] ] | <procedure specification> [ <end transaction command> ] | <end transaction command>
<end transaction command> ::=<rollback command> | <commit command>
<session set command> ::=SESSION SET { <session set schema clause> | <session set graph clause> | <session set time zone clause> | <session set parameter clause> }
<session set schema clause> ::=SCHEMA <schema reference>
<session set graph clause> ::=[ PROPERTY ] GRAPH <graph expression>
<session set time zone clause> ::=TIME ZONE <set time zone value>
<set time zone value> ::=<string value expression>
<session set parameter clause> ::=<session set graph parameter clause> | <session set binding table parameter clause> | <session set value parameter clause>
<session set graph parameter clause> ::=[ PROPERTY ] GRAPH <session set parameter name> <opt typed graph initializer>
<session set binding table parameter clause> ::=[ BINDING ] TABLE <session set parameter name> <opt typed binding table initializer>
<session set value parameter clause> ::=VALUE <session set parameter name> <opt typed value initializer>
<session set parameter name> ::=<parameter name> [ IF NOT EXISTS ]
<session reset command> ::=[ SESSION ] RESET [ <session reset arguments> ]
<session reset arguments> ::=[ ALL ] { PARAMETERS | CHARACTERISTICS } | SCHEMA | [ PROPERTY ] GRAPH | TIME ZONE | [ PARAMETER ] <parameter name>
<session close command> ::=[ SESSION ] CLOSE
<start transaction command> ::=START TRANSACTION [ <transaction characteristics> ]
<transaction characteristics> ::=<transaction mode> [ { <comma> <transaction mode> }... ]
<transaction mode> ::=<transaction access mode> | <implementation-defined access mode>
<transaction access mode> ::=READ ONLY | READ WRITE
<implementation-defined access mode> ::=I_DONT_KNOW
<rollback command> ::=ROLLBACK
<commit command> ::=COMMIT
<nested procedure specification> ::=<left brace> <procedure specification> <right brace>
<procedure specification> ::=<catalog-modifying procedure specification> | <data-modifying procedure specification> | <query specification>
<catalog-modifying procedure specification> ::=<procedure body>
<nested data-modifying procedure specification> ::=<left brace> <data-modifying procedure specification> <right brace>
<data-modifying procedure specification> ::=<procedure body>
<nested query specification> ::=<left brace> <procedure specification> <right brace>
<query specification> ::=<procedure body>
<procedure body> ::=[ <at schema clause> ] [ <binding variable definition block> ] <statement block>
<binding variable definition block> ::=<binding variable definition> ...
<binding variable definition> ::=<graph variable definition> | <binding table variable definition> | <value variable definition>
<statement block> ::=<statement> [ <next statement> ... ]
<statement> ::=<linear catalog-modifying statement> | <linear data-modifying statement> | <composite query statement>
<next statement> ::=NEXT [ <yield clause> ] <statement>
<graph variable definition> ::=[ PROPERTY ] GRAPH <graph variable> <opt typed graph initializer>
<opt typed graph initializer> ::=[ [ <typed> ] <graph reference value type> ] <graph initializer>
<graph initializer> ::=<equals operator> <graph expression>
<binding table variable definition> ::=[ BINDING ] TABLE <binding table variable> <opt typed binding table initializer>
<opt typed binding table initializer> ::=[ [ <typed> ] <binding table reference value type> ] <binding table initializer>
<binding table initializer> ::=<equals operator> <binding table expression>
<value variable definition> ::=VALUE <value variable> <opt typed value initializer>
<opt typed value initializer> ::=[ [ <typed> ] <value type> ] <value initializer>
<value initializer> ::=<equals operator> <value expression>
<graph expression> ::=<nested graph query specification> | <object expression primary> | <graph reference> | <object name or binding variable> | <current graph>
<current graph> ::=CURRENT_PROPERTY_GRAPH | CURRENT_GRAPH
<nested graph query specification> ::=<nested query specification>
<binding table expression> ::=<nested binding table query specification> | <object expression primary> | <binding table reference> | <object name or binding variable>
<nested binding table query specification> ::=<nested query specification>
<object expression primary> ::=VARIABLE <value expression primary> | <parenthesized value expression> | <non-parenthesized value expression primary special case>
<linear catalog-modifying statement> ::=<simple catalog-modifying statement>...
<simple catalog-modifying statement> ::=<primitive catalog-modifying statement> | <call catalog-modifying procedure statement>
<primitive catalog-modifying statement> ::=<create schema statement> | <create graph statement> | <create graph type statement> | <drop schema statement> | <drop graph statement> | <drop graph type statement>
<create schema statement> ::=CREATE SCHEMA [ IF NOT EXISTS ] <catalog schema parent and name>
<drop schema statement> ::=DROP SCHEMA [ IF EXISTS ] <catalog schema parent and name>
<create graph statement> ::=CREATE { [ PROPERTY ] GRAPH [ IF NOT EXISTS ] | OR REPLACE [ PROPERTY ] GRAPH } <catalog graph parent and name> { <open graph type> | <of graph type> } [ <graph source> ]
<open graph type> ::=OPEN [ [ PROPERTY ] GRAPH ] TYPE
<of graph type> ::=<graph type like graph> | [ <typed> ] <graph type reference> | [ <typed> ] <nested graph type specification>
<graph type like graph> ::=LIKE <graph expression>
<graph source> ::=AS COPY OF <graph expression>
<drop graph statement> ::=DROP [ PROPERTY ] GRAPH [ IF EXISTS ] <catalog graph parent and name>
<create graph type statement> ::=CREATE { [ PROPERTY ] GRAPH TYPE [ IF NOT EXISTS ] | OR REPLACE [ PROPERTY ] GRAPH TYPE } <catalog graph type parent and name> <graph type source>
<graph type source> ::=[ AS ] <copy of graph type> | <graph type like graph> | [ AS ] <nested graph type specification>
<copy of graph type> ::=COPY OF { <graph type reference> | <external object reference> }
<drop graph type statement> ::=DROP [ PROPERTY ] GRAPH TYPE [ IF EXISTS ] <catalog graph type parent and name>
<call catalog-modifying procedure statement> ::=<call procedure statement>
<linear data-modifying statement> ::=<focused linear data-modifying statement> | <ambient linear data-modifying statement>
<focused linear data-modifying statement> ::=<focused linear data-modifying statement body> | <focused nested data-modifying procedure specification>
<focused linear data-modifying statement body> ::=<use graph clause> <simple linear data-accessing statement> [ <primitive result statement> ]
<focused nested data-modifying procedure specification> ::=<use graph clause> <nested data-modifying procedure specification>
<ambient linear data-modifying statement> ::=<ambient linear data-modifying statement body> | <nested data-modifying procedure specification>
<ambient linear data-modifying statement body> ::=<simple linear data-accessing statement> [ <primitive result statement> ]
<simple linear data-accessing statement> ::=<simple data-accessing statement>...
<simple data-accessing statement> ::=<simple query statement> | <simple data-modifying statement>
<simple data-modifying statement> ::=<primitive data-modifying statement> | <call data-modifying procedure statement>
<primitive data-modifying statement> ::=<insert statement> | <set statement> | <remove statement> | <delete statement>
<insert statement> ::=INSERT <insert graph pattern>
<set statement> ::=SET <set item list>
<set item list> ::=<set item> [ { <comma> <set item> }... ]
<set item> ::=<set property item> | <set all properties item> | <set label item>
<set property item> ::=<binding variable reference> <period> <property name> <equals operator> <value expression>
<set all properties item> ::=<binding variable reference> <equals operator> <left brace> [ <property key value pair list> ] <right brace>
<set label item> ::=<binding variable reference> <is or colon> <label set specification>
<label set specification> ::=<label name> [ { <ampersand> <label name> }... ]
<remove statement> ::=REMOVE <remove item list>
<remove item list> ::=<remove item> [ { <comma> <remove item> }... ]
<remove item> ::=<remove property item> | <remove label item>
<remove property item> ::=<binding variable reference> <period> <property name>
<remove label item> ::=<binding variable reference> <is or colon> <label set specification>
<delete statement> ::={ DETACH | NODETACH } DELETE <delete item list>
<delete item list> ::=<delete item> [ { <comma> <delete item> }... ]
<delete item> ::=<value expression>
<call data-modifying procedure statement> ::=<call procedure statement>
<composite query statement> ::=<composite query expression>
<composite query expression> ::=<composite query expression> <query conjunction> <composite query primary> | <composite query primary>
<query conjunction> ::=<set operator> | OTHERWISE
<set operator> ::=UNION [ <set quantifier> ] | EXCEPT [ <set quantifier> ] | INTERSECT [ <set quantifier> ]
<composite query primary> ::=<linear query statement>
<linear query statement> ::=<focused linear query statement> | <ambient linear query statement>
<focused linear query statement> ::=[ <focused linear query statement part> ... ] <focused linear query and primitive result statement part> | <focused primitive result statement> | <focused nested query specification> | <select statement>
<focused linear query statement part> ::=<use graph clause> <simple linear query statement>
<focused linear query and primitive result statement part> ::=<use graph clause> <simple linear query statement> <primitive result statement>
<focused primitive result statement> ::=<use graph clause> <primitive result statement>
<focused nested query specification> ::=<use graph clause> <nested query specification>
<ambient linear query statement> ::=[ <simple linear query statement> ] <primitive result statement> | <nested query specification>
<simple linear query statement> ::=<simple query statement>...
<simple query statement> ::=<primitive query statement> | <call query statement>
<primitive query statement> ::=<match statement> | <let statement> | <for statement> | <filter statement> | <order by and page statement>
<match statement> ::=<simple match statement> | <optional match statement>
<simple match statement> ::=MATCH <graph pattern binding table>
<optional match statement> ::=OPTIONAL <optional operand>
<optional operand> ::=<simple match statement> | <left brace> <match statement block> <right brace> | <left paren> <match statement block> <right paren>
<match statement block> ::=<match statement>...
<call query statement> ::=<call procedure statement>
<filter statement> ::=FILTER { <where clause> | <search condition> }
<let statement> ::=LET <let variable definition list>
<let variable definition list> ::=<let variable definition> [ { <comma> <let variable definition> }... ]
<let variable definition> ::=<value variable definition> | <value variable> <equals operator> <value expression>
<for statement> ::=FOR <for item> [ <for ordinality or offset> ]
<for item> ::=<for item alias> <list value expression>
<for item alias> ::=<identifier> IN
<for ordinality or offset> ::=WITH { ORDINALITY | OFFSET } <identifier>
<order by and page statement> ::=<order by clause> [ <offset clause> ] [ <limit clause> ] | <offset clause> [ <limit clause> ] | <limit clause>
<primitive result statement> ::=<return statement> [ <order by and page statement> ] | FINISH
<return statement> ::=RETURN <return statement body>
<return statement body> ::=[ <set quantifier> ] { <asterisk> | <return item list> } [ <group by clause> ] | NO BINDINGS
<return item list> ::=<return item> [ { <comma> <return item> }... ]
<return item> ::=<aggregating value expression> [ <return item alias> ]
<return item alias> ::=AS <identifier>
<select statement> ::=SELECT [ <set quantifier> ] <select item list> [ <select statement body> [ <where clause> ] [ <group by clause> ] [ <having clause> ] [ <order by clause> ] [ <offset clause> ] [ <limit clause> ] ]
<select item list> ::=<select item> [ { <comma> <select item> }... ]
<select item> ::=<aggregating value expression> [ <select item alias> ]
<select item alias> ::=AS <identifier>
<having clause> ::=HAVING <search condition>
<select statement body> ::=FROM <select graph match list> | <select query specification>
<select graph match list> ::=<select graph match> [ { <comma> <select graph match> }... ]
<select graph match> ::=<graph expression> <match statement>
<select query specification> ::=FROM <nested query specification> | FROM <graph expression> <nested query specification>
<call procedure statement> ::=[ OPTIONAL ] CALL <procedure call>
<procedure call> ::=<inline procedure call> | <named procedure call>
<inline procedure call> ::=[ <variable scope clause> ] <nested procedure specification>
<variable scope clause> ::=<left paren> [ <binding variable reference list> ] <right paren>
<binding variable reference list> ::=<binding variable reference> [ { <comma> <binding variable reference> }... ]
<named procedure call> ::=<procedure reference> <left paren> [ <procedure argument list> ] <right paren> [ <yield clause> ]
<procedure argument list> ::=<procedure argument> [ { <comma> <procedure argument> }... ]
<procedure argument> ::=<value expression>
<use graph clause> ::=USE <graph expression>
<at schema clause> ::=AT <schema reference>
<binding variable reference> ::=<binding variable>
<element variable reference> ::=<binding variable reference>
<path variable reference> ::=<binding variable reference>
<parameter> ::=<parameter name>
<graph pattern binding table> ::=<graph pattern> [ <graph pattern yield clause> ]
<graph pattern yield clause> ::=YIELD <graph pattern yield item list>
<graph pattern yield item list> ::=<graph pattern yield item> [ { <comma> <graph pattern yield item> }... ]
<graph pattern yield item> ::=<element variable reference> <path variable reference>
<graph pattern> ::=[ <match mode> ] <path pattern list> [ <keep clause> ] [ <graph pattern where clause> ]
<match mode> ::=<repeatable elements match mode> | <different edges match mode>
<repeatable elements match mode> ::=REPEATABLE <element bindings or elements>
<different edges match mode> ::=DIFFERENT <edge bindings or edges>
<element bindings or elements> ::=ELEMENT [ BINDINGS ] | ELEMENTS
<edge bindings or edges> ::=<edge synonym> [ BINDINGS ] | <edges synonym>
<path pattern list> ::=<path pattern> [ { <comma> <path pattern> }... ]
<path pattern> ::=[ <path variable declaration> ] [ <path pattern prefix> ] <path pattern expression>
<path variable declaration> ::=<path variable> <equals operator>
<keep clause> ::=KEEP <path pattern prefix>
<graph pattern where clause> ::=WHERE <search condition>
<path pattern prefix> ::=<path mode prefix> | <path search prefix>
<path mode prefix> ::=<path mode> [ <path or paths> ]
<path mode> ::=WALK | TRAIL | SIMPLE | ACYCLIC
<path search prefix> ::=<all path search> | <any path search> | <shortest path search>
<all path search> ::=ALL [ <path mode> ] [ <path or paths> ]
<path or paths> ::=PATH | PATHS
<any path search> ::=ANY [ <number of paths> ] [ <path mode> ] [ <path or paths> ]
<number of paths> ::=<unsigned integer specification>
<shortest path search> ::=<all shortest path search> | <any shortest path search> | <counted shortest path search> | <counted shortest group search>
<all shortest path search> ::=ALL SHORTEST [ <path mode> ] [ <path or paths> ]
<any shortest path search> ::=ANY SHORTEST [ <path mode> ] [ <path or paths> ]
<counted shortest path search> ::=SHORTEST <number of paths> [ <path mode> ] [ <path or paths> ]
<counted shortest group search> ::=SHORTEST <number of groups> [ <path mode> ] [ <path or paths> ] { GROUP | GROUPS }
<number of groups> ::=<unsigned integer specification>
<path pattern expression> ::=<path term> | <path multiset alternation> | <path pattern union>
<path multiset alternation> ::=<path term> <multiset alternation operator> <path term> [ { <multiset alternation operator> <path term> }... ]
<path pattern union> ::=<path term> <vertical bar> <path term> [ { <vertical bar> <path term> }... ]
<path term> ::=<path factor> | <path concatenation>
<path concatenation> ::=<path term> <path factor>
<path factor> ::=<path primary> | <quantified path primary> | <questioned path primary>
<quantified path primary> ::=<path primary> <graph pattern quantifier>
<questioned path primary> ::=<path primary> <question mark>
<path primary> ::=<element pattern> | <parenthesized path pattern expression> | <simplified path pattern expression>
<element pattern> ::=<node pattern> | <edge pattern>
<node pattern> ::=<left paren> <element pattern filler> <right paren>
<element pattern filler> ::=[ <element variable declaration> ] [ <is label expression> ] [ <element pattern predicate> ]
<element variable declaration> ::=[ TEMP ] <element variable>
<is label expression> ::=<is or colon> <label expression>
<is or colon> ::=IS | <colon>
<element pattern predicate> ::=<element pattern where clause> | <element property specification>
<element pattern where clause> ::=WHERE <search condition>
<element property specification> ::=<left brace> <property key value pair list> <right brace>
<property key value pair list> ::=<property key value pair> [ { <comma> <property key value pair> }... ]
<property key value pair> ::=<property name> <colon> <value expression>
<edge pattern> ::=<full edge pattern> | <abbreviated edge pattern>
<full edge pattern> ::=<full edge pointing left> | <full edge undirected> | <full edge pointing right> | <full edge left or undirected> | <full edge undirected or right> | <full edge left or right> | <full edge any direction>
<full edge pointing left> ::=<left arrow bracket> <element pattern filler> <right bracket minus>
<full edge undirected> ::=<tilde left bracket> <element pattern filler> <right bracket tilde>
<full edge pointing right> ::=<minus left bracket> <element pattern filler> <bracket right arrow>
<full edge left or undirected> ::=<left arrow tilde bracket> <element pattern filler> <right bracket tilde>
<full edge undirected or right> ::=<tilde left bracket> <element pattern filler> <bracket tilde right arrow>
<full edge left or right> ::=<left arrow bracket> <element pattern filler> <bracket right arrow>
<full edge any direction> ::=<minus left bracket> <element pattern filler> <right bracket minus>
<abbreviated edge pattern> ::=<left arrow> | <tilde> | <right arrow> | <left arrow tilde> | <tilde right arrow> | <left minus right> | <minus sign>
<parenthesized path pattern expression> ::=<left paren> [ <subpath variable declaration> ] [ <path mode prefix> ] <path pattern expression> [ <parenthesized path pattern where clause> ] <right paren>
<subpath variable declaration> ::=<subpath variable> <equals operator>
<parenthesized path pattern where clause> ::=WHERE <search condition>
<insert graph pattern> ::=<insert path pattern list>
<insert path pattern list> ::=<insert path pattern> [ <comma> <insert path pattern>... ]
<insert path pattern> ::=<insert node pattern> [ { <insert edge pattern> <insert node pattern> }... ]
<insert node pattern> ::=<left paren> [ <insert element pattern filler> ] <right paren>
<insert edge pattern> ::=<insert edge pointing left> | <insert edge pointing right> | <insert edge undirected>
<insert edge pointing left> ::=<left arrow bracket> [ <insert element pattern filler> ] <right bracket minus>
<insert edge pointing right> ::=<minus left bracket> [ <insert element pattern filler> ] <bracket right arrow>
<insert edge undirected> ::=<tilde left bracket> [ <insert element pattern filler> ] <right bracket tilde>
<insert element pattern filler> ::=<element variable declaration> [ <label and property set specification> ] | [ <element variable declaration> ] <label and property set specification>
<label and property set specification> ::=<label set specification> [ <element property specification> ] | [ <label set specification> ] <element property specification>
<label expression> ::=<label term> | <label disjunction>
<label disjunction> ::=<label expression> <vertical bar> <label term>
<label term> ::=<label factor> | <label conjunction>
<label conjunction> ::=<label term> <ampersand> <label factor>
<label factor> ::=<label primary> | <label negation>
<label negation> ::=<exclamation mark> <label primary>
<label primary> ::=<label name> | <wildcard label> | <parenthesized label expression>
<wildcard label> ::=<percent>
<parenthesized label expression> ::=<left paren> <label expression> <right paren>
<graph pattern quantifier> ::=<asterisk> | <plus sign> | <fixed quantifier> | <general quantifier>
<fixed quantifier> ::=<left brace> <unsigned integer> <right brace>
<general quantifier> ::=<left brace> [ <lower bound> ] <comma> [ <upper bound> ] <right brace>
<lower bound> ::=<unsigned integer>
<upper bound> ::=<unsigned integer>
<simplified path pattern expression> ::=<simplified defaulting left> | <simplified defaulting undirected> | <simplified defaulting right> | <simplified defaulting left or undirected> | <simplified defaulting undirected or right> | <simplified defaulting left or right> | <simplified defaulting any direction>
<simplified defaulting left> ::=<left minus slash> <simplified contents> <slash minus>
<simplified defaulting undirected> ::=<tilde slash> <simplified contents> <slash tilde>
<simplified defaulting right> ::=<minus slash> <simplified contents> <slash minus right>
<simplified defaulting left or undirected> ::=<left tilde slash> <simplified contents> <slash tilde>
<simplified defaulting undirected or right> ::=<tilde slash> <simplified contents> <slash tilde right>
<simplified defaulting left or right> ::=<left minus slash> <simplified contents> <slash minus right>
<simplified defaulting any direction> ::=<minus slash> <simplified contents> <slash minus>
<simplified contents> ::=<simplified term> | <simplified path union> | <simplified multiset alternation>
<simplified path union> ::=<simplified term> <vertical bar> <simplified term> [ { <vertical bar> <simplified term> }... ]
<simplified multiset alternation> ::=<simplified term> <multiset alternation operator> <simplified term> [ { <multiset alternation operator> <simplified term> }... ]
<simplified term> ::=<simplified factor low> | <simplified concatenation>
<simplified concatenation> ::=<simplified term> <simplified factor low>
<simplified factor low> ::=<simplified factor high> | <simplified conjunction>
<simplified conjunction> ::=<simplified factor low> <ampersand> <simplified factor high>
<simplified factor high> ::=<simplified tertiary> | <simplified quantified> | <simplified questioned>
<simplified quantified> ::=<simplified tertiary> <graph pattern quantifier>
<simplified questioned> ::=<simplified tertiary> <question mark>
<simplified tertiary> ::=<simplified direction override> | <simplified secondary>
<simplified direction override> ::=<simplified override left> | <simplified override undirected> | <simplified override right> | <simplified override left or undirected> | <simplified override undirected or right> | <simplified override left or right> | <simplified override any direction>
<simplified override left> ::=<left angle bracket> <simplified secondary>
<simplified override undirected> ::=<tilde> <simplified secondary>
<simplified override right> ::=<simplified secondary> <right angle bracket>
<simplified override left or undirected> ::=<left arrow tilde> <simplified secondary>
<simplified override undirected or right> ::=<tilde> <simplified secondary> <right angle bracket>
<simplified override left or right> ::=<left angle bracket> <simplified secondary> <right angle bracket>
<simplified override any direction> ::=<minus sign> <simplified secondary>
<simplified secondary> ::=<simplified primary> | <simplified negation>
<simplified negation> ::=<exclamation mark> <simplified primary>
<simplified primary> ::=<label name> | <left paren> <simplified contents> <right paren>
<where clause> ::=WHERE <search condition>
<yield clause> ::=YIELD <yield item list>
<yield item list> ::=<yield item> [ { <comma> <yield item> }... ]
<yield item> ::={ <yield item name> [ <yield item alias> ] }
<yield item name> ::=<field name>
<yield item alias> ::=AS <binding variable>
<group by clause> ::=GROUP BY <grouping element list>
<grouping element list> ::=<grouping element> [ { <comma> <grouping element> } ] | <empty grouping set>
<grouping element> ::=<binding variable reference>
<empty grouping set> ::=<left paren> <right paren>
<order by clause> ::=ORDER BY <sort specification list>
<aggregate function> ::=COUNT <left paren> <asterisk> <right paren> | <general set function> | <binary set function>
<general set function> ::=<general set function type> <left paren> [ <set quantifier> ] <value expression> <right paren>
<binary set function> ::=<binary set function type> <left paren> <dependent value expression> <comma> <independent value expression> <right paren>
<general set function type> ::=AVG | COUNT | MAX | MIN | SUM | COLLECT | STDDEV_SAMP | STDDEV_POP
<set quantifier> ::=DISTINCT | ALL
<binary set function type> ::=PERCENTILE_CONT | PERCENTILE_DISC
<dependent value expression> ::=[ <set quantifier> ] <numeric value expression>
<independent value expression> ::=<numeric value expression>
<sort specification list> ::=<sort specification> [ { <comma> <sort specification> }... ]
<sort specification> ::=<sort key> [ <ordering specification> ] [ <null ordering> ]
<sort key> ::=<aggregating value expression>
<ordering specification> ::=ASC | ASCENDING | DESC | DESCENDING
<null ordering> ::=NULLS FIRST | NULLS LAST
<limit clause> ::=LIMIT <unsigned integer specification>
<offset clause> ::=<offset synonym> <unsigned integer specification>
<offset synonym> ::=OFFSET | SKIP
<graph type specification> ::=[ PROPERTY ] GRAPH TYPE <nested graph type specification>
<nested graph type specification> ::=<left brace> <graph type specification body> <right brace>
<graph type specification body> ::=<element type definition list>
<element type definition list> ::=<element type definition> [ { <comma> <element type definition> }... ]
<element type definition> ::=<node type definition> | <edge type definition>
<node type definition> ::=<node type pattern> | <node synonym> <node type phrase>
<node type pattern> ::=<left paren> [ <node type name> ] [ <node type filler> ] <right paren>
<node type phrase> ::=[ TYPE ] <node type name> [ <node type filler> ] | <node type filler>
<node type name> ::=<element type name>
<node type filler> ::=<node type label set definition> | <node type property type set definition> | <node type label set definition> <node type property type set definition>
<node type label set definition> ::=<label set definition>
<node type property type set definition> ::=<property type set definition>
<edge type definition> ::=<edge type pattern> | [ <edge kind> ] <edge synonym> <edge type phrase>
<edge type pattern> ::=<full edge type pattern> | <abbreviated edge type pattern>
<edge type phrase> ::=[ TYPE ] <edge type name> [ <edge type filler> <endpoint definition> ] | <edge type filler> <endpoint definition>
<edge type name> ::=<element type name>
<edge type filler> ::=<edge type label set definition> | <edge type property type set definition> | <edge type label set definition> <edge type property type set definition>
<edge type label set definition> ::=<label set definition>
<edge type property type set definition> ::=<property type set definition>
<full edge type pattern> ::=<full edge type pattern pointing right> | <full edge type pattern pointing left> | <full edge type pattern undirected>
<full edge type pattern pointing right> ::=<source node type reference> <arc type pointing right> <destination node type reference>
<full edge type pattern pointing left> ::=<destination node type reference> <arc type pointing left> <source node type reference>
<full edge type pattern undirected> ::=<source node type reference> <arc type undirected> <destination node type reference>
<arc type pointing right> ::=<minus left bracket> <arc type filler> <bracket right arrow>
<arc type pointing left> ::=<left arrow bracket> <arc type filler> <right bracket minus>
<arc type undirected> ::=<tilde left bracket> <arc type filler> <right bracket tilde>
<arc type filler> ::=[ <edge type name> ] [ <edge type filler> ]
<abbreviated edge type pattern> ::=<abbreviated edge type pattern pointing right> | <abbreviated edge type pattern pointing left> | <abbreviated edge type pattern undirected>
<abbreviated edge type pattern pointing right> ::=<source node type reference> <right arrow> <destination node type reference>
<abbreviated edge type pattern pointing left> ::=<destination node type reference> <left arrow> <source node type reference>
<abbreviated edge type pattern undirected> ::=<source node type reference> <tilde> <destination node type reference>
<node type reference> ::=<source node type reference> | <destination node type reference>
<source node type reference> ::=<left paren> <source node type name> <right paren> | <left paren> [ <node type filler> ] <right paren>
<destination node type reference> ::=<left paren> <destination node type name> <right paren> | <left paren> [ <node type filler> ] <right paren>
<edge kind> ::=DIRECTED | UNDIRECTED
<endpoint definition> ::=CONNECTING <endpoint pair definition>
<endpoint pair definition> ::=<endpoint pair definition pointing right> | <endpoint pair definition pointing left> | <endpoint pair definition undirected> | <abbreviated edge type pattern>
<endpoint pair definition pointing right> ::=<left paren> <source node type name> <connector pointing right> <destination node type name> <right paren>
<endpoint pair definition pointing left> ::=<left paren> <destination node type name> <left arrow> <source node type name> <right paren>
<endpoint pair definition undirected> ::=<left paren> <source node type name> <connector undirected> <destination node type name> <right paren>
<connector pointing right> ::=TO | <right arrow>
<connector undirected> ::=TO | <tilde>
<source node type name> ::=<element type name>
<destination node type name> ::=<element type name>
<label set definition> ::=LABEL <label name> | LABELS <label name set> | <is or colon> <label name set>
<label name set> ::=<label name> [ <comma> <label name> ] | <left paren> <label name> [ <comma> <label name> ] <right paren>
<property type set definition> ::=<left brace> [ <property type definition list> ] <right brace>
<property type definition list> ::=<property type definition> [ { <comma> <property type definition> }... ]
<property type definition> ::=<property name> [ <typed> ] <property value type>
<property value type> ::=<value type>
<binding table type> ::=[ BINDING ] TABLE <field types specification>
<value type> ::=I_DONT_KNOW
<typed> ::=<double colon> | TYPED
<predefined type> ::=<boolean type> | <character string type> | <byte string type> | <numeric type> | <temporal type> | <reference value type>
<boolean type> ::={ BOOL | BOOLEAN } [ <not null> ]
<character string type> ::={ STRING | VARCHAR } [ <left paren> <max length> <right paren> ] [ <not null> ]
<byte string type> ::=BYTES [ <left paren> [ <min length> <comma> ] <max length> <right paren> ] [ <not null> ] | BINARY [ <left paren> <fixed length> <right paren> ] [ <not null> ] | VARBINARY [ <left paren> <max length> <right paren> ] [ <not null> ]
<min length> ::=<unsigned integer>
<max length> ::=<unsigned integer>
<fixed length> ::=<unsigned integer>
<numeric type> ::=<exact numeric type> | <approximate numeric type>
<exact numeric type> ::=<binary exact numeric type> | <decimal exact numeric type>
<binary exact numeric type> ::=<signed binary exact numeric type> | <unsigned binary exact numeric type>
<signed binary exact numeric type> ::=INT8 [ <not null> ] | INT16 [ <not null> ] | INT32 [ <not null> ] | INT64 [ <not null> ] | INT128 [ <not null> ] | INT256 [ <not null> ] | SMALLINT [ <not null> ] | INT [ <left paren> <precision> <right paren> ] [ <not null> ] | BIGINT | [ SIGNED ] <verbose binary exact numeric type> [ <not null> ]
<unsigned binary exact numeric type> ::=UINT8 [ <not null> ] | UINT16 [ <not null> ] | UINT32 [ <not null> ] | UINT64 [ <not null> ] | UINT128 [ <not null> ] | UINT256 [ <not null> ] | USMALLINT [ <not null> ] | UINT [ <left paren> <precision> <right paren> ] [ <not null> ] | UBIGINT [ <not null> ] | UNSIGNED <verbose binary exact numeric type> [ <not null> ]
<verbose binary exact numeric type> ::=INTEGER8 [ <not null> ] | INTEGER16 [ <not null> ] | INTEGER32 [ <not null> ] | INTEGER64 [ <not null> ] | INTEGER128 [ <not null> ] | INTEGER256 [ <not null> ] | SMALL INTEGER [ <not null> ] | INTEGER [ <left paren> <precision> <right paren> ] [ <not null> ] | BIG INTEGER [ <not null> ]
<decimal exact numeric type> ::={ DECIMAL | DEC } [ <left paren> <precision> [ <comma> <scale> ] <right paren> [ <not null> ] ]
<precision> ::=<unsigned decimal integer>
<scale> ::=<unsigned decimal integer>
<approximate numeric type> ::=FLOAT16 [ <not null> ] | FLOAT32 [ <not null> ] | FLOAT64 [ <not null> ] | FLOAT128 [ <not null> ] | FLOAT256 [ <not null> ] | FLOAT [ <left paren> <precision> [ <comma> <scale> ] <right paren> ] [ <not null> ] | REAL [ <not null> ] | DOUBLE [ PRECISION ] [ <not null> ]
<temporal type> ::=<temporal instant type> | <temporal duration type>
<temporal instant type> ::=<datetime type> | <localdatetime type> | <date type> | <time type> | <localtime type>
<temporal duration type> ::=<duration type>
<datetime type> ::=ZONED DATETIME [ <not null> ] | TIMESTAMP WITH TIMEZONE [ <not null> ]
<localdatetime type> ::=LOCAL DATETIME [ <not null> ] | TIMESTAMP [ WITHOUT TIMEZONE ] [ <not null> ]
<date type> ::=DATE [ <not null> ]
<time type> ::=ZONED TIME [ <not null> ] | TIME WITH TIMEZONE [ <not null> ]
<localtime type> ::=LOCAL TIME [ <not null> ] | TIME WITHOUT TIMEZONE [ <not null> ]
<duration type> ::=DURATION [ <not null> ]
<reference value type> ::=<graph reference value type> | <binding table reference value type> | <node reference value type> | <edge reference value type>
<graph reference value type> ::=<open graph reference value type> | <closed graph reference value type>
<closed graph reference value type> ::=<graph type specification> [ <not null> ]
<open graph reference value type> ::=OPEN [ PROPERTY ] GRAPH [ <not null> ]
<binding table reference value type> ::=<binding table type> [ <not null> ]
<node reference value type> ::=<open node reference value type> | <closed node reference value type>
<closed node reference value type> ::=<node type definition> [ <not null> ]
<open node reference value type> ::=[ OPEN ] <node synonym> [ <not null> ]
<edge reference value type> ::=<open edge reference value type> | <closed edge reference value type>
<closed edge reference value type> ::=<edge type definition> [ <not null> ]
<open edge reference value type> ::=[ OPEN ] <edge synonym> [ <not null> ]
<constructed type> ::=<list value type> | <record type>
<list value type> ::={ <list value type name> <left angle bracket> <value type> <right angle bracket> | <value type> <list value type name> } [ <left bracket> <max length> <right bracket> ] [ <not null> ]
<list value type name> ::=[ GROUP ] <list value type name synonym>
<list value type name synonym> ::=LIST | ARRAY
<record type> ::=[ OPEN ] RECORD [ <not null> ] | [ RECORD ] <field types specification> [ <not null> ]
<field types specification> ::=<left brace> [ <field type list> ] <right brace>
<field type list> ::=<field type> [ { <comma> <field type> }... ]
<dynamic union type> ::=<open dynamic union type> | <dynamic property value type> | <closed dynamic union type>
<open dynamic union type> ::=ANY
<dynamic property value type> ::=[ ANY ] PROPERTY VALUE
<closed dynamic union type> ::=ANY <left angle bracket> <component type list> <right angle bracket> | <component type list>
<component type list> ::=<component type> [ { <vertical bar> <component type> }... ]
<component type> ::=<value type>
<path value type> ::=PATH
<not null> ::=NOT NULL
<field type> ::=<field name> [ <typed> ] <value type>
<schema reference> ::=<absolute catalog schema reference> | <relative catalog schema reference> | <reference parameter>
<absolute catalog schema reference> ::=<solidus> | <absolute directory path> <schema name>
<catalog schema parent and name> ::=<absolute directory path> <schema name>
<relative catalog schema reference> ::=<predefined schema reference> | <relative directory path> <schema name>
<predefined schema reference> ::=HOME_SCHEMA | CURRENT_SCHEMA | <period>
<absolute directory path> ::=<solidus> [ <simple directory path> ]
<relative directory path> ::=<double period> [ { <solidus> <double period> }... <solidus> [ <simple directory path> ] ]
<simple directory path> ::={ <directory name> <solidus> }...
<graph reference> ::=<catalog object parent reference> <graph name> | <delimited graph name> | <home graph> | <reference parameter>
<catalog graph parent and name> ::=[ <catalog object parent reference> ] <graph name>
<home graph> ::=HOME_PROPERTY_GRAPH | HOME_GRAPH
<graph type reference> ::=<catalog graph type parent and name> | <reference parameter>
<catalog graph type parent and name> ::=[ <catalog object parent reference> ] <graph type name>
<binding table reference> ::=<catalog object parent reference> <binding table name> | <delimited binding table name> | <reference parameter>
<catalog binding table parent and name> ::=[ <catalog object parent reference> ] <binding table name>
<procedure reference> ::=<catalog procedure parent and name> | <reference parameter>
<catalog procedure parent and name> ::=[ <catalog object parent reference> ] <procedure name>
<catalog object parent reference> ::=<schema reference> [ <solidus> ] [ { <object name> <period> }... ] | { <object name> <period> }...
<reference parameter> ::=<parameter>
<external object reference> ::=I_DONT_KNOW
<search condition> ::=<boolean value expression>
<predicate> ::=<comparison predicate> | <exists predicate> | <null predicate> | <normalized predicate> | <directed predicate> | <labeled predicate> | <source/destination predicate> | <all_different predicate> | <same predicate>
<comparison predicate> ::=<comparison predicand> <comparison predicate part 2>
<comparison predicate part 2> ::=<comp op> <comparison predicand>
<comp op> ::=<equals operator> | <not equals operator> | <less than operator> | <greater than operator> | <less than or equals operator> | <greater than or equals operator>
<comparison predicand> ::=<common value expression> | <boolean predicand>
<exists predicate> ::=EXISTS { <left brace> <graph pattern> <right brace> | <left paren> <graph pattern> <right paren> | <left brace> <match statement block> <right brace> | <left paren> <match statement block> <right paren> | <nested query specification> }
<null predicate> ::=<value expression primary> <null predicate part 2>
<null predicate part 2> ::=IS [ NOT ] NULL
<value type predicate> ::=<value expression primary> <value type predicate part 2>
<value type predicate part 2> ::=IS [ NOT ] <typed> <value type>
<normalized predicate> ::=<string value expression> <normalized predicate part 2>
<normalized predicate part 2> ::=IS [ NOT ] [ <normal form> ] NORMALIZED
<directed predicate> ::=<element variable reference> <directed predicate part 2>
<directed predicate part 2> ::=IS [ NOT ] DIRECTED
<labeled predicate> ::=<element variable reference> <labeled predicate part 2>
<labeled predicate part 2> ::=<is labeled or colon> <label expression>
<is labeled or colon> ::=IS [ NOT ] LABELED | <colon>
<source/destination predicate> ::=<node reference> <source predicate part 2> | <node reference> <destination predicate part 2>
<node reference> ::=<element variable reference>
<source predicate part 2> ::=IS [ NOT ] SOURCE OF <edge reference>
<destination predicate part 2> ::=IS [ NOT ] DESTINATION OF <edge reference>
<edge reference> ::=<element variable reference>
<all_different predicate> ::=ALL_DIFFERENT <left paren> <element variable reference> <comma> <element variable reference> [ { <comma> <element variable reference> }... ] <right paren>
<same predicate> ::=SAME <left paren> <element variable reference> <comma> <element variable reference> [ { <comma> <element variable reference> }... ] <right paren>
<property_exists predicate> ::=PROPERTY_EXISTS <left paren> <element variable reference> <comma> <property name> <right paren>
<value specification> ::=<literal> | <parameter value specification>
<unsigned value specification> ::=<unsigned literal> | <parameter value specification>
<unsigned integer specification> ::=<unsigned integer> | <parameter>
<parameter value specification> ::=<parameter> | <predefined parameter>
<predefined parameter> ::=CURRENT_USER
<value expression> ::=<common value expression> | <boolean value expression>
<common value expression> ::=<numeric value expression> | <string value expression> | <datetime value expression> | <duration value expression> | <list value expression> | <record value expression> | <path value expression> | <reference value expression>
<reference value expression> ::=<graph reference value expression> | <binding table reference value expression> | <node reference value expression> | <edge reference value expression>
<graph reference value expression> ::=[ PROPERTY ] GRAPH <graph expression> | <value expression primary>
<binding table reference value expression> ::=[ BINDING ] TABLE <binding table expression> | <value expression primary>
<node reference value expression> ::=<value expression primary>
<edge reference value expression> ::=<value expression primary>
<record value expression> ::=<value expression primary>
<aggregating value expression> ::=<value expression>
<boolean value expression> ::=<boolean term> | <boolean value expression> OR <boolean term> | <boolean value expression> XOR <boolean term>
<boolean term> ::=<boolean factor> | <boolean term> AND <boolean factor>
<boolean factor> ::=[ NOT ] <boolean test>
<boolean test> ::=<boolean primary> [ IS [ NOT ] <truth value> ]
<truth value> ::=TRUE | FALSE | UNKNOWN
<boolean primary> ::=<predicate> | <boolean predicand>
<boolean predicand> ::=<parenthesized boolean value expression> | <non-parenthesized value expression primary>
<parenthesized boolean value expression> ::=<left paren> <boolean value expression> <right paren>
<numeric value expression> ::=<term> | <numeric value expression> <plus sign> <term> | <numeric value expression> <minus sign> <term>
<term> ::=<factor> | <term> <asterisk> <factor> | <term> <solidus> <factor>
<factor> ::=[ <sign> ] <numeric primary>
<numeric primary> ::=<value expression primary> | <numeric value function>
<value expression primary> ::=<parenthesized value expression> | <non-parenthesized value expression primary>
<parenthesized value expression> ::=<left paren> <value expression> <right paren>
<non-parenthesized value expression primary> ::=<non-parenthesized value expression primary special case> | <binding variable reference>
<non-parenthesized value expression primary special case> ::=<property reference>
<collection value constructor> ::=<list value constructor> | <record value constructor> | <path value constructor>
<numeric value function> ::=<length expression> | <absolute value expression> | <modulus expression> | <trigonometric function> | <general logarithm function> | <common logarithm> | <natural logarithm> | <exponential function> | <power function> | <square root> | <floor function> | <ceiling function>
<length expression> ::=<char length expression> | <byte length expression> | <path length expression>
<char length expression> ::={ CHAR_LENGTH | CHARACTER_LENGTH } <left paren> <character string value expression> <right paren>
<byte length expression> ::={ BYTE_LENGTH | OCTET_LENGTH } <left paren> <byte string value expression> <right paren>
<path length expression> ::=PATH_LENGTH <left paren> <path value expression> <right paren>
<absolute value expression> ::=ABS <left paren> <numeric value expression> <right paren>
<modulus expression> ::=MOD <left paren> <numeric value expression dividend> <comma> <numeric value expression divisor> <right paren>
<numeric value expression dividend> ::=<numeric value expression>
<numeric value expression divisor> ::=<numeric value expression>
<trigonometric function> ::=<trigonometric function name> <left paren> <numeric value expression> <right paren>
<trigonometric function name> ::=SIN | COS | TAN | COT | SINH | COSH | TANH | ASIN | ACOS | ATAN | DEGREES | RADIANS
<general logarithm function> ::=LOG <left paren> <general logarithm base> <comma> <general logarithm argument> <right paren>
<general logarithm base> ::=<numeric value expression>
<general logarithm argument> ::=<numeric value expression>
<common logarithm> ::=LOG10 <left paren> <numeric value expression> <right paren>
<natural logarithm> ::=LN <left paren> <numeric value expression> <right paren>
<exponential function> ::=EXP <left paren> <numeric value expression> <right paren>
<power function> ::=POWER <left paren> <numeric value expression base> <comma> <numeric value expression exponent> <right paren>
<numeric value expression base> ::=<numeric value expression>
<numeric value expression exponent> ::=<numeric value expression>
<square root> ::=SQRT <left paren> <numeric value expression> <right paren>
<floor function> ::=FLOOR <left paren> <numeric value expression> <right paren>
<ceiling function> ::={ CEIL | CEILING } <left paren> <numeric value expression> <right paren>
<string value expression> ::=<character string value expression> | <byte string value expression>
<character string value expression> ::=<character string concatenation> | <character string factor>
<character string concatenation> ::=<character string value expression> <concatenation operator> <character string factor>
<character string factor> ::=<character string primary>
<character string primary> ::=<value expression primary> | <string value function>
<byte string value expression> ::=<byte string concatenation> | <byte string factor>
<byte string factor> ::=<byte string primary>
<byte string primary> ::=<value expression primary> | <string value function>
<byte string concatenation> ::=<byte string value expression> <concatenation operator> <byte string factor>
<string value function> ::=<character string function> | <byte string function>
<character string function> ::=I_DONT_KNOW
<fold> ::={ UPPER | LOWER } <left paren> <character string value expression> <right paren>
<trim function> ::=<single-character trim function> | <multi-character trim function>
<single-character trim function> ::=TRIM <left paren> <trim operands> <right paren>
<multi-character trim function> ::={ BTRIM | LTRIM | RTRIM } <left paren> <trim source> [ <comma> <trim character string> ] <right paren>
<trim operands> ::=[ [ <trim specification> ] [ <trim character string> ] FROM ] <trim source>
<trim source> ::=<character string value expression>
<trim specification> ::=LEADING | TRAILING | BOTH
<trim character string> ::=<character string value expression>
<normalize function> ::=NORMALIZE <left paren> <character string value expression> [ <comma> <normal form> ] <right paren>
<normal form> ::=NFC | NFD | NFKC | NFKD
<byte string function> ::=I_DONT_KNOW
<byte string trim function> ::=TRIM <left paren> <byte string trim operands> <right paren>
<byte string trim operands> ::=[ [ <trim specification> ] [ <trim byte string> ] FROM ] <byte string trim source>
<byte string trim source> ::=<byte string value expression>
<trim byte string> ::=<byte string value expression>
<string length> ::=<numeric value expression>
<datetime value expression> ::=<datetime term> | <duration value expression> <plus sign> <datetime term> | <datetime value expression> <plus sign> <duration term> | <datetime value expression> <minus sign> <duration term>
<datetime term> ::=<datetime factor>
<datetime factor> ::=<datetime primary>
<datetime primary> ::=<value expression primary> | <datetime value function>
<datetime value function> ::=<date function> | <time function> | <datetime function> | <local time function> | <local datetime function>
<date function> ::=CURRENT_DATE | DATE <left paren> [ <date function parameters> ] <right paren>
<time function> ::=CURRENT_TIME | ZONED_TIME <left paren> [ <time function parameters> ] <right paren>
<local time function> ::=LOCAL_TIME [ <left paren> [ <time function parameters> ] <right paren> ]
<datetime function> ::=CURRENT_TIMESTAMP | ZONED_DATETIME <left paren> [ <datetime function parameters> ] <right paren>
<local datetime function> ::=LOCAL_TIMESTAMP | LOCAL_DATETIME <left paren> [ <datetime function parameters> ] <right paren>
<date function parameters> ::=<date string> | <record value constructor>
<time function parameters> ::=<time string> | <record value constructor>
<datetime function parameters> ::=<datetime string> | <record value constructor>
<duration value expression> ::=<duration term> | <duration value expression 1> <plus sign> <duration term 1> | <duration value expression 1> <minus sign> <duration term 1> | <datetime subtraction>
<datetime subtraction> ::=DURATION_BETWEEN <left paren> <datetime subtraction parameters> <right paren>
<datetime subtraction parameters> ::=<datetime value expression 1> <comma> <datetime value expression 2>
<duration term> ::=<duration factor> | <duration term 2> <asterisk> <factor> | <duration term 2> <solidus> <factor> | <term> <asterisk> <duration factor>
<duration factor> ::=[ <sign> ] <duration primary>
<duration primary> ::=<value expression primary> | <duration value function>
<duration value expression 1> ::=<duration value expression>
<duration term 1> ::=<duration term>
<duration term 2> ::=<duration term>
<datetime value expression 1> ::=<datetime value expression>
<datetime value expression 2> ::=<datetime value expression>
<duration value function> ::=<duration function> | <duration absolute value function>
<duration function> ::=DURATION <left paren> <duration function parameters> <right paren>
<duration function parameters> ::=<duration string> | <record value constructor>
<duration absolute value function> ::=ABS <left paren> <duration value expression> <right paren>
<list value expression> ::=<list concatenation> | <list primary>
<list concatenation> ::=<list value expression 1> <concatenation operator> <list primary>
<list value expression 1> ::=<list value expression>
<list primary> ::=<list value function> | <value expression primary>
<list value function> ::=<trim list function> <elements function>
<trim list function> ::=TRIM <left paren> <list value expression> <comma> <numeric value expression> <right paren>
<elements function> ::=ELEMENTS <left paren> <path value expression> <right paren>
<list value constructor> ::=<list value constructor by enumeration>
<list value constructor by enumeration> ::=[ <list value type name> ] <left bracket> [ <list element list> ] <right bracket>
<list element list> ::=<list element> [ { <comma> <list element> }... ]
<list element> ::=<value expression>
<record value constructor> ::=[ RECORD ] <fields specification>
<fields specification> ::=<left brace> [ <field list> ] <right brace>
<field list> ::=<field> [ { <comma> <field> }... ]
<field> ::=<field name> <colon> <value expression>
<path value expression> ::=<path value concatenation> | <path value primary>
<path value concatenation> ::=<path value expression 1> <concatenation operator> <path value primary>
<path value expression 1> ::=<path value expression>
<path value primary> ::=<value expression primary>
<path value constructor> ::=<path value constructor by enumeration>
<path value constructor by enumeration> ::=PATH <left bracket> <path element list> <right bracket>
<path element list> ::=<path element list start> [ <path element list step> ... ]
<path element list start> ::=<node reference value expression>
<path element list step> ::=<comma> <edge reference value expression> <comma> <node reference value expression>
<property reference> ::=<property source> <period> <property name>
<property source> ::=<node reference value expression> | <edge reference value expression> | <record value expression>
<value query expression> ::=VALUE <nested query specification>
<case expression> ::=<case abbreviation> | <case specification>
<case abbreviation> ::=NULLIF <left paren> <value expression> <comma> <value expression> <right paren> | COALESCE <left paren> <value expression> { <comma> <value expression> }... <right paren>
<case specification> ::=<simple case> | <searched case>
<simple case> ::=CASE <case operand> <simple when clause> ... [ <else clause> ] END
<searched case> ::=CASE <searched when clause>... [ <else clause> ] END
<simple when clause> ::=WHEN <when operand list> THEN <result>
<searched when clause> ::=WHEN <search condition> THEN <result>
<else clause> ::=ELSE <result>
<case operand> ::=<non-parenthesized value expression primary> | <element variable reference>
<when operand list> ::=<when operand> [ { <comma> <when operand> }... ]
<when operand> ::=<non-parenthesized value expression primary> | <comparison predicate part 2> | <null predicate part 2>
<result> ::=<result expression> | NULL
<result expression> ::=<value expression>
<cast specification> ::=CAST <left paren> <cast operand> AS <cast target> <right paren>
<cast operand> ::=<value expression>
<cast target> ::=<value type>
<element_id function> ::=ELEMENT_ID <left paren> <element variable reference> <right paren>
