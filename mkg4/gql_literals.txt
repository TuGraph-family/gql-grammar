409





IWD 39075:202y(E)

21 Lexical elements

« In consequence of WG3:UTC-069 Deleted 1 (one) editor's note »

21.1 <literal>

Function

Specify a value.

Format

<literal> ::=

<signed numeric literal>

| <general literal>

<general literal> ::=

<predefined type literal>

| <list literal>

| <record literal>

<predefined type literal> ::=

<boolean literal>

| <character string literal>

| <byte string literal>

| <temporal literal>

| <duration literal>

| <null literal>

<unsigned literal> ::=

<unsigned numeric literal>

| <general literal>

<boolean literal> ::=

TRUE | FALSE | UNKNOWN

<character string literal> ::=

<single quoted character sequence>

| <double quoted character sequence>

« WG3:UTC-044 »

<unbroken character string literal> ::=

[ <no escape> ] <unbroken single quoted character sequence>

| [ <no escape> ] <unbroken double quoted character sequence>

<single quoted character sequence> ::=

[ <no escape> ] <unbroken single quoted character sequence>

[ { <separator> <unbroken single quoted character sequence> }... ]

<double quoted character sequence> ::=

[ <no escape> ] <unbroken double quoted character sequence>

[ { <separator> <unbroken double quoted character sequence> }... ]

<accent quoted character sequence> ::=

[ <no escape> ] <unbroken accent quoted character sequence>

410

IWD 39075:202y(E)

21.1 <literal>

[ { <separator> <unbroken accent quoted character sequence> }... ]

<no escape> ::=

<commercial at>

<unbroken single quoted character sequence> ::=

<quote> [ <single quoted character representation> ... ] <quote>

<unbroken double quoted character sequence> ::=

<double quote> [ <double quoted character representation>... ] <double quote>

<unbroken accent quoted character sequence> ::=

<grave accent> [ <accent quoted character representation>... ] <grave accent>

<single quoted character representation> ::=

<character representation>

!! See the Syntax Rules.

<double quoted character representation> ::=

<character representation>

!! See the Syntax Rules.

<accent quoted character representation> ::=

<character representation>

!! See the Syntax Rules.

« WG3:UTC-044 »

<character representation> ::=

!! See the Syntax Rules.

<string literal character> ::=

!! See the Syntax Rules.

<escaped character> ::=

<escaped reverse solidus>

| <escaped quote>

| <escaped double quote>

| <escaped grave accent>

| <escaped tab>

| <escaped backspace>

| <escaped newline>

| <escaped carriage return>

| <escaped form feed>

| <unicode escape value>

<escaped reverse solidus> ::=

<reverse solidus> <reverse solidus>

<escaped quote> ::=

<reverse solidus> <quote>

<escaped double quote> ::=

<reverse solidus> <double quote>

« WG3:UTC-074 »

<escaped grave accent> ::=

<reverse solidus> <grave accent>

« WG3:UTC-074 deleted one alternative »

« WG3:UTC-074 deleted one production »

<escaped tab> ::=

<reverse solidus> t

411

IWD 39075:202y(E)

21.1 <literal>

<escaped backspace> ::=

<reverse solidus> b

<escaped newline> ::=

<reverse solidus> n

<escaped carriage return> ::=

<reverse solidus> r

<escaped form feed> ::=

<reverse solidus> f

<unicode escape value> ::=

<unicode 4 digit escape value>

| <unicode 6 digit escape value>

<unicode 4 digit escape value> ::=

<reverse solidus> u <hex digit> <hex digit> <hex digit> <hex digit>

<unicode 6 digit escape value> ::=

<reverse solidus> U <hex digit> <hex digit> <hex digit> <hex digit> <hex digit>

<hex digit>

<byte string literal> ::=

X <quote> [ <space> ... ]

[ { <hex digit> [ <space> ... ] <hex digit> [ <space>... ] }...

] <quote>

[ { <separator> <quote> [ <space>... ] [ { <hex digit> [ <space> ... ]

<hex digit> [ <space>... ] }... ] <quote> }... ]

<signed numeric literal> ::=

[ <sign> ] <unsigned numeric literal>

<unsigned numeric literal> ::=

<exact numeric literal>

| <approximate numeric literal>

« WG3:UTC-074 »

<exact numeric literal> ::=

<unsigned integer>

| <unsigned decimal in common notation> [ <exact number suffix> ]

| <unsigned decimal in scientific notation> [ <exact number suffix> ]

| <unsigned decimal integer> [ <exact number suffix> ]

<approximate numeric literal> ::=

<unsigned decimal in common notation> <approximate number suffix>

| <unsigned decimal in scientific notation> [ <approximate number suffix> ]

| <unsigned decimal integer> <approximate number suffix>

<exact number suffix> ::=

M

<approximate number suffix> ::=

F | D

<sign> ::=

<plus sign>

| <minus sign>

<unsigned integer> ::=

<unsigned decimal integer>

| <unsigned hexadecimal integer>

| <unsigned octal integer>

| <unsigned binary integer>

412

IWD 39075:202y(E)

21.1 <literal>

« WG3:UTC-074 »

<unsigned decimal in common notation> ::=

<unsigned decimal integer> { [ <period> [ <unsigned decimal integer> ] ] }

| <period> <unsigned decimal integer>

<unsigned decimal integer> ::=

<digit> [ { [ <underscore> ] <digit> }... ]

<unsigned hexadecimal integer> ::=

0x { [ <underscore> ] <hex digit> }...

<unsigned octal integer> ::=

0o { [ <underscore> ] <octal digit> }...

<unsigned binary integer> ::=

0b { [ <underscore> ] <binary digit> }...

<signed decimal integer> ::=

[ <sign> ] <unsigned decimal integer>

« Editorial: Resolve Seq.#944 P00-USA-443 »

« WG3:UTC-074 »

<unsigned decimal in scientific notation> ::=

<mantissa> E <exponent>

!! See the Syntax Rules.

<mantissa> ::=

<exact numeric literal>

<exponent> ::=

<signed decimal integer>

« WG3:UTC-117 »

<temporal literal> ::=

<date literal>

| <time literal>

| <datetime literal>

| <SQL-datetime literal>

<date literal> ::=

DATE <date string>

<time literal> ::=

TIME <time string>

<datetime literal> ::=

{ DATETIME | TIMESTAMP } <datetime string>

<date string> ::=

<unbroken character string literal>

<time string> ::=

<unbroken character string literal>

<datetime string> ::=

<unbroken character string literal>

« WG3:UTC-117 »

<SQL-datetime literal> ::=

!! See the Syntax Rules.

<duration literal> ::=

DURATION <duration string>

413

IWD 39075:202y(E)

21.1 <literal>

| <SQL-interval literal>

<duration string> ::=

<unbroken character string literal>

<SQL-interval literal> ::=

!! See the Syntax Rules.

<null literal> ::=

NULL

<list literal> ::=

<list value constructor by enumeration>

<record literal> ::=

<record value constructor>

Syntax Rules

« WG3:UTC-074 »

1)

In an <unsigned hexadecimal integer> , <unsigned octal integer>, or <unsigned binary integer> , there shall be no <separator> between the radix indicators “0x”, “0o”, “0b” and the first <hex digit>,

<octal digit> , <binary digit>, or <underscore> .

2)

An <unsigned decimal integer> that immediately contains <underscore>s is equivalent to the same

<unsigned decimal integer> with every <underscore> removed.

3)

An <unsigned hexadecimal integer> that immediately contains <underscore>s is equivalent to the same <unsigned hexadecimal integer> with every <underscore> removed.

4)

An <unsigned octal integer> that immediately contains <underscore> s is equivalent to the same

<unsigned octal integer> with every <underscore> removed.

5)

An <unsigned binary integer> that immediately contains <underscore>s is equivalent to the same

<unsigned binary integer> with every <underscore> removed.

6)

An <unsigned hexadecimal integer> is equivalent to an <unsigned decimal integer> containing a series of <digit>s that represent the same integer number as the series of <hex digit> s.

7)

An <unsigned octal integer> is equivalent to an <unsigned decimal integer> containing a series of

<digit> s that represent the same integer number as the series of <octal digit>s.

8)

An <unsigned binary integer> is equivalent to an <unsigned decimal integer> containing a series of <digit>s that represent the same integer number as the series of <binary digit> s.

« WG3:UTC-074 »

9)

In an <unsigned decimal in scientific notation> , the exponent indicator “E” may be represented

either in upper-case (as “E”) or in lower-case (as “e”).

10) In an <approximate numeric literal> , the <approximate number suffix> “F” or “D” may be represented either in upper-case (as “F” or “D”) or in lower-case (as “f” or “d”).

11) There shall be no <separator> before the <approximate number suffix> in an <approximate numeric

literal>.

12) A <mantissa> shall not contain an <unsigned integer> that is not an <unsigned decimal integer> .

13) The maximum number of <digit> s immediately contained in an <unsigned integer> is implemen-

tation-defined (IL010) but shall not be less than 9.

« WG3:UTC-074 »

414

IWD 39075:202y(E)

21.1 <literal>

14) An <exact numeric literal> that is an <unsigned decimal integer> has an implicit <period> following the last <digit> .

15) In an <exact numeric literal> the <exact number suffix> “M” may be represented either in upper-case (as “M”) or in lower-case (as “m”).

16) There shall be no <separator> before the <exact number suffix> in an <exact numeric literal> .

17) The declared type of an <exact numeric literal> ENL is an exact numeric type whose scale is the number of <digit> s to the right of the <period> . There shall be an exact numeric type capable of representing the value of ENL exactly.

« WG3:UTC-074 »

18) The declared type of an <approximate numeric literal> ANL is determined as follows.

Case:

a)

If ANL simply contains the <approximate number suffix> “F” or “f”, then the declared type of ANL is the regular approximate numeric type specified by FLOAT.

b)

If ANL simply contains the <approximate number suffix> “D” or “d”, then the declared type of ANL is the double approximate numeric type specified by DOUBLE.

c)

Otherwise, the declared type of ANL is an implementation-defined (ID079) approximate

numeric type.

19) The value of an <approximate numeric literal> ANL shall not be greater than the maximum value nor less than the minimum value that can be represented by the declared type of ANL.

20) The declared type of a <boolean literal> is the Boolean type.

21) The <character string literal> specifies the character string specified by the <single quoted character

sequence> or the <double quoted character sequence> that it contains.

22) The <unbroken character string literal> specifies the character string specified by the <unbroken

single quoted character sequence> or the <unbroken double quoted character sequence> that it contains.

23) The <single quoted character sequence> specifies the character string comprising the quote-separ-

ated concatenation of the character strings specified by the <unbroken single quoted character

sequence>s that it contains.

24) The <double quoted character sequence> specifies the character string comprising the double

quote-separated concatenation of the character strings specified by the <unbroken double quoted

character sequence> s that it contains.

25) The <accent quoted character sequence> specifies the character string comprising the accent-sep-

arated concatenation of the character strings specified by the <unbroken accent quoted character

sequence>s that it contains.

26) The <unbroken single quoted character sequence> specifies the character string comprising the

sequence of characters defined by the <single quoted character representation>s that it contains.

27) The <unbroken double quoted character sequence> specifies the character string comprising the

sequence of characters defined by the <double quoted character representation>s that it contains.

28) The <unbroken accent quoted character sequence> specifies the character string comprising the

sequence of characters defined by the <accent quoted character representation>s that it contains.

« WG3:UTC-044 »

415

IWD 39075:202y(E)

21.1 <literal>

29) There shall be no <separator> between <no escape> and an <unbroken single quoted character

sequence>, <unbroken double quoted character sequence>, or <unbroken accent quoted character

sequence>.

30) For every BNF non-terminal NT simply contained in an <unbroken character string literal>, <single

quoted character sequence> , <double quoted character sequence>, or <accent quoted character

sequence> CS. If CS immediately contains the <no escape> , then character escaping is said to be disabled in NT; otherwise, character escaping is said to be enabled in NT.

31) If <single quoted character representation> CR is specified, then:

a)

If character escaping is enabled in CR, then CR hall not be a <quote> or a <reverse solidus>

unless either of these occurs as part of an <escaped character>.

b)

Otherwise, character escaping is disabled in CR and CR shall not be a <quote> .

32) If <double quoted character representation> CR is specified, then:

a)

If character escaping is enabled in CR, then CR hall not be a <double quote> or a <reverse

solidus> unless either of these occurs as part of an <escaped character> .

b)

Otherwise, character escaping is disabled in CR and CR shall not be a <double quote>.

33) The <accent quoted character representation> CR is specified, then:

a)

If character escaping is enabled in CR, then CR hall not be a <grave accent> or a <reverse

solidus> unless either of these occurs as part of an <escaped character> .

b)

Otherwise, character escaping is disabled in CR and CR shall not be a <grave accent>.

34) If character escaping is enabled in a <character representation> CR, then CR shall conform to the Format and Syntax Rules of a <string literal character> or an <escaped character>; otherwise, character escaping is disabled in CR and CR should conform to the Format and Syntax Rules of

<string literal character> only.

35) If the <character representation> CR is specified, then:

a)

Case:

i)

If character escaping is enabled in CR, then any character in CR except for those

occurring as part of an <escaped character> is considered a <string literal character>.

ii)

Otherwise, character escaping is disabled in CR and any character in CR is considered

a <string literal character>.

b)

For every <string literal character> CH contained in CR:

i)

If CH is not <whitespace>, then it shall not be in the Unicode General Category Class

“Cc”.

NOTE 226 — In particular, this excludes BACKSPACE (U+0008).

ii)

Whether CH shall not be a <bidirectional control character> is implementation-defined

(IA019).

NOTE 227 — This mitigates CVE-2021-42574.

iii)

CH shall not be in the Unicode General Category Class “Cn”.

NOTE 228 — The Unicode General Category classes “Cc” and “Cn”, are assigned to Unicode characters

that are, respectively, Control codes (other) and Not Assigned codes.

NOTE 229 — Despite these restrictions, any character can still be expressed in a <character repres-

entation> through the use of a suitable <escaped character> .

« WG3:UTC-074 »

416

IWD 39075:202y(E)

21.1 <literal>

36) In an <escaped character> , there shall be no <separator> after the leading <reverse solidus> .

37) In an <escaped character> each <escaped reverse solidus> represents a <reverse solidus> character.

38) In an <escaped character> each <escaped quote> represents a <quote> character.

39) In an <escaped character> each <escaped double quote> represents a <double quote> character.

40) In an <escaped character> each <escaped grave accent> represents a <grave accent> character.

41) In an <escaped character> each <escaped tab> represents the Unicode character identified by the code point U+0009.

42) In an <escaped character> each <escaped backspace> represents the Unicode character identified by the code point U+0008.

43) In an <escaped character> each <escaped newline> represents the Unicode character identified by the code point U+000A.

44) In an <escaped character> each <escaped carriage return> represents the Unicode character identified by the code point U+000D.

45) In an <escaped character> each <escaped form feed> represents the Unicode character identified by the code point U+000C.

46) In an <escaped character> each <unicode escape value> represents the Unicode character identified by the code point.

47) The declared type of a <character string literal> is character string.

48) In a <byte string literal>, the sequence

<quote> [ <space>... ] { <hex digit> [ <space> ... ]

<hex digit> [ <space> ... ] }... <quote>

is equivalent to the sequence

<quote> { <hex digit> <hex digit> }... <quote>

NOTE 230 — The <hex digit>s in the equivalent sequence are in the same sequence and relative sequence as in the original <byte string literal> .

49) In a <byte string literal>, the sequence

<quote> { <hex digit> <hex digit> }... <quote> <separator>

<quote> { <hex digit> <hex digit> }... <quote>

is equivalent to the sequence

<quote> { <hex digit> <hex digit> }... { <hex digit> <hex digit> }... <quote>

NOTE 231 — The <hex digit>s in the equivalent sequence are in the same sequence and relative sequence as in the original <byte string literal> .

50) In a <byte string literal>, the introductory 'X' may be represented either in upper-case (as 'X') or in lower-case (as 'x').

51) In a <character string literal>, or <byte string literal> , a <separator> shall contain a <newline>.

52) The declared type of a <byte string literal> is a byte string type. Each <hex digit> appearing in the literal is equivalent to a quartet of bits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F are interpreted as

0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, and

1111, respectively. The <hex digit> s a, b, c, d, e, and f have respectively the same values as the <hex

digit> s A, B, C, D, E, and F.

417

IWD 39075:202y(E)

21.1 <literal>

53) The character string specified by the <unbroken character string literal> immediately contained

in <date string> shall conform to the representation specified in clause 5.2, “Date” of ISO 8601-

1:2019 as extended by clauses 4.3, “Additional explicit forms” and 4.4, “Numerical extensions” of

ISO 8601-2:2019.

54) The declared type of <date literal> is DATE.

55) The character string specified by the <unbroken character string literal> immediately contained

in <time string> shall conform to the representation specified in clause 5.3, “Time of day” of ISO

8601-1:2019 as extended by clauses 4.3, “Additional explicit forms” and 4.4, “Numerical extensions”

of ISO 8601-2:2019.

« WG3:UTC-117 »

56) If the <time string> does not contain a representation of a time zone displacement, then the declared type of <time literal> is LOCAL TIME; otherwise, the declared type of <time literal> is ZONED TIME.

« WG3:UTC-117 »

57) The character string specified by the <unbroken character string literal> immediately contained

in <datetime string> shall conform to the representation specified in clause 5.4, “Date and time of

day” of ISO 8601-1:2019 as extended by clauses 4.3, “Additional explicit forms” and 4.4, “Numerical

extensions” of ISO 8601-2:2019.

« WG3:UTC-117 Deleted 1 (one) editor's note »

« WG3:UTC-117 »

58) If the <datetime string> does not contain a representation of a time zone displacement, then the

declared type of <datetime literal> is LOCAL DATETIME, otherwise, the declared type of <datetime

literal> is ZONED DATETIME.

59) The declared type of <duration literal> is DURATION.

60) The declared type DT of a <null literal> NS is defined as follows.

Case:

** Editor’s Note (number 64) **

The way in which the declared type of NULL is determined may require further adjustment (as per the discussion of

RKE-048).

a)

If DT can be determined by the context in which NS appears, then NS is effectively replaced

by CAST( NS AS DT).

NOTE 232 — In every such context, NS is uniquely associated with some expression or site of declared type

DT, which thereby becomes the declared type of NS.

b)

Otherwise, it is implementation-defined (IA014) whether an exception condition is raised:

syntax error or access rule violation — invalid syntax (42001). If an exception condition is not

raised, then DT is implementation-defined (ID085).

61) The <unbroken character string literal> immediately contained in <duration string> shall conform to the representation specified in clause 5.5.2, “Duration” of ISO 8601-1:2019 as extended by clauses

4.3, “Additional explicit forms” and 4.4, “Numerical extensions” of ISO 8601-2:2019.

« WG3:UTC-117 »

62) <SQL-datetime literal> shall conform to the Syntax Rules of <datetime literal> in ISO/IEC 9075-

2:2023.

63) <SQL-interval literal> shall conform to the Syntax Rules of <interval literal> in ISO/IEC 9075-2:2023.

64) If <SQL-interval literal> is specified, then:

418

IWD 39075:202y(E)

21.1 <literal>

a)

If <SQL-interval literal> contains a <years value> y, then let Y be 'Y y'; otherwise, let Y be the zero-length character string.

b)

If <SQL-interval literal> contains a <months value> m, then let M be 'M m'; otherwise, let M be the zero-length character string.

c)

If <SQL-interval literal> contains a <days value> d, then let D be 'D d'; otherwise, let D be the zero-length character string.

d)

If <SQL-interval literal> contains an <hours value> h, then let H be 'H h'; otherwise, let H be the zero-length character string.

e)

If <SQL-interval literal> contains a <minutes value> mn, then let MN be 'M mn'; otherwise, let MN be the zero-length character string.

f)

If <SQL-interval literal> contains a <seconds value> s, then let S be 'S s'; otherwise, let S be the zero-length character string.

g)

If <SQL-interval literal> contains an <hours value>, <minutes value> , or <seconds value> , then let T be 'T'; otherwise, let T be the zero-length character string.

h)

If <SQL-interval literal> contains at most one <minus sign> , then let SN be '-'; otherwise, let SN be the zero-length character string.

<SQL-interval literal> it is equivalent to the <duration literal>:

DURATION ' SN P YMDTHMNS'

65) Every <value expression> contained in a <list element> of the <list element list> of the <list value

constructor by enumeration> contained in a <list literal> shall be a <literal> .

66) The declared type of <list literal> is the declared type of the immediately contained <list value

constructor by enumeration> .

67) Every <value expression> contained in a <field> of the <field list> of the <record value constructor>

contained in a <record literal> shall be a <literal>.

« WG3:UTC-096R1 Deleted 1 (one) SR »

General Rules

1)

Except when it is contained in an <exact numeric literal>, the value of an <unsigned integer> is the numeric value determined by application of the normal mathematical interpretation of positional

decimal notation to the series of <digit> s that constitutes the <unsigned integer> .

2)

The value of an <exact numeric literal> is the numeric value determined by application of the normal

mathematical interpretation of positional decimal notation to the source characters that constitute

the <exact numeric literal>.

3)

Let ANL be an <approximate numeric literal>. Let ANDT be the declared type of ANL. Let ANV be the product of the exact numeric value represented by the <mantissa> of ANL and the number

obtained by raising the number 10 to the power of the exact numeric value represented by the

<exponent> of ANL. If ANV is a value of ANDT, then the value of ANL is ANV; otherwise, the value of ANL is a value of ANDT obtained from ANV by rounding or truncation. The choice of whether to

round or truncate is implementation-defined (IA005).

4)

The <sign> in a <signed numeric literal> is a monadic arithmetic operator. The monadic arithmetic operators + and − specify monadic plus and monadic minus, respectively. If neither monadic plus

nor monadic minus are specified in a <signed numeric literal>, or if monadic plus is specified, then

419

IWD 39075:202y(E)

21.1 <literal>

the literal is positive. If monadic minus is specified in a <signed numeric literal>, then the literal is negative.

5)

The truth value of a <boolean literal> is True if TRUE is specified, is False if FALSE is specified, and is Unknown if UNKNOWN is specified.

6)

The value of a <character string literal> is the character string that it specifies.

7)

The value of an <unbroken character string literal> is the character string that it specifies.

8)

The value of a <byte string literal> is the byte string comprising sequence of bits defined by the

<hex digit>s that it contains. Each <hex digit> appearing in the literal is equivalent to a quartet of bits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F are interpreted as 0000, 0001, 0010, 0011, 0100,

0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, and 1111, respectively. The <hex

digit> s a, b, c, d, e, and f have respectively the same values as the <hex digit>s A, B, C, D, E, and F.

9)

If <date string> contains a representation with reduced precision, then the lowest valid value for

each of the omitted lower order time scale components is implicit.

10) The value of a <date literal> is a calendar date in the Gregorian calendar.

11) If <time string> contains a representation with reduced precision, then value for each of the omitted lower order time scale components is 0 (zero).

12) The value of a <time literal> is a time of day. If the <time string> contained a representation of a time shift, then the time shift information is preserved.

13) If <datetime string> contains a representation with reduced precision, then value for each of the omitted lower order time scale components is 0 (zero).

14) The value of a <datetime literal> is a time. If the <datetime string> contained a representation of a time shift, then the time shift information is preserved.

15) The value of a <duration literal> is a duration or a negative duration.

NOTE 233 — See clause 4.4.1.9 Duration of ISO 8601-2:2019 for the definition of a negative duration.

16) The value of a <null literal> is the null value.

17) The value of <list literal> is the value of the immediately contained <list value constructor by enu-

meration>.

18) The value of <record literal> is the value of the immediately contained <record value constructor>.

Conformance Rules

1)

Without Feature GB13, “Hexadecimal literals”, conforming GQL language shall not contain an

<unsigned hexadecimal integer> .

2)

Without Feature GB14, “Octal literals”, conforming GQL language shall not contain an <unsigned

octal integer> .

3)

Without Feature GB15, “Binary literals”, conforming GQL language shall not contain an <unsigned

binary integer> .

« WG3:UTC-044 »

4)

Without Feature GB41, “Opt-out character escaping”, conforming GQL language shall not contain

<no escape>.

« WG3:UTC-074 »

420

IWD 39075:202y(E)

21.1 <literal>

5)

Without Feature GB43, “Approximate number in common notation or as decimal integer with suffix”,

conforming GQL language shall not contain an <approximate numeric literal> that is an <unsigned

decimal in common notation> followed by an <approximate number suffix> or an <unsigned decimal

integer> followed by an <approximate number suffix>.

6)

Without Feature GB44, “Approximate number in scientific notation with suffix”, conforming GQL

language shall not contain an <approximate numeric literal> that is an <unsigned decimal in scientific

notation> followed by an <approximate number suffix>.

7)

Without Feature GB45, “Optional float number suffix”, conforming GQL language shall not contain

an <approximate numeric literal> that is an <unsigned decimal in scientific notation> followed by an <approximate number suffix> .

8)

Without Feature GB46, “Optional double number suffix”, conforming GQL language shall not contain

an <approximate numeric literal> that simply contains an <approximate number suffix> that is “d”

or “D”.

9)

Without Feature GB47, “Exact number in common notation without suffix”, conforming GQL language

shall not contain an <exact numeric literal> that is an <unsigned decimal in common notation>.

10) Without Feature GB48, “Exact number in common notation or as decimal integer with suffix”, con-

forming GQL language shall not contain an <exact numeric literal> that is an <unsigned decimal in

common notation> followed by an <exact number suffix> or an <unsigned decimal integer> followed by an <exact number suffix> .

11) Without Feature GB49, “Exact number in scientific notation with suffix”, conforming GQL language

shall not contain an <exact numeric literal> that is an <unsigned decimal in scientific notation>

followed by an <exact number suffix>.

« WG3:UTC-117 »

12) Without Feature GC23, “Date and time support”, conforming GQL language shall not contain a

<temporal literal>.

13) Without Feature GC24, “Durations and temporal arithmetic support”, conforming GQL language

shall not contain a <duration literal> .

14) Without Feature GC25, “SQL datetime and interval formats”, conforming GQL language shall not

contain an <SQL-datetime literal> or an <SQL-interval literal> .

« WG3:UTC-042 3 Subclauses moved »

421





IWD 39075:202y(E)

21.2 Names and variables

21.2 Names and variables

Function

Specify names and variables.

Format

<object name> ::=

<identifier>

« WG3:UTC-039R1 »

<object name or binding variable> ::=

<regular identifier>

<directory name> ::=

<identifier>

<schema name> ::=

<identifier>

« WG3:UTC-039R1 »

<graph name> ::=

<regular identifier>

| <delimited graph name>

<delimited graph name> ::=

<delimited identifier>

<graph type name> ::=

<identifier>

<element type name> ::=

<identifier>

« WG3:UTC-039R1 »

<binding table name> ::=

<regular identifier>

| <delimited binding table name>

<delimited binding table name> ::=

<delimited identifier>

<procedure name> ::=

<identifier>

« WG3:UTC-039R1 Deleted 1 (one) production »

<label name> ::=

<identifier>

<property name> ::=

<identifier>

<field name> ::=

<identifier>

<parameter name> ::=

<dollar sign> <separated identifier>

<variable> ::=

422

IWD 39075:202y(E)

21.2 Names and variables

<graph variable>

| <graph pattern variable>

| <binding table variable>

| <value variable>

| <binding variable>

<graph variable> ::=

<binding variable>

<graph pattern variable> ::=

<element variable>

| <path or subpath variable>

<path or subpath variable> ::=

<path variable>

| <subpath variable>

<element variable> ::=

<binding variable>

<path variable> ::=

<binding variable>

« WG3:UTC-080 »

<subpath variable> ::=

<regular identifier>

« Editorial: Deleted 1 (one) editor's note »

<binding table variable> ::=

<binding variable>

<value variable> ::=

<binding variable>

<binding variable> ::=

<regular identifier>

Syntax Rules

« WG3:UTC-095 »

1)

The name of that which is identified by a <delimited identifier> or a <non-delimited identifier>

DIONDI is the canonical name form of DIONDI.

NOTE 234 — See SR 21) of Subclause 21.3, “<token>, <separator>, and <identifier>” for the definition of canonical name form.

General Rules

1)

An <object name> identifies a GQL-object.

« WG3:UTC-039R1 »

2)

An <object name or binding variable> identifies a GQL-object or a binding variable.

3)

A <directory name> identifies a GQL-directory.

4)

A <schema name> identifies a GQL-schema.

5)

A <graph name> identifies a graph.

« WG3:UTC-039R1 »

423

IWD 39075:202y(E)

21.2 Names and variables

6)

A <delimited graph name> identifies a graph.

7)

A <graph type name> identifies a graph type.

8)

An <element type name> identifies an element type.

9)

A <binding table name> identifies a binding table.

« WG3:UTC-039R1 »

10) A <delimited binding table name> identifies a binding table.

11) A <procedure name> identifies a procedure.

« WG3:UTC-039R1 Deleted 1 (one) GR »

12) A <label name> identifies a label.

13) A <property name> identifies a property of a GQL-object.

14) A <field name> identifies a field of a record, a field type of a record, or a column of a binding table.

15) A <parameter name> identifies a parameter.

« WG3:UTC-039R1 »

16) A <variable> identifies a variable. A variable is a graph variable, a graph pattern variable, a binding table variable, a value variable, or a binding variable.

17) A <graph variable> identifies a graph variable. Graph variables are binding variables.

« WG3:UTC-080 »

18) A <graph pattern variable> identifies a graph pattern variable. A graph pattern variable is an element variable, a path variable, or a subpath variable.

19) A <path or subpath variable> identifies a path variable or a subpath variable.

20) An <element variable> identifies an element variable.

21) A <path variable> identifies a path variable. Path variables are binding variables.

« WG3:UTC-080 »

22) A <subpath variable> identifies a subpath variable.

« WG3:UTC-080 deleted a note »

23) A <binding table variable> identifies a binding table variable. Binding table variables are binding variables.

24) A <value variable> identifies a value variable. Value variables are binding variables.

« WG3:UTC-039R1 »

25) A <binding variable> identifies a binding variable.

Conformance Rules

None.

424





IWD 39075:202y(E)

21.3 <token>, <separator>, and <identifier>

21.3 <token> , <separator> , and <identifier>

Function

Specify lexical units (tokens, separators, and identifiers) that participate in the GQL language.

Format

<token> ::=

<non-delimiter token>

| <delimiter token>

<non-delimiter token> ::=

<regular identifier>

| <parameter name>

| <key word>

| <unsigned numeric literal>

| <byte string literal>

| <multiset alternation operator>

<identifier> ::=

<regular identifier>

| <delimited identifier>

<separated identifier> ::=

<extended identifier>

| <delimited identifier>

<non-delimited identifier> ::=

<regular identifier>

| <extended identifier>

<regular identifier> ::=

<identifier start> [ <identifier extend> ... ]

<extended identifier> ::=

<identifier extend> ...

<delimited identifier> ::=

<double quoted character sequence>

| <accent quoted character sequence>

<identifier start> ::=

!! See the Syntax Rules.

<identifier extend> ::=

!! See the Syntax Rules.

<key word> ::=

<reserved word>

| <non-reserved word>

« WG3:UTC-084 »

« Editorial: Separate out pre-reserved words »

« Editorial: Key words added to support 9075 interval literals »

<reserved word> ::=

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

« Three keywords moved to pre-reserved »

ABS | ACOS | ALL | ALL_DIFFERENT | AND | ANY | ARRAY

425

IWD 39075:202y(E)

21.3 <token> , <separator>, and <identifier>

| AS | ASC | ASCENDING | ASIN | AT | ATAN | AVG

« WG3:UTC-090R1 »

| BIG | BIGINT | BINARY | BOOL | BOOLEAN | BOTH | BTRIM | BY | BYTE_LENGTH | BYTES

« WG3:UTC-071R1 Deleted a reserved word »

« WG3:UTC-045R1 »

« WG3:UTC-090R1 »

« One keyword moved to pre-reserved »

| CALL | CASE | CAST | CEIL | CEILING

| CHAR_LENGTH | CHARACTER_LENGTH | CHARACTERISTICS

« WG3:UTC-071R1 Deleted two reserved words »

« Three keywords moved to pre-reserved »

| CLOSE | COALESCE | COLLECT | COMMIT | COPY | COS | COSH | COT | COUNT | CREATE

| CURRENT_DATE | CURRENT_GRAPH | CURRENT_PROPERTY_GRAPH

« One keyword moved to pre-reserved »

| CURRENT_SCHEMA | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

« One keyword moved to pre-reserved »

| DATE | DATETIME | DAY | DEC | DECIMAL | DEGREES | DELETE | DESC

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

« WG3:UTC-117 »

« One keyword moved to pre-reserved »

| DESCENDING | DETACH | DISTINCT | DOUBLE | DROP | DURATION | DURATION_BETWEEN

« WG3:UTC-071R1 Deleted 5 reserved words »

« One keyword moved to pre-reserved »

| ELEMENT_ID | ELSE | END | EXCEPT | EXISTS | EXP

« WG3:UTC-101 »

| FALSE | FILTER | FINISH | FLOAT | FLOAT16 | FLOAT32 | FLOAT64 | FLOAT128 | FLOAT256

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

« One keyword moved to pre-reserved »

| FLOOR | FOR | FROM

« Two keywords moved to pre-reserved »

| GROUP

| HAVING | HOME_GRAPH | HOME_PROPERTY_GRAPH | HOME_SCHEMA | HOUR

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

| IF | IN | INSERT | INT | INTEGER | INT8 | INTEGER8 | INT16 | INTEGER16 | INT32

| INTEGER32 | INT64 | INTEGER64 | INT128 | INTEGER128 | INT256 | INTEGER256

« WG3:UTC-071R1 »

| INTERSECT | INTERVAL | IS

« WG3:UTC-071R1 Deleted two reserved word »

« One keyword moved to pre-reserved »

| LEADING | LET | LIKE | LIMIT | LIST | LN

« WG3:UTC-117 »

| LOCAL | LOCAL_DATETIME | LOCAL_TIME | LOCAL_TIMESTAMP | LOG | LOG10 | LOWER | LTRIM

« WG3:UTC-071R1 Deleted four reserved word »

| MATCH | MAX | MIN | MINUTE | MOD | MONTH

426

IWD 39075:202y(E)

21.3 <token>, <separator>, and <identifier>

« WG3:UTC-071R1 Deleted 3 reserved words »

« WG3:UTC-101 »

« One keyword moved to pre-reserved »

| NEXT | NODETACH | NORMALIZE | NOT | NULL | NULLS | NULLIF

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

« One keyword moved to pre-reserved »

« WG3:UTC-071R1 Deleted two reserved words »

| OCTET_LENGTH | OF | OFFSET | OPEN | OPTIONAL | OR | ORDER | OTHERWISE

« WG3:UTC-045R1 »

« WG3:UTC-081 »

| PARAMETER | PARAMETERS | PATH | PATH_LENGTH | PATHS | PERCENTILE_CONT

« WG3:UTC-071R1 Deleted two reserved words »

« WG3:UTC-127R1 »

« Three keywords moved to pre-reserved »

| PERCENTILE_DISC | POWER | PRECISION | PROPERTY_EXISTS

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

« One keyword moved to pre-reserved »

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

« WG3:UTC-045R1 »

« Three keywords moved to pre-reserved »

| RADIANS | REAL | RECORD | REMOVE | REPLACE | RESET

« WG3:UTC-071R1 Deleted 2 reserved words »

« Two keywords moved to pre-reserved »

| RETURN | ROLLBACK | RTRIM

« WG3:UTC-071R1 Deleted 3 reserved words »

| SAME | SCHEMA | SECOND | SELECT | SESSION | SET | SIGNED | SIN | SINH | SKIP

« WG3:UTC-071R1 Deleted 3 reserved words »

« WG3:UTC-081 »

« One keyword moved to pre-reserved »

| SMALL | SMALLINT | SQRT | START | STDDEV_POP | STDDEV_SAMP | STRING | SUM

« WG3:UTC-071R1 Deleted two reserved word »

« WG3:UTC-015 »

« WG3:UTC-043 Deleted two reserved words »

| TAN | TANH | THEN | TIME | TIMESTAMP | TRAILING | TRIM | TRUE | TYPED

| UBIGINT | UINT | UINT8 | UINT16 | UINT32 | UINT64 | UINT128 | UINT256 | UNION

« WG3:UTC-071R1 Deleted 4 reserved words »

« Two keywords moved to pre-reserved »

| UNKNOWN | UNSIGNED | UPPER | USE | USMALLINT

« One keyword moved to pre-reserved »

| VALUE | VARBINARY | VARCHAR | VARIABLE

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

| WHEN | WHERE | WITH

| XOR

« WG3:UTC-071R1 Deleted 1 (one) reserved word »

427

IWD 39075:202y(E)

21.3 <token> , <separator>, and <identifier>

| YEAR | YIELD

« WG3:UTC-117 »

| ZONED | ZONED_DATETIME | ZONED_TIME

<pre-reserved word> ::=

AGGREGATE | AGGREGATES | ALTER

| CATALOG | CLEAR | CLONE | CONSTRAINT | CURRENT_ROLE

| DATA | DIRECTORY

| EXACT | EXISTING

| FUNCTION

| GQLSTATUS | GRANT

| INSTANT

| LEFT

| NOTHING | NUMERIC

| ON

| PARTITION | PROCEDURE | PRODUCT | PROJECT

| QUERY

| RECORDS | REFERENCE | RENAME | REVOKE | RIGHT

| SUBSTRING

| TEMPORAL

| UNIQUE | UNIT

| VALUES

<non-reserved word> ::=

ACYCLIC

| BINDING | BINDINGS

« WG3:UTC-071R1 Deleted 3 non-reserved words »

| CONNECTING

| DESTINATION | DIFFERENT | DIRECTED

« WG3:UTC-015 »

« One keyword moved to pre-reserved »

| EDGE | EDGES | ELEMENT | ELEMENTS

« WG3:UTC-071R1 Deleted 1 (one) non-reserved word »

| FIRST

| GRAPH | GROUPS

« WG3:UTC-088 Deleted INDEX »

« One keyword moved to pre-reserved »

| KEEP

« WG3:UTC-071R1 Deleted 3 non-reserved words »

428

IWD 39075:202y(E)

21.3 <token>, <separator>, and <identifier>

| LABEL | LABELED | LABELS | LAST

« WG3:UTC-071R1 Deleted 2 non-reserved words »

« Editorial: Added NO since its used by NO BINDINGS »

« Editorial: Added NUMERIC since its used in base type names »

« One keyword moved to pre-reserved »

| NFC | NFD | NFKC | NFKD | NO | NODE | NORMALIZED

« WG3:UTC-071R1 Deleted 2 non-reserved words »

| ONLY | ORDINALITY

| PROPERTY

« WG3:UTC-071R1 Deleted 1 (one) non-reserved word »

| READ | RELATIONSHIP | RELATIONSHIPS | REPEATABLE

« WG3:UTC-071R1 Deleted 1 (one) non-reserved word »

| SHORTEST | SIMPLE | SOURCE

« WG3:UTC-117 »

« WG3:UTC-071R1 Deleted 2 non-reserved words »

« One keyword moved to pre-reserved »

| TABLE | TEMP

« WG3:UTC-117 »

| TIMEZONE | TO | TRAIL | TRANSACTION | TYPE

| UNDIRECTED

« WG3:UTC-071R1 Deleted 1 (one) non-reserved word »

| VERTEX

| WALK

« WG3:UTC-117 »

| WITHOUT | WRITE

| ZONE

<multiset alternation operator> ::=

|+| !! <U+007C, U+002B, U+007C>

<delimiter token> ::=

<GQL special character>

| <bracket right arrow>

| <bracket tilde right arrow>

| <character string literal>

| <concatenation operator>

| <date string>

| <datetime string>

| <delimited identifier>

| <double colon>

| <double minus sign>

| <double period>

| <duration string>

| <greater than operator>

| <greater than or equals operator>

| <left arrow>

| <left arrow bracket>

| <left arrow tilde>

| <left arrow tilde bracket>

| <left minus right>

429

IWD 39075:202y(E)

21.3 <token> , <separator>, and <identifier>

| <left minus slash>

| <left tilde slash>

| <less than operator>

| <less than or equals operator>

| <minus left bracket>

| <minus slash>

| <not equals operator>

| <right arrow>

| <right bracket minus>

| <right bracket tilde>

| <slash minus>

| <slash minus right>

| <slash tilde>

| <slash tilde right>

| <tilde left bracket>

| <tilde right arrow>

| <tilde slash>

| <time string>

<bracket right arrow> ::=

]-> !! <U+005D, U+002D, U+003E>

<bracket tilde right arrow> ::=

]~> !! <U+005D, U+007E, U+003E>

<concatenation operator> ::=

|| !! <U+007C, U+007C>

<double colon> ::=

:: !! <U+003A, U+003A>

<double minus sign> ::=

-- !! <U+002D, U+002D>

<double period> ::=

.. !! <U+002E, U+002E>

<greater than operator> ::=

<right angle bracket>

<greater than or equals operator> ::=

>= !! <U+003E, U+003D>

<left arrow> ::=

<- !! <U+003C, U+002D>

<left arrow tilde> ::=

<~ !! <U+003C, U+007E>

<left arrow bracket> ::=

<-[ !! <U+003C, U+002D, U+005B>

<left arrow tilde bracket> ::=

<~[ !! <U+003C, U+007E, U+005B>

<left minus right> ::=

<-> !! <U+003C, U+002D, U+003E>

<left minus slash> ::=

<-/ !! <U+003C, U+002D, U+002F>

<left tilde slash> ::=

<~/ !! <U+003C, U+007E, U+002F>

<less than operator> ::=

430

IWD 39075:202y(E)

21.3 <token>, <separator>, and <identifier>

<left angle bracket>

<less than or equals operator> ::=

<= !! <U+003C, U+003D>

<minus left bracket> ::=

-[ !! <U+002D, U+005B>

<minus slash> ::=

-/ !! <U+002D, U+002F>

<not equals operator> ::=

<> !! <U+003C, U+003E>

<right arrow> ::=

-> !! <U+002D, U+003E>

<right bracket minus> ::=

]- !! <U+005D, U+002D>

<right bracket tilde> ::=

]~ !! <U+005D, U+007E>

<slash minus> ::=

/- !! <U+002F, U+002D>

<slash minus right> ::=

/-> !! <U+002F, U+002D, U+003E>

<slash tilde> ::=

/~ !! <U+002F, U+007E>

<slash tilde right> ::=

/~> !! <U+002F, U+007E, U+003E>

<tilde left bracket> ::=

~[ !! <U+007E, U+005B>

<tilde right arrow> ::=

~> !! <U+007E, U+003E>

<tilde slash> ::=

~/ !! <U+007E, U+002F>

<double solidus> ::=

// !! <U+002F, U+002F>

<separator> ::=

{ <comment> | <whitespace> }...

<whitespace> ::=

!! See the Syntax Rules.

<bidirectional control character> ::=

!! See the Syntax Rules.

<comment> ::=

<simple comment>

| <bracketed comment>

<simple comment> ::=

<simple comment introducer> [ <simple comment character>... ] <newline>

<simple comment introducer> ::=

<double solidus>

431

IWD 39075:202y(E)

21.3 <token> , <separator>, and <identifier>

| <double minus sign>

<simple comment character> ::=

!! See the Syntax Rules.

<bracketed comment> ::=

<bracketed comment introducer>

<bracketed comment contents>

<bracketed comment terminator>

<bracketed comment introducer> ::=

/* !! <U+002F, U+002A>

<bracketed comment terminator> ::=

*/ !! <U+002A, U+002F>

<bracketed comment contents> ::=

!! See the Syntax Rules.

<newline> ::=

!! See the Syntax Rules.

<edge synonym> ::=

EDGE | RELATIONSHIP

<edges synonym> ::=

EDGES | RELATIONSHIPS

<node synonym> ::=

NODE | VERTEX

Syntax Rules

1)

An <identifier start> is <underscore> or any character with the Unicode property XID_Start, optionally modified by an implementation-defined (IE003) profile, as defined by UAX31-D1 Default

Identifier Syntax in Unicode Standard Annex #31.

NOTE 235 — The characters in ID_Start are those in the Unicode General Category classes “Lu”, “Ll”, “Lt”, “Lm”, “Lo”,

and “Nl” together with those with the Unicode property Other_ID_Start but none of which have the Unicode properties

Pattern_Syntax or Pattern_White_Space. The characters in XID_Start are derived from those in ID_Start to ensure

closure under NFKC normalization.

2)

An <identifier extend> is any character with the Unicode property XID_Continue, optionally modified

by an implementation-defined (IE003) profile, as defined by UAX31-D1 Default Identifier Syntax

in Unicode Standard Annex #31.

NOTE 236 — The characters in ID_Continue are those in ID_Start together with those in the Unicode General Category

classes “Mn”, “Mc”, “Nd”, and “Pc” together with those with the Unicode property Other_ID_Continue but none of

which have the Unicode properties Pattern_Syntax or Pattern_White_Space. The characters in XID_Continue are

derived from those in ID_Continue to ensure closure under NFKC normalization. Every character in XID_Start is also

a character in XID_Continue.

3)

The representative form RF of a <non-delimited identifier> NDI is the character string comprising the sequence of characters contained in NDI. RF shall not be the zero-length character string.

NOTE 237 — Provisions regarding the assumed Unicode normalization of character strings apply. See

Subclause 4.15.3.3, “Character string types” .

4)

The representative form RF of a <delimited identifier> DI is the character string specified by the

<double quoted character sequence> , or the <accent quoted character sequence> contained in DI.

RF shall not be the zero-length character string.

NOTE 238 — Provisions regarding the assumed Unicode normalization of character strings apply. See

Subclause 4.15.3.3, “Character string types” .

432

IWD 39075:202y(E)

21.3 <token>, <separator>, and <identifier>

5)

For every <non-delimited identifier> or <delimited identifier> NDIODI: a)

Let RF be the representative form of NDIODI.

b)

The maximum length in characters of RF shall be 214 −1 = 16383.

NOTE 239 — This maximum length is modified by CR 1).

c)

RF shall not contain characters of the Unicode General Category classes “Cc”, “Cf”, “Cn”, “Cs”,

“Zl”, or “Zp”.

NOTE 240 — The Unicode General Category classes “Cc”, “Cf”, “Cn”, “Cs”, “Zl”, and “Zp” are assigned to Unicode

characters that are, respectively, Control codes (other), Formal Control codes, Not Assigned codes, Surrogates,

Line Separators, and Paragraph Separators.

d)

RF shall not contain characters of the Unicode General Category class “Zs” other than <space> .

NOTE 241 — Unicode General Category class “Zs” identifies characters that are Space Separators (whitespace).

e)

Whether characters of the Unicode General Category class “Co” are permitted to be contained

in RF is implementation-defined (IA020).

NOTE 242 — The Unicode General Category class “Co” is assigned to private use characters.

6)

<whitespace> is any consecutive sequence of Unicode characters with the property White_Space.

NOTE 243 — These are the characters the Unicode General Category classes “Zs”, “Zl” and “Zp” together with the

characters: U+0009 (Horizontal Tabulation), U+000A (Line Feed), U+000B (Vertical Tabulation), U+000C (Form

Feed), U+000D (Carriage Return), and U+0085 (Next Line).

7)

A <bidirectional control character> is any of the following characters of the Unicode General Category class “Cf”: LEFT-TO-RIGHT EMBEDDING (U+202A), RIGHT-TO-LEFT EMBEDDING (U+202B), POP

DIRECTIONAL FORMATTING (U+202C), LEFT-TO-RIGHT OVERRIDE (U+202D), RIGHT-TO-LEFT

OVERRIDE (U+202E), LEFT-TO-RIGHT ISOLATE (U+2066), RIGHT-TO-LEFT ISOLATE (U+2067),

FIRST STRONG ISOLATE (U+2068), POP DIRECTIONAL ISOLATE (U+2069).

NOTE 244 — The Unicode General Category class “Cf” is assigned to Unicode characters that are Formal Control

codes.

8)

<simple comment character> is any character in the GQL source text character repertoire that is

not a <newline> .

9)

<bracketed comment contents> is any character string of characters in the GQL source text character

repertoire that does not contain <bracketed comment terminator> .

10) Whether a <simple comment character> or <bracketed comment contents> shall not be or contain, respectively, a <bidirectional control character> is implementation-defined (IA019).

NOTE 245 — This mitigates CVE-2021-42574.

11) <newline> is the implementation-defined (IA023) end-of-line indicator.

NOTE 246 — <newline> is typically represented by U+000A (“Line Feed”) and/or U+000D (“Carriage Return”); however, this representation is not required by this document.

12) A <token>, other than a <byte string literal>, <character string literal> , or a <delimited identifier>,

shall not contain a <separator> .

13) Any <token> may be followed by a <separator>. A <non-delimiter token> shall be followed by a

<delimiter token> or a <separator> .

« Editorial: UTC-013 P16-ISO-010 »

NOTE 247 — If the Format does not allow a <non-delimiter token> to be followed by a <delimiter token> , then that

<non-delimiter token> will be followed by a <separator> .

14) GQL text containing one or more instances of <simple comment> is equivalent to the same GQL text

with each <simple comment> replaced with <newline>.

433

IWD 39075:202y(E)

21.3 <token> , <separator>, and <identifier>

15) GQL text containing one or more instances of <bracketed comment> is equivalent to the same GQL

text with each <bracketed comment> BC replaced with,

Case:

a)

If BC contains a <newline>, then <newline>.

b)

Otherwise, <space>.

16) For every <non-delimited identifier> NDI there is exactly one corresponding case-normal form CNF.

CNF is a character string derived from the representative form RF of NDI as follows.

Let n be the number of characters in RF. For i ranging from 1 (one) to n, the i-th character Mi of RF

is transliterated into the corresponding character or characters of CNF as follows.

Case:

a)

If Mi is a lower-case character or a title case character for which an equivalent upper-case

sequence U is defined by Unicode, then let j be the number of characters in U; the next j characters of CNF are U.

b)

Otherwise, the next character of CNF is Mi.

NOTE 248 — Any lower-case letters for which there are no upper-case equivalents are left in their lower-case form.

NOTE 249 — The case-normal form of a <non-delimited identifier> is used in excluding <reserved word>s.

17) The case-normal form of a <non-delimited identifier> shall not be equal, according to the comparison rules in Subclause 19.3, “<comparison predicate>”, to any <reserved word> (with every letter that is a lower-case letter replaced by the corresponding upper-case letter or letters), treated as a

<character string literal> .

« Editorial: UTC-013 P16-ISO-010 »

NOTE 250 — It is the intention that no <key word> specified in this document or revisions thereto will end with an

<underscore> .

18) Two <non-delimited identifier> s are equivalent if their representative forms compare equally

according to the comparison rules in Subclause 19.3, “<comparison predicate>”.

19) A <non-delimited identifier> and a <delimited identifier> are equivalent if their representative forms compare equally according to the comparison rules in Subclause 19.3, “<comparison predic-

ate>”.

20) Two <delimited identifier> s are equivalent if their representative forms compare equally according to the comparison rules in Subclause 19.3, “<comparison predicate>” .

« WG3:UTC-095 »

21) For every <delimited identifier> or <non-delimited identifier> DIONDI there is exactly one canonical name form that is a character string derived from the representative form of DINODI using an

implementation-defined (IW023) mechanism such that the canonical forms of equivalent identifiers

are always identical.

22) For the purposes of identifying <reserved word> s, any <simple Latin lower-case letter> contained in a candidate <key word> shall be effectively treated as the corresponding <simple Latin upper-

case letter>.

23) For the purposes of identifying <non-reserved word> s, any <simple Latin lower-case letter> contained in a candidate <key word> shall be effectively treated as the corresponding <simple Latin

upper-case letter> .

434

IWD 39075:202y(E)

21.3 <token>, <separator>, and <identifier>

General Rules

None.

Conformance Rules

1)

Without Feature GB00, “Long identifiers”, in conforming GQL language, the maximum length in

characters of the representative form of a <non-delimited identifier> or a <delimited identifier>

shall be 27 −1 = 127.

2)

Without Feature GB01, “Double minus sign comments”, conforming GQL language shall not contain

a <simple comment> introduced with a <double minus sign>.

3)

Without Feature GB02, “Double solidus comments”, conforming GQL language shall not contain a

<simple comment> introduced with a <double solidus>.

435





IWD 39075:202y(E)

21.4 <GQL terminal character>

21.4 <GQL terminal character>

Function

Define the terminal symbols of the GQL language.

Format

<GQL terminal character> ::=

<GQL language character>

| <other language character>

<GQL language character> ::=

<simple Latin letter>

| <digit>

| <GQL special character>

<simple Latin letter> ::=

<simple Latin lower-case letter>

| <simple Latin upper-case letter>

<simple Latin lower-case letter> ::=

a | b | c | d | e | f | g | h | i | j | k | l | m | n | o

| p | q | r | s | t | u | v | w | x | y | z

<simple Latin upper-case letter> ::=

A | B | C | D | E | F | G | H | I | J | K | L | M | N | O

| P | Q | R | S | T | U | V | W | X | Y | Z

<hex digit> ::=

<standard digit> | A | B | C | D | E | F | a | b | c | d | e | f

<digit> ::=

<standard digit>

| <other digit>

<standard digit> ::=

<octal digit> | 8 | 9

<octal digit> ::=

<binary digit> | 2 | 3 | 4 | 5 | 6 | 7

<binary digit> ::=

0 | 1

<other digit> ::=

!! See the Syntax Rules.

<GQL special character> ::=

<space>

| <ampersand>

| <asterisk>

| <colon>

| <equals operator>

| <comma>

« WG3:UTC-044 »

| <commercial at>

| <dollar sign>

| <double quote>

| <exclamation mark>

436

IWD 39075:202y(E)

21.4 <GQL terminal character>

| <grave accent>

| <right angle bracket>

| <left brace>

| <left bracket>

| <left paren>

| <left angle bracket>

| <minus sign>

| <period>

| <plus sign>

| <question mark>

| <quote>

| <reverse solidus>

| <right brace>

| <right bracket>

| <right paren>

| <semicolon>

| <solidus>

| <underscore>

| <vertical bar>

| <percent>

| <circumflex>

| <tilde>

<space> ::=

!! U+0020

<ampersand> ::=

& !! U+0026

<asterisk> ::=

* !! U+002A

<circumflex> ::=

^ !! U+005E

<colon> ::=

: !! U+003A

<comma> ::=

, !! U+002C

« WG3:UTC-044 »

<commercial at> ::=

@ !! U+0040

<dollar sign> ::=

$ !! U+0024

<double quote> ::=

" !! U+0022

<equals operator> ::=

= !! U+003D

<exclamation mark> ::=

! !! U+0021

<right angle bracket> ::=

> !! U+003E

<grave accent> ::=

` !! U+0060

<left brace> ::=

437

IWD 39075:202y(E)

21.4 <GQL terminal character>

{ !! U+007B

<left bracket> ::=

[ !! U+005B

<left paren> ::=

( !! U+0028

<left angle bracket> ::=

< !! U+003C

<minus sign> ::=

- !! U+002D

<percent> ::=

% !! U+0025

<period> ::=

. !! U+002E

<plus sign> ::=

+ !! U+002B

<question mark> ::=

? !! U+003F

<quote> ::=

' !! U+0027

<reverse solidus> ::=

\ !! U+005C

<right brace> ::=

} !! U+007D

<right bracket> ::=

] !! U+005D

<right paren> ::=

) !! U+0029

<semicolon> ::=

; !! U+003B

<solidus> ::=

/ !! U+002F

<tilde> ::=

~ !! U+007E

<underscore> ::=

_ !! U+005F

<vertical bar> ::=

| !! U+007C

<other language character> ::=

!! See the Syntax Rules.

Syntax Rules

1)

<other language character> is any Unicode character not contained in <GQL language character>.

438

IWD 39075:202y(E)

21.4 <GQL terminal character>

2)

<other digit> is any Unicode character in the Unicode General Category class “Nd” not contained in

<standard digit>.

3)

The <hex digit> s a, b, c, d, e, and f have respectively the same values as the <hex digit>s A, B, C, D, E, and F.

General Rules

1)

There is a one-to-one correspondence between the symbols contained in <simple Latin upper-case

letter> and the symbols contained in <simple Latin lower-case letter> such that, for every i, the symbol defined as the i-th alternative for <simple Latin upper-case letter> corresponds to the symbol defined as the i-th alternative for <simple Latin lower-case letter>.

Conformance Rules

None.

439





IWD 39075:202y(E)

22 Additional common rules

** Editor’s Note (number 65) **

SQL has Subclause 9.16, “Potential sources of non-determinism” in SQL/Foundation, which is modified by Subclause 9.1,

“Potential sources of non-determinism” in SQL/PGQ as a result of WG3:W04-009R1. GQL currently has no equivalent Subclause.

See Language Opportunity GQL-011 .

22.1 Store assignment

Function

Specify rules for assignments.

Subclause Signature

“Store assignment” [Syntax Rules] (

Parameter: “TARGET”,

Parameter: “VALUE”

)

TARGET — a GQL site that is the target of an assignment operation.

VALUE — a GQL value that is assigned to TARGET.

— This signature is invoked from Subclause 10.3, “<value variable definition>” , SR 8)b)i)1)

— This signature is invoked from Subclause 13.2, “<insert statement>” , SR 4)d)ii)

— This signature is invoked from Subclause 13.3, “<set statement>” , SR 3)a)iii)2)

— This signature is invoked from Subclause 13.3, “<set statement>” , SR 3)b)ii)2)B)

— This signature is invoked from Subclause 22.1, “Store assignment”, SR 5)c)

— This signature is invoked from Subclause 22.1, “Store assignment”, SR 7)d)

— This signature is invoked from Subclause 22.1, “Store assignment”, SR 8)b)i)2)

“Store assignment” [General Rules] (

Parameter: “TARGET”,

Parameter: “VALUE”

)

TARGET — a GQL site that is the target of an assignment operation.

VALUE — a GQL value that is assigned to TARGET.

— This signature is invoked from Subclause 13.2, “<insert statement>” , GR 3)a)i)4)A)III)

— This signature is invoked from Subclause 13.2, “<insert statement>” , GR 3)a)ii)4)A)III)

— This signature is invoked from Subclause 13.3, “<set statement>” , GR 5)a)ii)

— This signature is invoked from Subclause 13.3, “<set statement>” , GR 5)b)iii)2)

— This signature is invoked from Subclause 22.1, “Store assignment”, GR 4)b)i)4)

— This signature is invoked from Subclause 22.1, “Store assignment”, GR 4)b)xii)1)

— This signature is invoked from Subclause 22.1, “Store assignment”, GR 4)b)xii)2)A)

— This signature is invoked from Subclause 22.1, “Store assignment”, GR 4)b)xii)3)

— This signature is invoked from Subclause 22.1, “Store assignment”, GR 4)b)xiii)3)

— This signature is invoked from Subclause 22.1, “Store assignment”, GR 4)b)xiv)2)

440

IWD 39075:202y(E)

22.1 Store assignment

Syntax Rules

1)

Let T be the TARGET and let V be the VALUE in an application of the Syntax Rules of this Subclause.

2)

Let SD be the declared type of V.

3)

Let TD be the declared type of T.

« WG3:UTC-124 »

4)

SD shall be assignable to TD.

« WG3:UTC-015 »

5)

If at least one of SD or TD is a dynamic union type, then:

a)

Let SCTS be the set determined as follows. If SD is a dynamic union type, then SCTS is the set

of component types of SD; otherwise, SCTS is the singleton set comprising SD.

b)

Let TCTS be the set determined as follows. If TD is a dynamic union type, then TCTS is the set

of component types of TD; otherwise, TCTS is the singleton set comprising TD.

c)

For each type ST in SCTS, there shall be one type TT in TCTS such that given a temporary site TS whose declared type is TT and an arbitrary expression AX whose declared type is ST, then

the Syntax Rules of this Subclause are applied with TS as TARGET and AX as VALUE.

d)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause.

NOTE 251 — This ensures that every possible source value is possibly store-assignable to the target.

6)

If TD is a predefined value type, then

Case:

a)

If TD is a reference value type, then:

i)

The data type descriptors of SD and TD shall specify the same object base type name.

« WG3:UTC-086R1 »

ii)

Either TD is an open type or the constraining object type of SD shall be a subtype of

the constraining object type of TD.

« WG3:UTC-124 Consequence »

b)

Otherwise, TD is not a reference value type.

7)

If TD is a list value type, then:

a)

SD shall be a list value type.

b)

Let TELT be the list element type of TD and let VELT be the list element type of SD.

c)

Let TS be a transient site whose declared type is TELT, and let AX be an arbitrary expression

whose declared type is VELT.

d)

The Syntax Rules of this Subclause are applied with TS as TARGET and AX as VALUE.

8)

If TD is a record type, then

Case:

a)

If TD is an open record type, then SD shall be a record type.

« WG3:UTC-124 »

b)

Otherwise, TD is a closed record type.

441

IWD 39075:202y(E)

22.1 Store assignment

Case:

i)

If SD is a closed record type with the same set of field names as TD. For every field type

name FTN in the set of field names of SD:

1)

Let FTD be the declared type of the field type of TD whose name is FTN, let FSD

be the declared type of the field type of SD whose name is FTN, let TS be a transient

site whose declared type is FTD, and let AX be an arbitrary expression whose

declared type is FSD.

2)

The Syntax Rules of this Subclause are applied with TS as TARGET and AX as

VALUE.

ii)

Otherwise, SD is an open record type.

9)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause.

General Rules

1)

Let T be the TARGET and let V be the VALUE in an application of the General Rules of this Subclause.

« WG3:UTC-015 »

2)

Let VD be determined as follows.

Case:

a)

If the declared type of V is a dynamic union type, then VD is the most specific static value type

of V.

b)

Otherwise, VD is the declared type of V.

3)

Let TD be the declared type of T.

4)

Case:

a)

If V is the null value, then TD shall be nullable and T is set to the null value.

b)

Otherwise, V is material.

Case:

« WG3:UTC-015 »

i)

If TD is a dynamic union type, then:

1)

Let NTCTS be the set of component types of TD to which VD is assignable.

2)

The Syntax Rules of Subclause 22.18, “Static value type set precedence determin-

ation”, are applied with NTCTS as NDTSET; let NTCTL be the NDTLIST returned from the application of those Syntax Rules.

3)

Let TST be the value type of an element of NTCTL for which the simulated

application of the General Rules of this Subclause succeeds without raising an

exception condition, or the first element of NTCTL if no such simulated application

succeeds.

4)

The General Rules of this Subclause are applied with a temporary site TS whose

declared type is TST as TARGET and V as VALUE.

ii)

If TD is a reference value type, then:

442

IWD 39075:202y(E)

22.1 Store assignment

1)

If the base type of V is not the same as the base type of TD, then an exception

condition is raised: data exception — reference value, invalid base type (22G0V).

2)

If the referent of V is not an object of TD, then an exception condition is raised:

data exception — reference value, invalid constrained type (22G0W).

3)

The value of T is set to V.

iii)

If TD is character string type and the length in characters M of V is not greater than the

maximum length in characters of T, then the value of T is set to V and the length in

characters of T is set to M.

iv)

If TD is character string type and the length in characters M of V is greater than the

maximum length in characters L of T, then

Case:

1)

If the rightmost M− L characters of V are all <whitespace> characters, then the value of T is set to the first L characters of V and the length in characters of T is

set to L.

2)

If one or more of the rightmost M− L characters of V are not <whitespace> characters, then an exception condition is raised: data exception — string data, right

truncation (22001).

« Correct application of W24-035R2 »

« Editorial: Correct application of W24-032 »

v)

If TD is fixed-length byte string type with length in bytes L and the length in bytes of V

is equal to L, then the value of T is set to V.

vi)

If TD is fixed-length byte string type with length in bytes L and the length in bytes M

of V is larger than L, then

Case:

« Correct application of W24-035R2 »

1)

If the rightmost M− L bytes of V are all equal to X'00', then the value of T is set to

the first L bytes of V.

2)

If one or more of the rightmost M− L bytes of V are not equal to X'00', then an

exception condition is raised: data exception — string data, right truncation

(22001).

« Correct application of W24-035R2 »

« Editorial: Correct application of W24-032 »

vii)

If TD is fixed-length byte string type with length in bytes L and the length in bytes M

of V is less than L, then the first M bytes of T are set to V and the last L− M bytes of T are set to X'00's.

viii)

If TD is variable-length byte string type and the length in bytes M of V is not greater

than the maximum length in bytes of T, then the value of T is set to V and the length in

bytes of T is set to M.

ix)

If TD is variable-length byte string type and the length in bytes M of V is greater than

the maximum length in bytes L of T, then

Case:

443

IWD 39075:202y(E)

22.1 Store assignment

1)

If the rightmost M− L bytes of V are all equal to X'00', then the value of T is set to

the first L bytes of V and the length in bytes of T is set to L.

2)

If one or more of the rightmost M− L bytes of V are not equal to X'00', then an

exception condition is raised: data exception — string data, right truncation

(22001).

« WG3:UTC-124 »

x)

If TD is a numeric type, then

Case:

1)

If V is a value of TD, then the value of T is set to V.

2)

If a value of TD can be obtained from V by rounding or truncation, then it is

implementation-defined (ID101) which of the following occurs:

A)

The value of T is set to that value. If TD is exact numeric, then it is implemen-

tation-defined (IA005) whether the approximation is obtained by rounding

or by truncation.

B)

An exception condition is raised: data exception — numeric value out of

range (22003).

3)

Otherwise, an exception condition is raised: data exception — numeric value out

of range (22003).

xi)

If TD is a datetime type, then

1)

If only one of TD and VD is a zoned datetime type, then V is effectively replaced

by

CAST ( V AS TD )

« WG3:UTC-124 »

2)

Case:

A)

If V is a value of TD, then the value of T is set to V.

B)

If a value of TD can be obtained from V by rounding or truncation, then it

is implementation-defined (ID101) which of the following occurs:

I)

The value of T is set to that value. It is implementation-defined

(IA005) whether the approximation is obtained by rounding or

truncation.

II)

An exception condition is raised: data exception — datetime field

overflow (22008).

C)

Otherwise, an exception condition is raised: data exception — datetime field

overflow (22008).

xii)

If TD is a list value type, then

Case:

1)

If the maximum cardinality L of T is equal to the cardinality of V, then for i ranging

from 1 (one) to L, the General Rules of this Subclause are applied with the i-th

element of T as TARGET and the i-th element of V as VALUE.

2)

If the maximum cardinality L of T is smaller than the cardinality M of V, then

444

IWD 39075:202y(E)

22.1 Store assignment

Case:

A)

If the rightmost M− L elements of V are all null, then for i ranging from 1

(one) to L, the General Rules of this Subclause are applied with the i-th ele-

ment of T as TARGET and the i-th element of V as VALUE.

B)

If one or more of the rightmost M− L elements of V are not the null value,

then an exception condition is raised: data exception — array data, right

truncation (2202F).

3)

If the maximum cardinality L of T is greater than the cardinality M of V, then for

i ranging from 1 (one) to M, the General Rules of this Subclause are applied with

the i-th element of T as TARGET and the i-th element of V as VALUE. The cardinality of the value of T is set to M.

NOTE 252 — The maximum cardinality L of T is unchanged.

xiii)

If TD is a closed record type, then:

1)

If there is a field of V whose name is not the name of a field type of TD, then an

exception condition is raised: data exception — record data, field unassignable

(22G0X).

2)

If there is a field type of TD whose name is not the name of a field of V, then an

exception condition is raised: data exception — record data, field missing (22G0Y).

3)

For every field type name FTN in the set of field type names of VD: The General

Rules of this Subclause are applied with the field with name FTN of T as TARGET

and the field with name FTN of V as VALUE.

xiv)

If TD is an open record type, then for every field F in V:

1)

Let FTN be the name of F, let FTD be the declared type of F, and let TS be a transient site whose declared type is FTD.

2)

The General Rules of this Subclause are applied with TS as TARGET and F as

VALUE.

3)

The field with name FTN in T is set to the value of TS.

xv)

Otherwise, the value of T is set to V.

5)

Evaluation of the General Rules is terminated and control is returned to the invoking Subclause.

445





IWD 39075:202y(E)

22.2 Machinery for graph pattern matching

22.2 Machinery for graph pattern matching

Function

Define the infrastructure (alphabet, mappings and related definitions) used in graph pattern matching.

Subclause Signature

“Machinery for graph pattern matching” [General Rules] (

Parameter: “PROPERTY GRAPH”,

Parameter: “PATH PATTERN LIST”

) Returns: “MACHINERY”

« Editorial: Add documentation »

PROPERTY GRAPH — a property graph.

PATH PATTERN LIST — a <path pattern list>.

MACHINERY — the machinery to be used for graph pattern matching.

— This signature is invoked from Subclause 16.7, “<graph pattern binding table>”, GR 1)

Syntax Rules

None.

General Rules

1)

Let PG be the PROPERTY GRAPH and let PPL be the PATH PATTERN LIST in an application of the

General Rules of this Subclause. The result of the application of this Subclause is returned as

MACHINERY.

2)

Let SVV be the set of names of node variables declared in PPL at the same depth of graph pattern

matching, and let SEV be the set of names of edge variables declared in PPL at the same depth of

graph pattern matching.

3)

For each subpath variable SPV declared in PPL at the same depth of graph pattern matching, let

SPVBEGIN and SPVEND be two distinct <identifier> s that are distinct from every <identifier> in SVV

∪ SEV and from every <identifier> created by this rule. SPVBEGIN is the begin subpath symbol and SPVEND is the end subpath symbol associated with SPV. Let SPS be the set of every subpath symbol.

4)

Let `()` and `-` be mutually distinct <identifier>s that are distinct from every <identifier> in SVV ∪

SEV ∪ SPS. These are, respectively, the anonymous node symbol and the anonymous edge symbol. Let SAS be the set of anonymous symbols.

5)

Let NPP be the number of <parenthesized path pattern expression>s contained in PPL at the same depth of graph pattern matching. Let PPPE 1, ..., PPPENPP be an enumeration of the <parenthesized

path pattern expression> s contained in PPL at the same depth of graph pattern matching. For every i, 1 (one) ≤ i ≤ NPP, i is the bracket index of PPPEi.

6)

Let `[1`, ..., `[NPP`, `]1`, ..., `]NPP` be 2 * NPP <identifier> s that are mutually distinct, and distinct from every member of SVV ∪ SEV ∪ SPS ∪ SAS and from every graph element of PG. These are called bracket symbols. For every bracket symbols `[ j òr `] j`, j is the bracket index of the bracket symbol. There are 446

IWD 39075:202y(E)

22.2 Machinery for graph pattern matching

two bracket symbols for each bracket index j between 1 (one) and NPP, corresponding to the

<parenthesized path pattern expression>s PPPEj. Let SBS be the set of bracket symbols.

7)

Let GX be the set whose members are the graph elements of PG, the subpath symbols, and the bracket

symbols.

8)

Let ABC be SPS ∪ SBS ∪ SVV ∪ SEV ∪ SAS. ABC is the alphabet. The members of ABC are symbols.

9)

A word is a string of elements of ABC.

10) An elementary binding is a pair ( LET, GE) where LET is a member of ABC and GE is a member of GX, such that:

Case:

a)

If LET is a bracket symbol, then LET = GE. In this case, the elementary binding is a bracket

symbol binding. If LET is a start bracket symbol, then the elementary binding is a start bracket

symbol binding; otherwise, it is an end bracket symbol binding. The bracket index of LET is the

bracket index of the bracket symbol binding.

b)

If LET is a subpath symbol, then LET = GE. In this case, the elementary binding is a subpath

symbol binding.

c)

If LET is the name of a node variable or the anonymous node symbol, then GE is a node. In

this case the elementary binding is a node symbol binding.

d)

If LET is the name of an edge variable or the anonymous edge symbol, then GE is an edge. In

this case, the elementary binding is an edge symbol binding.

11) If EB = ( LET, GE) is an elementary binding, then EB is an elementary binding of LET, and EB binds LET to GE.

« Editorial: Align with Directives Part 2 »

NOTE 253 — An elementary binding is a mapping of a symbol (an <identifier> ) to a member of GX; it is not the binding of a graph pattern variable. In particular, if LET is the name of an element variable EV, there can be more than one elementary binding of LET in a multi-path binding. In a consistent path binding (defined subsequently),

two elementary bindings of LET necessarily bind to the same graph element in contexts in which LET is exposed as unconditional singleton; otherwise, elementary bindings of LET are independent of one another, and can bind to

more than one graph element. Similarly, references to EV are context-dependent, and can resolve to a list that is a

proper subset of all the graph elements bound to LET by elementary bindings. Resolution of <element variable ref-

erence> s is performed by the General Rules of Subclause 22.6, “Applying bindings to evaluate an expression”.

« WG3:UTC-087R2 »

** Editor’s Note (number 66) **

The following item from BER-031 was not included. A compressed binding is a pair ( LOV, GE) where LOV is a list of names of element variables and GE is a graph element.

12) When an elementary binding ( LET, GE) binds LET to a graph element GE during the evaluation of an <element pattern where clause>, temporarily add a new field whose field name is LET and whose field value is a graph element reference value to GE to the current working record until the evaluation

has finished.

13) A path binding is a sequence of zero or more elementary bindings, B = ( LET 1, E 1), ... (LETN, EN).

Given a path binding B:

« Editorial: Align with Directives Part 2 »

« WG3:UTC-080 »

NOTE 254 — Unlike the definition of path, the definition of path binding allows a sequence of zero elementary

bindings. For example, a quantifier can iterate 0 (zero) times, resulting in an empty path binding. The result of a

447

IWD 39075:202y(E)

22.2 Machinery for graph pattern matching

<path pattern>, on the other hand, is unable to be empty because of a Syntax Rule that enforces a minimum node count of 1 (one).

a)

The word of B is the sequence LET 1, ..., LETN.

b)

The annotated path of B is the sequence E 1, ..., EN.

« WG3:UTC-009 P00-USA-169 »

NOTE 255 — If the path binding is consistent (defined subsequently), then the annotated path of B contains

within it a path that matches the word of B, plus mark-up with bracket symbols and subpath symbols indicating

how to interpret the path as a match to the word.

c)

The compressed path binding CPB of B is obtained from B as follows:

i)

Let CPB be a copy of B.

ii)

All subpath symbol bindings and all bracket symbol bindings are deleted from CPB.

iii)

Each maximal subsequence MS of CPB comprising one or more consecutive node

bindings is replaced by a single compressed binding, whose components are the follow-

ing:

1)

The first component is a list of the names of node variables in the first component

of the node bindings of MS.

NOTE 256 — This list is empty if only the anonymous node symbol is bound in MS.

2)

The second component is the node that is bound by the first node binding in MS.

NOTE 257 — For consistent path bindings, consecutive node bindings will bind the same node.

iv)

In each edge binding EB of CPB, the first component is replaced by a list of zero or one

name of an edge variable, retaining the name of the edge variable in the first component

of EB, if any.

d)

The extracted path XP of B is obtained from the compressed path binding of B as the sequence

of the second components of the compressed bindings of CPB.

« WG3:UTC-080 »

NOTE 258 — The extracted path is a path if the path binding is consistent and non-empty; otherwise, the

extracted path is not necessarily a path.

14) Let REDUCE be a function that maps path bindings to path bindings, determined as follows:

a)

Let PBIN be a path binding.

b)

Let PBOUT be a copy of PBIN.

c)

All bracket bindings are removed from PBOUT.

d)

Every element binding to a temporary node variable is replaced by an anonymous node

binding to the same node in PBOUT.

e)

Every element binding to a temporary edge variable is replaced by an anonymous edge

binding to the same edge in PBOUT.

f)

The following steps are performed on PBOUT repeatedly until no more anonymous node

bindings can be removed:

i)

If there are two adjacent anonymous node bindings, then the second is removed.

ii)

If there is a binding of a node variable adjacent to an anonymous node binding, then

the anonymous node binding is removed.

g)

REDUCE( PBIN) is PBOUT.

448

IWD 39075:202y(E)

22.2 Machinery for graph pattern matching

15) In a path binding, two node bindings are separable if there is an edge binding between them.

« Email from: Jim Melton 2022-12-08 0219 »

16) A path binding B is consistent if all of the following conditions are true:

« WG3:UTC-080 »

a)

The extracted path XP of B is either the empty sequence or a path of PG.

NOTE 259 — That is, either XP is empty or XP begins with a node, alternates between nodes and edges, each

edge in XP connects the node before and after it, and XP ends with a node.

b)

For every two node bindings ( LET 1, E 1) and ( LET 2, E 2) that are not separable, E 1 = E 2.

« WG3:UTC-009 P00-USA-169 »

NOTE 260 — If there are only bracket symbol or subpath symbol bindings between two node bindings, then

the node bindings must bind to the same node.

c)

For every edge binding EB = ( LET, GE), let (LETleft, GEleft) be the last node binding to the left of EB and let (LETright, GEright) be the first node binding to the right of EB.

Case:

i)

If GE is an undirected edge, then GE is an edge connecting GEleft and GEright.

ii)

If GE is a directed edge, then either GEleft is the source node and GEright is the destination

node of GE, or GEright is the source node and GEleft is the destination node of GE.

NOTE 261 — The directionality constraint of the edge binding is fully checked during the generation

of the regular language for <path concatenation> .

d)

For every start bracket symbol binding SBS contained in B, let j be the bracket index of SBS.

All of the following are true:

i)

There is an end bracket symbol binding contained in B and following SBS whose bracket

index is j. Let EBS be the first such end bracket symbol binding. Let PPS be the explicit

or implicit <path mode prefix> simply contained in the <parenthesized path pattern

expression> whose bracket index is j. Let PM be the <path mode> contained in PPS.

ii)

Case:

1)

If PM is TRAIL, then there is no pair of edge bindings at two different positions

between SBS and EBS that bind the same edge.

NOTE 262 — This definition does not take note of the symbols that are bound, only the edges.

It is a violation of the TRAIL <path mode> if the symbols in the pair of distinct edge bindings

are both anonymous edge symbols, are both edge variables (whether the same or different),

or one is the anonymous edge symbol and the other is an edge variable.

2)

If PM is SIMPLE, then no two separable node bindings between SBS and EBS bind

the same node, except that the first and last node binding between SBS and SES

may bind the same node.

« Editorial: Align with Directives Part 2 »

NOTE 263 — This definition does not take note of the symbols that are bound, only the nodes.

It is a violation of the SIMPLE <path mode> if the symbols in the pair of separable node bindings

are both anonymous node symbols, are both node variables (whether the same or different),

or one is the anonymous node symbol and the other is a node variable. However, the first and

last node binding between SBS and EBS can bind the same node without violating the SIMPLE

<path mode> .

3)

If PM is ACYCLIC, then no two separable node bindings between SBS and EBS bind

the same node.

449

IWD 39075:202y(E)

22.2 Machinery for graph pattern matching

NOTE 264 — This definition does not take note of the symbols that are bound, only the nodes.

It is a violation of the ACYCLIC <path mode> if the symbols in the pair of separable node

bindings are both anonymous node symbols, both are node variables (whether the same or

different), or one is the anonymous node symbol and the other is a node variable.

NOTE 265 — The <path mode> WALK imposes no constraints on the extracted path.

17) A multi-path binding is an n-tuple ( PB 1, ..., PBn) for some positive integer n such that each PBi, 1

(one) ≤ i ≤ n, is a path binding.

« WG3:UTC-009 P00-USA-169 »

18) If S and T are sets of strings, then let S ⋅ T be the set of strings formed by concatenating an element of S followed by an element of T; that is, S ⋅ T = { s t | s is an element of S, t is an element of T }.

NOTE 266 — The ⋅ operator will be used to concatenate words (strings of symbols) and path bindings (strings of

elementary bindings).

19) If S is a set of strings, then let S 0 be the set whose only element is the string of length 0 (zero), and for each non-negative integer n, let Sn+1 be Sn ⋅ S. Let S* be the union of Sn for every non-negative integer n.

NOTE 267 — If S is not empty, then S* is an infinite set; however, a finite result for every <graph pattern> is assured by the syntactic requirement that every <quantified path primary> is bounded, contained in a restrictive <parenthes-

ized path pattern expression> or contained in a selective <path pattern>.

20) REDUCE is extended to multi-path bindings as follows. If MPB = ( PB 1, ..., PBn) is a multi-path binding, then REDUCE( MPB) = ( REDUCE( PB 1), ..., REDUCE( PBn)).

21) Let MACH be a data structure comprising the following:

a)

ABC, the alphabet, formed as the disjoint union of the following:

i)

SVV, the set of names of node variables.

ii)

SEV, the set of names of edge variables.

iii)

SPS, the set of subpath symbols.

iv)

SAS, the set of anonymous symbols.

v)

SBS, the set of bracket symbols.

b)

REDUCE, the function mapping path bindings to path bindings, and multi-path bindings to

multi-path bindings.

22) Evaluation of the General Rules is terminated and control is returned to the invoking Subclause,

which receives MACH as MACHINERY.

Conformance Rules

None.

450





IWD 39075:202y(E)

22.3 Evaluation of a <path pattern expression>

22.3 Evaluation of a <path pattern expression>

Function

Evaluate a <path pattern expression>.

Subclause Signature

“Evaluation of a <path pattern expression> ” [General Rules] (

Parameter: “PROPERTY GRAPH”,

Parameter: “PATH PATTERN LIST”,

Parameter: “MACHINERY”,

Parameter: “SPECIFIC BNF INSTANCE”

) Returns: “SET OF MATCHES”

« Editorial: Add documentation »

PROPERTY GRAPH — a property graph.

PATH PATTERN LIST — a <path pattern list>. "

MACHINERY — the machinery for graph pattern matching.

SPECIFIC BNF INSTANCE — the specific instance of a BNF non-terminal to be evaluated.

« WG3:W25-016 »

SET OF MATCHES — the set of local matches to the SPECIFIC BNF INSTANCE.

— This signature is invoked from Subclause 16.8, “<graph pattern>”, GR 5)b)

Syntax Rules

None.

General Rules

1)

Let PG be the PROPERTY GRAPH, let PPL be the PATH PATTERN LIST, let MACH be the MACHINERY, and let SBI be the SPECIFIC BNF INSTANCE in an application of the General Rules of this Subclause.

The result of the application of this Subclause is returned as SET OF MATCHES.

2)

The following components of MACH are identified:

a)

ABC, the alphabet, formed as the disjoint union of the following:

i)

SVV, the set of names of node variables.

ii)

SEV, the set of names of edge variables.

iii)

SPS, the set of subpath symbols.

iv)

SAS, the set of anonymous symbols.

v)

SBS, the set of bracket symbols.

b)

REDUCE, the function mapping path bindings to path bindings, and multi-path bindings to

multi-path bindings.

451

IWD 39075:202y(E)

22.3 Evaluation of a <path pattern expression>

3)

For every instance BNT of a BNF non-terminal that is a <path pattern expression>, <path term>,

<path pattern union>, <path factor> , <path concatenation>, <path primary>, <quantified path

primary>, <questioned path primary>, <element pattern> , or <parenthesized path pattern expres-

sion> equal to or contained in SBI at the same depth of graph pattern matching, the following are defined by simultaneous recursion: the regular language of BNT, denoted RL( BNT), defined as a set

of words over ABC; and the set of local matches to BNT, denoted SLM( BNT), defined as a set of path bindings.

NOTE 268 — SLM( BNT) is consistent except when concatenating an edge pattern prior to concatenating the following node pattern. Restrictive path modes are enforced when generating SLM( BNT) for the <parenthesized path pattern

expression> that declares the path mode.

« Editorial: Align with Directives Part 2 »

NOTE 269 — RL( BNT) and SLM( BNT) can be infinite sets if BNT contains an effectively unbounded quantifier. Every effectively unbounded quantifier is required to be contained in a selective <path pattern>; the potentially infinite set of local matches is subsequently reduced to a finite set by the General Rules of Subclause 22.4, “Evaluation of a

selective <path pattern>”.

NOTE 270 — The BNF non-terminals are listed above in the “top down” order of appearance in the Format of

Subclause 16.10, “<path pattern expression>” ; the definitions in the following subrules treat the same BNF non-terminals in “bottom up” order.

Case:

a)

If BNT is a <parenthesized path pattern expression>, then let PPE be the <path pattern

expression> immediately contained in BNT and let j be the bracket index of BNT.

NOTE 271 — “Bracket index” is defined in Subclause 22.2, “Machinery for graph pattern matching”.

i)

Case:

1)

If BNT simply contains a <subpath variable declaration> SVD, then let SV be the subpath variable declared by SVD. Let BSV be the begin subpath symbol associated

with SV and let ESV be the end subpath symbol associated with SV. Let BSVBINDING

be ( BSV, BSV) and let ESVBINDING be ( ESV, ESV).

2)

Otherwise, let BSV, ESV, BSVBINDING and ESVBINDING be the empty string.

ii)

RL( BNT) is { `[ j` } ⋅ { BSV } ⋅ RL( PPE) ⋅ { ESV } ⋅ { `] j` }

iii)

Let STPB be SLM(PPE).

Let SLMMAYBE be { (`[ j`, `[ j`) } ⋅ { BSVBINDING } ⋅ STPB ⋅ { ESVBINDING } ⋅ { (`] j`, `] j`) }

SLM( BNT) is the set of every path binding in SLMMAYBE that is consistent.

NOTE 272 — That is, the words in RL( BNT) are formed by surrounding the words of RL( PPE) by the

bracket symbols `[ j ànd `] j`. If BNT contains a subpath variable declaration, then the words of RL( BNT) are also surrounded by the begin and end subpath symbol associated with that subpath variable.

Similarly, the path bindings in SLMMAYBE are formed by surrounding the path bindings with bracket

bindings and, if there is a subpath declaration, with the corresponding begin and end subpath bindings.

Eliminating inconsistent bindings from SLMMAYBE to get SLM( BNT) has the effect of enforcing

restrictive path modes.

b)

If BNT is an <element pattern> EP, then:

i)

Case:

1)

If EP declares an element variable EV, then let EPI be the name of EV.

2)

If EP is a <node pattern> , then let EPI bè()`, the anonymous node symbol.

3)

If EP is an <edge pattern>, then let EPI bè-`, the anonymous edge symbol.

ii)

RL( BNT) is { EPI }, the set whose sole member is EPI.

452

IWD 39075:202y(E)

22.3 Evaluation of a <path pattern expression>

iii)

SLM( BNT) is the set of every elementary binding ( EPI, GE) such that:

1)

If EP is a <node pattern> , then GE is a node.

2)

If EP is an <edge pattern>, then GE is an edge.

3)

If EP simply contains a <label expression> LE, then the value of TV is True when the Syntax Rules of Subclause 22.5, “Satisfaction of a <label expression> by a label

set”, are applied with LE as LABEL EXPRESSION and the label set of GE as LABEL

SET; let TV be the TRUTH VALUE returned from the application of those Syntax Rules.

c)

If BNT is a <quantified path primary> , then:

i)

Let PP be the <path primary> immediately contained in BNT. As a result of the trans-

formations in the Syntax Rules, PP is a <parenthesized path pattern expression>. Let

R be RL( PP) and let S be SLM( PP).

ii)

Let GQ be the <general quantifier> immediately contained in BNT.

iii)

Let LB be the value of the <lower bound> contained in GQ.

iv)

Case:

1)

If GQ contains an <upper bound> , then let UB be the value of the <upper bound>.

A)

RL( BNT) is RLB ∪ RLB+1 ∪ ... ∪ RUB−1 ∪ R UB.

B)

Let TOOMUCH be SLB ∪ SLB+1 ∪ ... ∪ SUB−1 ∪ SUB.

C)

SLM( BNT) is the set of those path bindings in TOOMUCH that are consistent.

2)

Otherwise,

A)

RL( BNT) is RLB ⋅ R*.

B)

Let WAYTOOMUCH be SLB ⋅ S*.

C)

SLM( BNT) is the set of those path bindings in WAYTOOMUCH that are con-

sistent.

d)

If BNT is a <questioned path primary> , then:

i)

Let PP be the <path primary> immediately contained in BNT. As a result of the trans-

formations in the Syntax Rules, PP is a <parenthesized path pattern expression>. Let

R be RL( PP) and let S be SLM( PP).

ii)

RL( BNT) is R 0 ∪ R.

iii)

SLM( BNT) is S 0 ∪ S.

e)

If BNT is a <path primary> , then let BNT2 be the <element pattern> or <parenthesized path

pattern expression> that is immediately contained in BNT.

i)

RL( BNT) is RL( BNT2).

ii)

SLM( BNT) is SLM( BNT2).

f)

If BNT is a <path concatenation> , then:

i)

Let PST be the <path term> and let PC be the <path factor> that are immediately contained in BNT.

453

IWD 39075:202y(E)

22.3 Evaluation of a <path pattern expression>

ii)

RL( BNT) is RL( PST) ⋅ RL( PC).

iii)

Case:

1)

If PC is an <edge pattern>, then SLM( BNT) is SLM( PST) ⋅ SLM( PC) NOTE 273 — If PC is an <edge pattern> , then there is a <node pattern> to its right, which will be concatenated in a subsequent iteration of this recursion; consistency, including the directionality constraint implied by the <edge pattern> , will be checked at that point.

2)

If PC is a <node pattern> , and the last <element pattern> EP of PST is an <edge

pattern> , then:

NOTE 274 — By transformations in the Syntax Rules of Subclause 16.10, “<path pattern

expression>”, an edge binding is always immediately preceded and followed by a node binding.

The current rule handles the situation in which the edge has been bound as the last elementary

binding of PST, and therefore PC is the node binding that immediately follows the edge binding.

Also note that the Syntax Rules have transformed every <abbreviated edge pattern> to a <full

edge pattern>.

A)

Let SLMCONCAT be SLM( PST) ⋅ SLM( PC).

B)

For each path binding PB contained in SLMCONCAT,

I)

Let GEright be the node that is bound in the last elementary binding

of PB.

II)

Let GE be the edge that is bound in the penultimate elementary

binding of PB.

III)

Let GEleft be the node that is bound in the antepenultimate elementary

binding of PB.

C)

Let the propositions L, U, and R be determined as follows:

I)

Proposition L is true if GE is a directed edge, GEleft is the destination

node of GE and GEright is the source node of GE.

II)

Proposition U is true if GE is an undirected edge, and GEleft and GEright

are the nodes connected by GE.

III)

Proposition R is true if GE is a directed edge, GEleft is the source node

of GE and GEright is the destination node of GE.

D)

Let the directionality constraint of EP be

Case:

I)

If EP is a <full edge pointing left>, then proposition L is true.

II)

If EP is a <full edge undirected>, then proposition U is true.

III)

If EP is a <full edge pointing right>, then proposition R is true.

IV)

If EP is a <full edge left or undirected>, then proposition L, or propos-

ition U, is true.

V)

If EP is a <full edge undirected or right>, then proposition U, or pro-

position R, is true.

VI)

If EP is a <full edge left or right> , then proposition L, or proposition

R, is true.

454

IWD 39075:202y(E)

22.3 Evaluation of a <path pattern expression>

VII)

If EP is a <full edge any direction>, then at least one of proposition

L, proposition U, or proposition R, is true.

E)

SLM( BNT) is the set of those path bindings of SLMCONCAT that are consistent

and satisfy the directionality constraint of EP.

3)

Otherwise, SLM( BNT) is the set of those path bindings in SLM( PST) ⋅ SLM( PC) that are consistent.

** Editor’s Note (number 67) **

It may be possible to enforce implicit joins of unconditional singletons exposed by a <path con-

catenation> as part of the GRs for <path concatenation> . This was discussed in an SQL/PGQ ad hoc meeting on September 8, 2020. It was decided not to attempt that change as part of WG3:W04-009R1, leaving it as a future possibility. See Language Opportunity GQL-044 .

g)

If BNT is a <path factor>, then let BNT2 be the <path primary> , <quantified path primary> or

<questioned path primary> immediately contained in BNT.

i)

RL( BNT) is RL( BNT2).

ii)

SLM( BNT) is SLM( BNT2).

h)

If BNT is a <path pattern union> , then let NMA be the number of <path term>s immediately contained in BNT. Let PMO 1, ..., PMONMA be these <path term>s.

i)

RL( BNT) is RL( PMO 1) ∪ RL( PMO 2) ∪ ... ∪ RL( PMONMA).

ii)

SLM( BNT) is SLM( PMO 1) ∪ SLM( PMO 2) ∪ ... ∪ SLM( PMONMA).

i)

If BNT is <path term> , then let BNT2 be the <path factor> or <path concatenation> immediately contained in BNT.

i)

RL( BNT) is RL( BNT2).

ii)

SLM( BNT) is SLM( BNT2).

j)

If BNT is a <path pattern expression>, then let BNT2 be the <path term> or <path pattern

union> immediately contained in BNT.

NOTE 275 — <path multiset alternation> is transformed into <path pattern union> in the Syntax Rules and therefore it is not considered separately here.

i)

RL( BNT) is RL( BNT2).

ii)

SLM( BNT) is SLM( BNT2).

4)

Let SM be SLM( SBI).

5)

Evaluation of the General Rules is terminated and control is returned to the invoking Subclause,

which receives SM as SET OF MATCHES.

Conformance Rules

None.

455





IWD 39075:202y(E)

22.4 Evaluation of a selective <path pattern>

22.4 Evaluation of a selective <path pattern>

Function

Evaluate a <path pattern> with a selective <path search prefix>.

Subclause Signature

“Evaluation of a selective <path pattern> ” [General Rules] (

Parameter: “PROPERTY GRAPH”,

Parameter: “PATH PATTERN LIST”,

Parameter: “MACHINERY”,

Parameter: “SELECTIVE PATH PATTERN”,

Parameter: “INPUT SET OF LOCAL MATCHES”

) Returns: “OUTPUT SET OF LOCAL MATCHES”

« Editorial: Add documentation »

PROPERTY GRAPH — a property graph.

PATH PATTERN LIST — a <path pattern list>.

MACHINERY — the machinery for graph pattern matching.

SELECTIVE PATH PATTERN — a selective <path pattern>.

« WG3:W25-016 »

INPUT SET OF LOCAL MATCHES — a set, possibly infinite, of matches to SELECTIVE PATH PATTERN.

OUTPUT SET OF LOCAL MATCHES — finite subset of the INPUT SET OF LOCAL MATCHES, selected

according to the criterion indicated by the selective <path search prefix> of SELECTIVE PATH PAT-

TERN.

— This signature is invoked from Subclause 16.8, “<graph pattern>”, GR 5)c)i)2)

Syntax Rules

None.

General Rules

1)

Let PG be the PROPERTY GRAPH, let PPL be the PATH PATTERN LIST, let MACH be the MACHINERY, let SEL be the SELECTIVE PATH PATTERN, and let INSLM be the INPUT SET OF LOCAL MATCHES in

an application of the General Rules of this Subclause. The result of the application of this Subclause

is returned as OUTPUT SET OF LOCAL MATCHES.

2)

It is implementation-defined (IA013) whether the General Rules of this Subclause are terminated

if an exception condition is raised. If a GQL-implementation defines that it terminates execution

because of an exception condition, it is implementation-dependent (UA006) which of the members

of CANDIDATES (defined subsequently) are actually probed to establish whether they might raise

an exception.

« Editorial: Align with Directives Part 2 »

NOTE 276 — CANDIDATES is potentially an infinite set, but there are algorithms to enumerate this set so as to satisfy

the selection criterion of the selective <path pattern> without testing all candidate solutions. Even if the SQL-implementation defines that it terminates when an exception condition is encountered on a particular candidate

456

IWD 39075:202y(E)

22.4 Evaluation of a selective <path pattern>

solution, the order of enumerating the candidates is implementation-dependent, and it is possible that a candidate

solution that would raise an exception is never tested.

3)

The following components of MACH are identified:

a)

ABC, the alphabet, formed as the disjoint union of the following:

i)

SVV, the set of names of node variables.

ii)

SEV, the set of names of edge variables.

iii)

SPS, the set of subpath symbols.

iv)

SAS, the set of anonymous symbols.

v)

SBS, the set of bracket symbols.

b)

REDUCE, the function mapping path bindings to path bindings, and multi-path bindings to

multi-path bindings.

4)

Let NP be the number of <path pattern>s in PPL.

5)

SEL is a selective <path pattern>. Let j be the bracket index of the <parenthesized path pattern

expression> simply contained in SEL.

NOTE 277 — “Bracket index” is defined in Subclause 22.2, “Machinery for graph pattern matching”.

NOTE 278 — By a syntactic transformation in Subclause 16.8, “<graph pattern>” , this <parenthesized path pattern

expression> is the entire content of SEL except possibly the declaration of a path variable.

6)

Let PSP be the <path search prefix> simply contained in SEL.

7)

Let N be the value of the <number of paths> or the <number of groups> specified in PSP. If N is not a positive integer, then an exception condition is raised: data exception — invalid number of paths

or groups (22G0F) and no further General Rules of this Subclause are applied.

8)

Let p be such that SEL is the p-th <path pattern> of PPL.

« Email from: Jim Melton 2022-12-08 0219 »

9)

Let CANDIDATES be the set of every path binding PBX in INSLM such that all of the following condi-

tions are true:

a)

For every unconditional singleton <element variable> EV exposed by SEL, EV is bound to a unique graph element by the elementary bindings of EV contained in PBX.

NOTE 279 — Anonymous symbols are not <element variable>s; there is no requirement that two anonymous

symbols bind to the same graph element.

b)

For every <parenthesized path pattern expression> PPPE equal to or contained in SEL, let i be the bracket index of PPPE, and let `[ì and `]ì be the bracket symbols associated with PPPE.

A binding of PPPE is a substring of PBX that begins with the bracket binding (`[ i`, `[ i`) and ends with the next bracket binding (`] i`, `] i`).

NOTE 280 — “Bracket index” is defined in Subclause 22.2, “Machinery for graph pattern matching”.

« Email from: Jim Melton 2022-12-08 0219 »

For every binding BPPPE of PPPE contained in PBX, all of the following are true:

i)

For every <element variable> EV that is exposed as an unconditional singleton by PPPE, EV is bound to a unique graph element by the elementary bindings of EV contained in

BPPPE.

NOTE 281 — Anonymous symbols are not <element variable>s; there is no requirement that two

anonymous symbols bind to the same graph element.

457

IWD 39075:202y(E)

22.4 Evaluation of a selective <path pattern>

ii)

If PPPE contains a <parenthesized path pattern where clause> PPPWC, then the value

of V is True when the General Rules of Subclause 22.6, “Applying bindings to evaluate

an expression”, are applied with PPL as GRAPH PATTERN, the <search condition> simply contained in PPPWC as EXPRESSION, MACH as MACHINERY, PBX as MULTI-PATH

BINDING, and a reference to BPPPE as a subset of PBX as REFERENCE TO LOCAL CON-

TEXT; let V be the VALUE returned from the application of those General Rules.

« Editorial: Align with Directives Part 2 »

NOTE 282 — This is the juncture at which an exception condition might be raised. It is implementation-

defined whether to terminate if an exception condition is raised. The order of enumerating the

members of CANDIDATES is implementation-dependent, and there is no requirement that a GQL-

implementation test all candidate solutions, which can be an infinite set in any case.

10) Each path binding PBX of CANDIDATES is replaced by REDUCE( PBX).

11) Redundant duplicate path bindings are removed from CANDIDATES.

12) CANDIDATES is partitioned as follows. For every path binding PBX in CANDIDATES, the partition of

PBX is the set of every path binding PBY in CANDIDATES such that the first and last node bindings

of PBX bind the same nodes as the first and last node bindings, respectively, of PBY.

13) Each partition PART of CANDIDATES is modified as follows.

Case:

a)

If PSP is an <any path search>, then

Case:

i)

If the number of path bindings in PART is N or less, then the entire partition PART is

retained.

ii)

Otherwise, it is implementation-dependent (UA005) which N path bindings of PART

are retained.

b)

If PSP is a <shortest path search> , then

Case:

i)

If PSP is a <counted shortest path search>, then

Case:

1)

If the number of path bindings in PART is N or less, then the entire partition PART

is retained.

2)

Otherwise, the path bindings of PART are sorted in increasing order of number

of edges; the order of path bindings that have the same number of edges is

implementation-dependent (US005). The first N path bindings in PART are

retained.

ii)

If PSP is <counted shortest group search>, then the path bindings in PART are grouped, with each group comprising those path bindings having the same number of edges.

The groups are ordered in increasing order by the number of edges.

Case:

1)

If the number of groups in PART is N or less, then the entire partition PART is

retained.

2)

Otherwise, the path bindings comprising the first N groups of PART are retained.

458

IWD 39075:202y(E)

22.4 Evaluation of a selective <path pattern>

14) Let OUTSLM be the set of path bindings retained in CANDIDATES after the preceding modifications

to its partitions.

15) Evaluation of the General Rules is terminated and control is returned to the invoking Subclause,

which receives OUTSLM as OUTPUT SET OF LOCAL MATCHES.

Conformance Rules

None.

459





IWD 39075:202y(E)

22.5 Satisfaction of a <label expression> by a label set

22.5 Satisfaction of a <label expression> by a label set

Function

Determine if a label set satisfies a <label expression>.

Subclause Signature

“Satisfaction of a <label expression> by a label set” [Syntax Rules] (

Parameter: “LABEL EXPRESSION”,

Parameter: “LABEL SET”

) Returns: “TRUTH VALUE”

« Editorial: Add documentation »

LABEL EXPRESSION — a <label expression>.

LABEL SET — the label set of a graph element.

TRUTH VALUE — True if the DEFINED LABEL SET satisfies the LABEL EXPRESSION; otherwise False.

— This signature is invoked from Subclause 19.9, “<labeled predicate>”, GR 2)b)i)

— This signature is invoked from Subclause 22.3, “Evaluation of a <path pattern expression>”, GR 3)b)iii)3)

Syntax Rules

1)

Let LEXP be the LABEL EXPRESSION and let LS be the LABEL SET in an application of the Syntax Rules of this Subclause. The result of the application of this Subclause is returned as TRUTH VALUE.

2)

A label set LS satisfies a <label expression> LE according to the following recursive definition: a)

If LE is a <label name> L2, then L2 is a member of LS.

b)

If LE is a <wildcard label> , then LS is non-empty.

NOTE 283 — This condition is always true; every label set is non-empty. The rule is written this way in case

empty label sets are permitted in the future, or for guidance to a GQL-implementation that supports graph

elements with no labels.

c)

If LE is a <parenthesized label expression> PLE, then let LE2 be the <label expression> simply contained in PLE; LS satisfies LE2.

d)

If LE is a <label negation> , then let LP be the <label primary> simply contained in LE; LS does not satisfy LP.

e)

If LE is a <label conjunction>, then let L1 be the <label term> and let L2 be the <label factor>

simply contained in LE; LS satisfies L1 and LS satisfies L2.

f)

If LE is a <label disjunction> , then let L1 be the <label expression> and let L2 be the <label

term> simply contained in LE; LS satisfies L1 or LS satisfies L2.

3)

TV is

Case:

a)

If LS satisfies LEXP, then True.

b)

Otherwise, False.

460

IWD 39075:202y(E)

22.5 Satisfaction of a <label expression> by a label set

4)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause,

which receives TV as TRUTH VALUE.

General Rules

None.

Conformance Rules

None.

461





IWD 39075:202y(E)

22.6 Applying bindings to evaluate an expression

22.6 Applying bindings to evaluate an expression

Function

Evaluate a <value expression> or <search condition> using the bindings of graph pattern variables determined by a local context within a multi-path binding.

Subclause Signature

“Applying bindings to evaluate an expression” [General Rules] (

Parameter: “GRAPH PATTERN”,

Parameter: “EXPRESSION”,

Parameter: “MACHINERY”,

Parameter: “MULTI-PATH BINDING”,

Parameter: “REFERENCE TO LOCAL CONTEXT”

) Returns: “VALUE”

« Editorial: Add documentation »

GRAPH PATTERN — a <graph pattern>.

EXPRESSION — a <value expression> or <search condition>.

MACHINERY — the machinery for graph pattern matching.

MULTI-PATH BINDING — multi-path binding to the <graph pattern> in which to evaluate the

expression.

« WG3:W25-016 »

REFERENCE TO LOCAL CONTEXT — an indication of a subset of the multi-path binding, the local

context. Group bindings are confined to the local context; singleton bindings may look outside the

local context.

VALUE — the evaluated value of EXPRESSION.

— This signature is invoked from Subclause 16.8, “<graph pattern>”, GR 9)a)ii)

— This signature is invoked from Subclause 16.8, “<graph pattern>”, GR 9)b)

— This signature is invoked from Subclause 22.4, “Evaluation of a selective <path pattern>” , GR 9)b)ii)

— This signature is invoked from Subclause 22.8, “Applying bindings to generate a record”, GR 2)b)i)

Syntax Rules

None.

General Rules

1)

Let GP be the GRAPH PATTERN, let EXP be the EXPRESSION, let MACH be the MACHINERY, let MPB

be the MULTI-PATH BINDING, and let RTLC be the REFERENCE TO LOCAL CONTEXT in an application

of the General Rules of this Subclause. The result of the application of this Subclause is returned as

VALUE.

2)

The following components of MACH are identified:

a)

ABC, the alphabet, formed as the disjoint union of the following:

i)

SVV, the set of names of node variables.

462

IWD 39075:202y(E)

22.6 Applying bindings to evaluate an expression

ii)

SEV, the set of names of edge variables.

iii)

SPS, the set of subpath symbols.

iv)

SAS, the set of anonymous symbols.

v)

SBS, the set of bracket symbols.

b)

REDUCE, the function mapping path bindings to path bindings, and multi-path bindings to

multi-path bindings.

3)

Let LC be the subset of MPB that is indicated by RTLC.

« WG3:W25-016 »

NOTE 284 — The local context is passed “by reference” in order to correctly evaluate non-local singletons. For

example, given the pattern:

( (A) -> ( (B) -> (C) WHERE A.X = B.X+C.X ) -> (D)){2}

then A.X makes a non-local reference to element variable A. A word of this pattern will repeat the outer <parenthesized

path pattern expression> twice, requiring two evaluations of the WHERE clause. Each evaluation of the WHERE

clause must locate the appropriate non-local reference to A. The bindings to the inner <parenthesized path pattern

expression>, if passed “by value”, might not be enough information to determine the appropriate binding to the outer

<parenthesized path pattern expression> .

4)

Let VREFS be the variable references that are contained in EXP whose variable is an element variable

or a path variable declared by GP that is in the scope of EXP, let n be the number elements of VREFS, let VRi be the i-th element of VREFS, for 1 (one) ≤ i ≤ n. The projected field value is a value defined for the variable references in VREFS according to the following General Rules.

5)

If EVR is a variable reference in VREFS whose variable is an element variable, then the projected

field value of EVR is defined as follows:

a)

Let DEG be the degree of reference of EVR.

b)

Let EV be the element variable of EVR.

c)

Case:

i)

If LC is equal to MPB, then let SPACE be MPB.

NOTE 285 — That is, the search space is the entire multi-path binding. This case arises in two circum-

stances: 1) the evaluation of a <parenthesized path pattern where clause> in the outermost <paren-

thesized path pattern expression> of a selective <path pattern> ; 2) the evaluation of a <graph pattern

where clause>.

ii)

Otherwise, let LCBI be the bracket index of the first bracket symbol in LC. Let LCPPPE

be the <parenthesized path pattern expression> contained in GP whose bracket index

is LCBI. Let PP be the <path pattern> containing LCPPPE.

NOTE 286 — “Bracket index” is defined in Subclause 22.2, “Machinery for graph pattern matching”.

Case:

1)

If EV is not declared by PP, then let SPACE be MPB.

NOTE 287 — In this case, EV is declared in some other <path pattern> than the one that contains ER. ER is a non-local reference, therefore DEG is singleton, and EV must be exposed as a singleton by the <path pattern> (s) that declare it.

2)

If EV is declared by LCPPPE, then let SPACE be LC.

NOTE 288 — In this case, EV is declared locally to LCPPPE and the binding(s) to ER can be

found by searching the local context LC.

3)

Otherwise, let DEFPPPE be the innermost <parenthesized path pattern expression>

that declares EV and that contains LCPPPE. Let BI be the bracket index of DEFPPPE.

463

IWD 39075:202y(E)

22.6 Applying bindings to evaluate an expression

Let `[BÌ and `]BÌ be the bracket symbols whose bracket index is BI. Let SPACE be

the smallest substring of MBP containing LC and beginning with `[ BI ànd ending

with `] BI`.

NOTE 289 — In this case, EV is declared in some outer scope containing LCPPPE, and the

binding of ER, if any, is found by searching the innermost scope that declares EV. ER is a non-

local reference, therefore DEG is singleton, and EV must be exposed as a singleton by DEFPPPE.

NOTE 290 — “Bracket index” is defined in Subclause 22.2, “Machinery for graph pattern

matching”.

d)

Case:

i)

If DEG is singleton, then

Case:

1)

If there is an elementary binding EB of EV in SPACE, then let LOE be a list with a

single graph element, the graph element that is bound to EV by EB.

NOTE 291 — Even if EV is bound multiple times in SPACE (expressing an equijoin on EV), the

list has only one graph element.

2)

Otherwise, let LOE be the empty list.

NOTE 292 — This case can only arise if DEG is conditional singleton.

ii)

If DEG is group, then

Case:

1)

If SPACE does not contain an elementary binding of EV, then let LOE be an empty

list.

2)

Otherwise, let LOE be the list of the graph elements that are bound to EV by ele-

mentary bindings in the order that they occur in SPACE, scanning SPACE from

left to right, and retaining duplicates.

** Editor’s Note (number 68) **

The bindings of a group reference flatten nested lists. This may be acceptable for SQL aggregates,

which have no support for nested groupings, but may be inadequate to fully capture the semantics

of a group reference in a graph pattern. WG3:MMX-035r2 section 4.1, “Desynchronized lists”

pointed out a problem with reducing group variables to lists: two lists may be interleaved, but

the reduction to separate lists can lose this information. The example given is

( (A:Person) -[:SPOUSE]-> ()

| (B:Person) -[:FRIEND]-> () ){3}

A solution may find matches to A and B in any order. With separate lists of matches of A and B,

it will not be easy to reconstruct the precise sequence of interleaved matches to A and B.

A similar problem can arise with nested quantifiers. WG3:MMX-035r2 section 4.2, “Nested

quantifiers” gives this example:

( (C1:CORP) (-[:TRANSFERS]->(B:BANK))*

-[:TRANSFERS]-> (C2:CORP) )*

With this pattern, there can be 0 (zero) or more bindings to B between any two consecutive

bindings to C1 and C2. With just independent lists of matches to C1, B and C2, it will not be easy

to determine what bindings to B lie between what bindings to C1 and C2.

e)

LOE is the list of graph elements bound to ER.

f)

The projected field value of EV is defined as follows.

Case:

464

IWD 39075:202y(E)

22.6 Applying bindings to evaluate an expression

i)

If DEG is singleton, then:

1)

If EV is a node variable and LOE contains a single node N, then the projected field

value of EVR is a node reference value for N.

2)

If EV is an edge variable and LOE contains a single edge E, then the projected field

value of EVR is an edge reference value for E.

3)

Otherwise, DEG is conditional singleton, LOE is empty, and the projected field

value of EVR is the null value.

ii)

Otherwise, DEG is group.

Case:

1)

If EV is a node variable, then the projected field value of EVR is the list value

comprising node reference values for the nodes given by LOE (in the order

determined by LOE).

2)

If EV is an edge variable, then the projected field value of EVR is the list value

comprising edge reference values for the edges given by LOE (in the order

determined by LOE).

6)

If PVR is a variable reference in VREFS whose variable is a path variable, then the projected field

value of PVR is defined as follows:

a)

Let PV be the path variable of PVR.

b)

Let PB be the path binding of MPB corresponding to the <path pattern> that declares PV.

c)

Let EP be the extracted path of PB and let PEL be the graph element list whose elements are

graph reference values for the graph elements given by EP (in the order determined by EP).

d)

The projected field value of PVR is the path value whose path element list is PEL.

7)

Let R be a record with fields Fi, 1 (one) ≤ i ≤ n, whose field name is the variable name of VRi and whose field value is the projected field value of VRi.

8)

Let V be the result of evaluating EXP in a new child execution context amended with R.

NOTE 293 — The type of the working record of this child execution context is determined by SR 25) of Subclause 16.7,

“<graph pattern binding table>” .

9)

Evaluation of the General Rules is terminated and control is returned to the invoking Subclause,

which receives V as VALUE.

Conformance Rules

None.

465





IWD 39075:202y(E)

22.7 Evaluating an expression on a group variable

22.7 Evaluating an expression on a group variable

Function

Evaluate a value expression that contains references to exactly one variable whose type is a group list

value type.

Subclause Signature

“Evaluating an expression on a group variable” [General Rules] (

Parameter: “GROUP LIST BINDING VARIABLE”,

Parameter: “EXPRESSION”

) Returns: “LIST VALUE”

GROUP LIST BINDING VARIABLE — a <binding variable> with group degree of reference

EXPRESSION — a <value expression> that references GROUP LIST BINDING VARIABLE

— This signature is invoked from Subclause 16.19, “<aggregate function>” , GR 4)a)ii)

« WG3:UTC-123R2 with corrections »

Syntax Rules

None.

General Rules

1)

Let GLBV be the GROUP LIST BINDING VARIABLE and let EXP be the EXPRESSION in an application of the General Rules of this Subclause. The result of the application of this Subclause is returned as

LIST VALUE. .

2)

Let NAME bet the name of GLBV.

3)

Let CWR be the current working record.

4)

Let ELTS be the value of the field of CWR whose name is NAME and let NELTS be the number of elements of ELTS.

NOTE 294 — ELTS is always a list of graph element reference values.

5)

Let LV be a list value determined as follows.

a)

Initially, LV is an empty list.

b)

For every i, 1 (one) ≤ i ≤ NELTS:

i)

Let FIELD be the field whose name is NAME and whose value is the i-th element of ELTS.

ii)

In a new child execution context whose working record is amended with the record

comprising FIELD: The result of EXP is appended to LV.

6)

Evaluation of the General Rules is terminated and control is returned to the invoking Subclause,

which receives LV as LIST VALUE.

466

IWD 39075:202y(E)

22.7 Evaluating an expression on a group variable

Conformance Rules

« WG3:UTC-123R2 »

1)

Without Feature GC28, “Element-wise group variable operations”, EXP shall be a <binding variable

reference> to GLBV.

467





IWD 39075:202y(E)

22.8 Applying bindings to generate a record

22.8 Applying bindings to generate a record

Function

Generate a record of output from a <graph pattern binding table>.

Subclause Signature

“Applying bindings to generate a record” [General Rules] (

Parameter: “GRAPH PATTERN”,

Parameter: “YIELD CLAUSE”,

Parameter: “MULTI-PATH BINDING”,

Parameter: “MACHINERY”

) Returns: “RECORD”

« Editorial: Add documentation »

GRAPH PATTERN — a <graph pattern>.

YIELD CLAUSE — a <graph pattern yield clause> .

MULTI-PATH BINDING — a multi-path binding.

MACHINERY — the machinery for graph pattern matching.

RECORD — a record to be output by <graph pattern binding table>.

— This signature is invoked from Subclause 16.7, “<graph pattern binding table>”, GR 5)e)i)

Syntax Rules

None.

General Rules

1)

Let GP be the GRAPH PATTERN, let YC be the YIELD CLAUSE, let MPB be the MULTI-PATH BINDING, and let MACH be the MACHINERY in an application of the General Rules of this Subclause. The result

of the application of this Subclause is returned as RECORD. .

2)

Let n be the number of <graph pattern variable> s simply contained in YC, let YCi be the i-th such

<graph pattern variable>, and let RECORD be a record with n fields Fi, 1 (one) ≤ i ≤ n determined as follows:

a)

The name of Fi is YCi.

b)

The value of Fi is determined as follows:

i)

The General Rules of Subclause 22.6, “Applying bindings to evaluate an expression”,

are applied with GP as GRAPH PATTERN, YCi as EXPRESSION, MACH as MACHINERY, MPB as MULTI-PATH BINDING, and reference to MPB as a subset of itself as REFERENCE

TO LOCAL CONTEXT; let VE be the VALUE returned from the application of those General Rules.

ii)

The field value of Fi is VE.

468

IWD 39075:202y(E)

22.8 Applying bindings to generate a record

3)

Evaluation of the General Rules is terminated and control is returned to the invoking Subclause,

which receives RECORD as RECORD.

Conformance Rules

None.

469





IWD 39075:202y(E)

22.9 Resolving a <simple directory path> from a start directory

22.9 Resolving a <simple directory path> from a start directory

Function

Determine a GQL-directory by resolving a <simple directory path> from a start directory

Subclause Signature

“Resolving a <simple directory path> from a start directory” [Syntax Rules] (

Parameter: “SIMPLE DIRECTORY PATH”,

Parameter: “START DIRECTORY”

) Returns: “RESOLVED DIRECTORY”

« Editorial: Add documentation »

SIMPLE DIRECTORY PATH — a <simple directory path>.

START DIRECTORY — the GQL-directory from which SIMPLE DIRECTORY PATH is to be resolved.

RESOLVED DIRECTORY — the resolved GQL-directory.

— This signature is invoked from Subclause 18.1, “<schema reference> and <catalog schema parent and name>” , SR 5)b)ii)1)

— This signature is invoked from Subclause 18.1, “<schema reference> and <catalog schema parent and name>” , SR 6)d)ii)1)

Syntax Rules

1)

Let SDP be the SIMPLE DIRECTORY PATH and let SD be the START DIRECTORY in an application of the Syntax Rules of this Subclause. The result of the application of this Subclause is returned as

RESOLVED DIRECTORY.

2)

Let DNSEQ be the sequence of all <directory name> s that are immediately contained in SDP, and let n be the number of elements of DNSEQ.

3)

Let D 0 be SD and let DNi, 1 (one) ≤ i ≤ n, be the i-th element of DNSEQ.

4)

The GQL-directory Dj, 1 (one) ≤ j ≤ n, is defined as follows:

a)

GQL-directory Dj-1 shall contain a GQL-directory with name DNj.

b)

For every other GQL-directory OGD contained in Dj-1, if the name by which OGD is identified

in Dj-1 and Dj are visually confusable with each other, then an exception condition is raised:

syntax error or access rule violation — use of visually confusable identifiers (42004).

c)

Dj is the GQL-directory with name DNj contained in GQL-directory Dj-1.

5)

RD is the GQL-directory Dn.

6)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause,

which receives RD as RESOLVED DIRECTORY.

General Rules

None.

470

IWD 39075:202y(E)

22.9 Resolving a <simple directory path> from a start directory

Conformance Rules

None.

471





IWD 39075:202y(E)

22.10 Determination of identical values

22.10 Determination of identical values

Function

Determine whether two values are identical.

Subclause Signature

“Determination of identical values” [General Rules] (

Parameter: “FIRST VALUE”,

Parameter: “SECOND VALUE”

)

« Editorial: Add documentation »

FIRST VALUE — the first of two values for which it is to be determined whether they are identical

values.

SECOND VALUE — the second of two values for which it is to be determined whether they are identical

values.

Syntax Rules

None.

General Rules

1)

Let V1 be the FIRST VALUE and let V2 be the SECOND VALUE in an application of the General Rules of this Subclause.

NOTE 295 — This Subclause is invoked implicitly wherever the word identical is used of two values.

2)

Whether V1 is identical to V2 is determined as follows.

Case:

a)

If V1 and V2 are both the null value, then V1 is identical to V2.

b)

If V1 is the null value and V2 is not the null value, or if V1 is not the null value and V2 is the null value, then V1 is not identical to V2.

« WG3:UTC-082R1 Deleted 1 (one) editor's note »

« WG3:UTC-082R1 Deleted 1 (one) GR »

c)

If V1 and V2 are character strings, then

Case:

« WG3:UTC-082R1 »

i)

If CHARACTER_LENGTH( V2) equals L, and if for all i, 1 (one) ≤ i ≤ L, the i-th character of V1 corresponds to the same Unicode code point as the i-th character of V2, then V1 is

identical to V2.

ii)

Otherwise, V1 is not identical to V2.

« Consequence of WG3:UTC-117 »

472

IWD 39075:202y(E)

22.10 Determination of identical values

d)

If V1 and V2 are zoned times or zoned datetimes, then:

Case:

i)

If V1 and V2 are not distinct and their time zone displacement fields are not distinct,

then V1 is identical to V2.

ii)

Otherwise, V1 is not identical to V2.

e)

If V1 and V2 are records, then:

Case:

i)

If the sets of field types of V1 and V2 have the same cardinality and all respective fields

of V1 and V2 with the same name are identical, then V1 is identical to V2.

ii)

Otherwise, V1 is not identical to V2.

f)

If V1 and V2 are lists, then:

Case:

i)

If V1 and V2 have the same cardinality and elements in the same ordinal position in

the two lists are identical, then V1 is identical to V2.

ii)

Otherwise, V1 is not identical to V2.

g)

If V1 and V2 are not comparable and the GQL-implementation does not support Feature GC02,

“Universal comparison”, then V1 is not identical to V2.

h)

Otherwise, V1 is identical to V2 if and only if V1 is not distinct from V2.

« WG3:UTC-082R1 Deleted 1 (one) GR »

473





IWD 39075:202y(E)

22.11 Determination of distinct values

22.11 Determination of distinct values

Function

Determine whether two values are distinct.

Subclause Signature

“Determination of distinct values” [General Rules] (

Parameter: “FIRST VALUE”,

Parameter: “SECOND VALUE”

)

« Editorial: Add documentation »

FIRST VALUE — the first of two values for which it is to be determined whether they are distinct

values.

SECOND VALUE — the second of two values for which it is to be determined whether they are distinct

values.

Syntax Rules

None.

General Rules

1)

Let V1 be the FIRST VALUE and let V2 be the SECOND VALUE in an application of the General Rules of this Subclause.

NOTE 296 — This Subclause is invoked implicitly wherever the word distinct is used of two values.

2)

Whether V1 is distinct from V2 is determined as follows.

Case:

** Editor’s Note (number 69) **

The way in which material values are determined to be distinct may require further adjustment (as per the discussion

of RKE-048).

a)

If V1 and V2 are both the null value, then V1 is not distinct from V2.

b)

If V1 is the null value and V2 is not the null value, or if V1 is not the null value and V2 is the null value, then V1 is distinct from V2.

« WG3:UTC-015 »

« WG3:UTC-050 »

c)

If V1 and V2 are comparable values of predefined value types but are not reference values,

then

Case:

i)

If V1 is not equal to V2, then V1 is distinct from V2.

ii)

Otherwise, V1 is not distinct from V2.

474

IWD 39075:202y(E)

22.11 Determination of distinct values

« WG3:UTC-015 »

d)

If V1 and V2 are reference values, then

Case:

i)

If V1 and V2 do not refer to the same referent, then V1 is distinct from V2.

ii)

Otherwise, V1 is not distinct from V2.

e)

If V1 and V2 are of constructed types, then

Case:

i)

If V1 and V2 are list values, then

Case:

1)

If V1 and V2 have different cardinality or the elements in the two list values of at

least one ordinal position are distinct, then V1 is distinct from V2.

2)

Otherwise, V1 is not distinct from V2.

ii)

If V1 and V2 are records, then

Case:

1)

If V1 and V2 have different sets of field names or the field values of at least one

of the respective fields of V1 and V2 with the same field name are distinct, then

V1 is distinct from V2.

2)

Otherwise, V1 is not distinct from V2.

« WG3:UTC-015 promoted one subrule »

iii)

If V1 and V2 are path values, then

Case:

1)

If the path element list of V1 is distinct from the path element list of V2, then V1

is distinct from V2.

2)

Otherwise, V1 is not distinct from V2.

iv)

Otherwise, V1 is distinct from V2.

« WG3:UTC-050 »

f)

Otherwise, V1 and V2 are nor comparable and

Case:

i)

If the GQL-implementation supports Feature GC02, “Universal comparison”, then

Case:

1)

If V1 is equal to V2, then V1 is not distinct from V2.

2)

Otherwise, V1 is distinct from V2.

ii)

Otherwise, an exception condition is raised: data exception — values not comparable

(22G04).

NOTE 297 — The circumstances in which this exception will occur are rare since in this document,

most uses of distinct occur in contexts where it already has been established that V1 and V2 are

comparable unless the GQL-implementation supports Feature GC02, “Universal comparison”.

475





IWD 39075:202y(E)

22.12 Equality operations

22.12 Equality operations

Function

Specify the prohibitions and restrictions by value type on operations that involve testing for equality.

Syntax Rules

1)

An equality operation is any of the following:

** Editor’s Note (number 70) **

Consider explicit support for additional collations other than UCS_BASIC and UNICODE (e.g., case insensitive variants,

use of alternative collation tables). See Language Opportunity GQL-012 .

a)

A <comparison predicate> that specifies <equals operator> or <not equals operator>.

b)

A <same predicate>.

c)

An <all_different predicate> .

2)

An operand of an equality operation is any of the following:

a)

A <comparison predicand> that is simply contained in a <comparison predicate> that specifies

<equals operator> or <not equals operator> .

b)

An <element variable reference> that is simply contained in a <same predicate> .

c)

An <element variable reference> that is simply contained in an <all_different predicate>.

General Rules

None.

Conformance Rules

None.

476





IWD 39075:202y(E)

22.13 Ordering operations

22.13 Ordering operations

Function

Specify the prohibitions and restrictions by value type on operations that involve ordering of data.

Syntax Rules

1)

An ordering operation is any of the following:

** Editor’s Note (number 71) **

Consider explicit support for additional collations other than UCS_BASIC and UNICODE (e.g., case insensitive variants,

use of alternative collation tables). See Language Opportunity GQL-012 .

a)

A <comparison predicate> that does not specify <equals operator> or <not equals operator>.

b)

A <sort specification list> .

c)

An <aggregate function> that specifies MAX or MIN.

2)

An operand of an ordering operation is any of the following:

a)

A <comparison predicand> that is simply contained in a <comparison predicate> that does not specify <equals operator> or <not equals operator>.

« Editorial: Correct application »

« WG3:UTC-081 »

b)

A <value expression> that is simply contained in an <aggregate function> that specifies MIN, MAX, PERCENTILE_CONT, or PERCENTILE_DISC.

c)

A <value expression> that is simply contained in a <sort key> .

General Rules

None.

Conformance Rules

None.

477





IWD 39075:202y(E)

22.14 Grouping operations

22.14 Grouping operations

Function

Specify the prohibitions and restrictions by value type on operations that involve grouping of data.

Syntax Rules

1)

A grouping operation is any of the following:

a)

A <group by clause> .

b)

An <aggregate function> that specifies DISTINCT.

c)

A <return statement> that simply contains DISTINCT without an intervening <return item> .

d)

A <select statement> that simply contains DISTINCT without an intervening <select item>.

e)

A <composite query expression> that simply contains or implies UNION DISTINCT.

f)

A <composite query expression> that simply contains EXCEPT.

g)

A <composite query expression> that simply contains INTERSECT.

2)

An operand of a grouping operation is any of the following:

a)

A <binding variable reference> that is simply contained in a <group by clause> .

b)

A <value expression> simply contained in an <aggregate function> that specifies DISTINCT.

c)

A <return item> that is simply contained in a <return statement> that simply contains DISTINCT

without an intervening <return item>.

d)

A <select item> that is simply contained in a <select statement> that simply contains DISTINCT

without an intervening <select item>.

e)

A column of the result of a <composite query expression> that simply contains or implies

UNION DISTINCT.

f)

A column of the result of a <composite query expression> that simply contains EXCEPT.

g)

A column of the result of a <composite query expression> that simply contains INTERSECT.

General Rules

None.

Conformance Rules

None.

478





IWD 39075:202y(E)

22.15 Collation determination

22.15 Collation determination

Function

Specify rules for determining the collation to be used in the comparison of character strings.

Subclause Signature

“Collation determination” [Syntax Rules] () Returns: “COLL”

« Editorial: Add documentation »

COLL — the collation to be used in the comparison of character strings.

— This signature is invoked from Subclause 19.3, “<comparison predicate>”, GR 5)b)

Syntax Rules

1)

The Syntax Rules of this Subclause are applied without any symbolic arguments.The result of the

application of this Subclause is returned as COLL.

2)

COLL is defined as the implementation-defined (ID022) choice of one of the following:

a)

UCS_BASIC.

b)

UNICODE.

c)

An implementation-defined (ID022) custom collation.

3)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause,

which receives COLL as COLL.

General Rules

None.

Conformance Rules

None.

« WG3:UTC-015 »

479





IWD 39075:202y(E)

22.16 Result of value type combinations

22.16 Result of value type combinations

Function

Specify the declared type of the result of certain combinations of values of compatible dynamic and static

value types, such as <case expression>s, or <list value expression> s.

Subclause Signature

“Result of value type combinations” [Syntax Rules] (

Parameter: “DTSET”

) Returns: “RESTYPE”

DTSET — a set of GQL value types.

RESTYPE — a GQL value type that can be used to represent values of all GQL value types contained

in DTSET.

— This signature is invoked from Subclause 4.15, “Value types” , XX 2)b)

— This signature is invoked from Subclause 20.13, “<list value expression>”, SR 2)a)

— This signature is invoked from Subclause 20.15, “<list value constructor>”, SR 3)

— This signature is invoked from Subclause 20.22, “<case expression>” , SR 5)

— This signature is invoked from Subclause 22.17, “Result of static value type combinations” , SR 4)i)ii)

Syntax Rules

1)

Let IDTS be the DTSET in an application of the Syntax Rules of this Subclause. The result of the

application of this Subclause is returned as RESTYPE.

2)

If the conforming GQL-implementation does not support Feature GD13, “Dynamic union types”,

then:

a)

The Syntax Rules of Subclause 22.17, “Result of static value type combinations”, are applied

with IDTS as DTSET; let IRESTYPE be the RESTYPE returned from the application of those Syntax Rules.

b)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause,

which receives IRESTYPE as RESTYPE.

3)

Let NDTS be the set of all static value types contained in IDTS.

4)

Let YDTS be the set of all dynamic value types contained in IDTS.

5)

Let PNDTS be a partition of NDTS, i.e., a family of non-empty disjoint subsets of NDTS such that:

a)

Every subset in PNDTS only contains value types from NDTS that have the same associated

base type or are numeric types.

b)

Every value type in NDTS is contained in exactly one subset of PNDTS.

NOTE 298 — By these rules, PNDTS is well-defined.

6)

Let the set of value types CDTS be well-defined as follows.

a)

For each subset SUBPNDTS of NDTS that is contained in PNDTS

Case:

480

IWD 39075:202y(E)

22.16 Result of value type combinations

i)

If the Syntax Rules of Subclause 22.17, “Result of static value type combinations” , can

be applied successfully with SUBPNDTS as DTSET, then:

1)

The Syntax Rules of Subclause 22.17, “Result of static value type combinations”,

are applied with SUBPNDTS as DTSET; let CRESTYPE be the RESTYPE returned from the application of those Syntax Rules.

2)

CRESTYPE is defined and included in CDTS.

ii)

Otherwise, the value type specified by ANY< SUBPNDTS> is included in CDTS.

NOTE 299 — ANY< SUBPNDTS> is subject to type normalization.

b)

No other value types are included in CDTS.

7)

Let DTR be defined as follows.

Case:

a)

Let FDTS be the non-empty union of YDTS and CDTS.

b)

Let FDTLIST be a <vertical bar> -separated enumeration of <value type> s that specify all value types in FDTS.

c)

DTR is the value type specified by ANY< FDTLIST>.

NOTE 300 — DTR can be either a dynamic union type or a static value type.

NOTE 301 — ANY< FDTLIST> is subject to type normalization.

8)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause,

which receives DTR as RESTYPE.

481





IWD 39075:202y(E)

22.17 Result of static value type combinations

22.17 Result of static value type combinations

Function

Specify the declared type of the result of certain combinations of values of compatible static value types,

such as <case expression>s, or <list value expression>s.

Subclause Signature

“Result of static value type combinations” [Syntax Rules] (

Parameter: “DTSET”

) Returns: “RESTYPE”

« Editorial: Add documentation »

DTSET — a set of GQL value types.

RESTYPE — a GQL value type that can be used to represent values of all GQL value types contained

in DTSET.

— This signature is invoked from Subclause 22.16, “Result of value type combinations”, SR 2)a)

— This signature is invoked from Subclause 22.16, “Result of value type combinations”, SR 6)a)i)1)

Syntax Rules

« WG3:UTC-015 deleted an editor's note »

1)

Let IDTS be the DTSET in an application of the Syntax Rules of this Subclause. The result of the

application of this Subclause is returned as RESTYPE.

« WG3:UTC-129 »

2)

IDTS shall be a non-empty set of static value types.

3)

Let DTS be the set of the nullable variants of all types in IDTS.

4)

Let the value type NDTR be determined as follows.

Case:

a)

If at least one of the value types in DTS is a character string type, then:

i)

Every value type in DTS shall be a character string type.

ii)

There shall be at least one character string type supported by the GQL-implementation

that is a supertype of every value type in DTS.

« WG3:UTC-129 »

iii)

NDTR is a character string type supported by the GQL-implementation that is a super-

type of every value type in DTS. This type is determined using an implementation-

defined (IW019) mechanism.

b)

If at least one of the value types in DTS is a byte string type, then:

i)

Every value type in DTS shall be a byte string type.

ii)

There shall be at least one byte string type supported by the GQL-implementation that

is a supertype of every value type in DTS.

« WG3:UTC-129 »

482

IWD 39075:202y(E)

22.17 Result of static value type combinations

iii)

NDTR is a byte string type supported by the GQL-implementation that is a supertype

of every value type in DTS. This type is determined using an implementation-defined

(IW020) mechanism.

c)

If at least one value type in DTS is numeric, then:

i)

All value types in DTS shall be numeric types.

« WG3:UTC-129 »

ii)

Case:

1)

If at least one value type in DTS is approximate numeric, then NDTR is approximate

numeric with implementation-defined (ID037) precision.

2)

Otherwise, NDTR is exact numeric with implementation-defined (IL016) precision

and with scale equal to the maximum of the scales of the value types in DTS.

d)

If at least one value type in DTS is a zoned datetime or local datetime type, then

Case:

« WG3:UTC-117 required adjustments »

i)

All value types in DTS shall be either zoned datetime or local datetime types.

ii)

If at least one value type in DTS is zoned datetime type, then NDTR is zoned datetime.

iii)

Otherwise, NDTR is local datetime.

« WG3:UTC-117 required adjustments »

e)

If at least one value type in DTS is a zoned time or local time type, then:

Case:

i)

All value types in DTS shall be either zoned time or local time types.

ii)

If at least one value type in DTS is a zoned time type, then NDTR is zoned time.

iii)

Otherwise, NDTR is local time.

f)

If at least one value type in DTS is date type, then all value types in DTS shall be date and NDTR

is date.

g)

If at least one value type in DTS is duration type, then all value types in DTS shall be duration

types and NDTR is duration.

h)

If at least one value type in DTS is a Boolean type, then all value types in DTS shall be Boolean

types and NDTR is the Boolean type.

i)

If at least one value type in DTS is a list value type, then:

i)

All value types in DTS shall be list value types.

ii)

The Syntax Rules of Subclause 22.16, “Result of value type combinations”, are applied

with the set of all list element types of all list value types in DTS as DTSET; let ELT be the RESTYPE returned from the application of those Syntax Rules

« WG3:UTC-123R2 »

iii)

Case:

1)

If all value types in DTS are group list value types, then NDTR is the group list

value type with list element type ELT.

483

IWD 39075:202y(E)

22.17 Result of static value type combinations

2)

Otherwise, NDTR is the regular list value type with list element type ELT.

j)

If at least one value type in DTS is a record type, then:

i)

All value types in DTS shall be a closed record type.

« Editorial: Correct application »

ii)

All record types in DTS shall have the same set of field names.

iii)

Let FNS be the set of all field names of all field types of all record types in DTS.

« WG3:UTC-129 »

iv)

NDTR is the closed record type comprising one field type for every field name FN in

FNS, where the field value type is the value type resulting from the application of this

Subclause to the set of field value types of field types with field name FN in every record

type in DTS.

« WG3:UTC-129 »

k)

If at least one value type in DTS is a reference type, then:

i)

All value types in DTS shall have the same associated base type.

ii)

Let BT be that associated base type.

iii)

There shall be at least one value type supported by the GQL-implementation that is a

supertype of every value type in DTS and whose associated base type is BT.

iv)

NDTR is a value type supported by the GQL-implementation that is a supertype of every

value type in DTS and whose associated base type is BT. This type is determined using

an implementation-defined (IW024).

5)

Let DTR be determined as follows.

Case:

a)

If IDTS only contains material value types, then DTR is the material variant of NDTR.

b)

Otherwise, DTR is NDTR.

6)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause,

which receives DTR as RESTYPE.

General Rules

None.

Conformance Rules

None.

484





IWD 39075:202y(E)

22.18 Static value type set precedence determination

22.18 Static value type set precedence determination

Function

Order a list of static value types by precedence.

Subclause Signature

“Static value type set precedence determination” [Syntax Rules] (

Parameter: “NDTSET”

) Returns: “NDTLIST”

NDTSET — a set of static value types that meet the requirements of some context.

NDTLIST — a list of static value types in order of precedence.

— This signature is invoked from Subclause 4.15, “Value types” , XX 2)

— This signature is invoked from Subclause 4.15, “Value types” , XX 1)a)ii)

— This signature is invoked from Subclause 17.9, “<value type>”, SR 91)h)i)

— This signature is invoked from Subclause 22.1, “Store assignment”, GR 4)b)i)2)

Syntax Rules

1)

Let IDTSET be the NDTSET in an application of the Syntax Rules of this Subclause. The result of the

application of this Subclause is returned as NDTLIST.

2)

The effective binary precision of a numeric type T is defined as follows.

Case:

a)

If the radix of T is decimal, then the effective binary precision is the product of log2(10) and

the precision of T.

b)

Otherwise, the radix of T is binary and the effective binary precision is the precision of T.

3)

The closed record type R corresponding to a set of property types PTSET is defined as follows:

a)

The set of field names of field types of R is the set of property names of property types in

PTSET.

b)

For each field type FT of R whose field name is FN, the field value type of FT is the property value type of the property type in PTSET whose property name is FN.

« WG3:UTC-086R1 »

4)

Let REF( NT) denote the closed node reference value type whose constraining object type is the

node type NT.

5)

Given a set of value types TS, let NTSEQ( TS) denote the result of applying an implementation-defined

(IW021) mechanism for determining a permutation of all value types of TS such that:

a)

NTSEQ( TS) is a permutation of the value types in TS, i.e., is a list of the same cardinality as TS

and contains every value type in TS exactly once.

b)

For each base type BT that is the associated base type of at least one value type in TS, there

is exactly one longest subsequence of NTSEQ( TS) that comprises every value type of BT that

is included in TS.

485

IWD 39075:202y(E)

22.18 Static value type set precedence determination

c)

There is exactly one (possibly empty) longest subsequence of NTSEQ( TS) that comprises every

numeric type that is included in TS.

d)

For each pair of different data types T1 and T2 from TS:

i)

If T1 is closed and T2 is an open value type with the same associated base type as T1,

then T1 precedes T2 in NTSEQ(TS).

ii)

If T1 is material and T2 is nullable, then T1 precedes T2 in NTSEQ( TS).

e)

For each pair of different character string types T1 and T2 from TS, if the maximum length of

T1 is less than the maximum length of T2, then T1 precedes T2 in NTSEQ( TS).

f)

For each pair of different byte string types T1 and T2 from TS:

i)

Let DIFF1 be the difference between the maximum length of T1 and the minimum length

of T1.

ii)

Let DIFF2 be the difference between the maximum length of T2 and the minimum length

of T2.

iii)

If DIFF1 is less than DIFF2, then T1 precedes T2 in NTSEQ( TS).

g)

For each pair of different numeric data types T1 and T2 from TS:

i)

If T1 is exact numeric and T2 is approximate numeric, then T1 precedes T2 in NTSEQ( TS).

ii)

If the effective binary precision of T1 is less than the effective binary precision of T2,

then T1 precedes T2 in NTSEQ( TS).

iii)

If the effective binary precision of T1 is equal to the effective binary precision of T2

and the scale of T1 is less than the scale of T2, then T1 precedes T2 in NTSEQ( TS).

h)

For each pair of different closed list types T1 and T2 from TS:

« WG3:UTC-123R2 »

i)

If T1 is a group list value type and T2 is a regular list value type, then T1 precedes T2

in NTSEQ( TS).

ii)

If the maximum cardinality of T1 is less than the maximum cardinality of T2, then T1

precedes T2 in NTSEQ( TS).

iii)

If the element type E1 of T1 precedes the element type E2 of T2 in NTSEQ({ E1, E2}), then T1 precedes T2 in NTSEQ( TS).

i)

For each pair of different closed record types T1 and T2 from TS:

i)

If the number of field types of T1 is less than the number of field types of T2, then T1

precedes T2 in NTSEQ( TS).

ii)

If T1 and T2 have the same set of field names FNS and for each field name FN in FNS, the field value type FVT1 of the field type with name FN of T1 precedes the field value

type FVT2 of the field type with name FN of T2 in NTSEQ({ FVT1, FVT2}), then T1 precedes T2 in NTSEQ( TS).

« WG3:UTC-086R1 »

j)

For each pair of different closed node reference value types T1 and T2 from TS whose con-

straining object types are the node types O1 and O2, respectively:

i)

If the node type label set of O2 is a proper subset of the node type label set of O1, then

T1 precedes T2 in NTSEQ( TS).

486

IWD 39075:202y(E)

22.18 Static value type set precedence determination

ii)

If the closed record type R1 corresponding to the node type property type set of O1

precedes the closed record type R2 corresponding to the node type property type set

of O2 in NTSEQ({ R1, R2}), then T1 precedes T2 in NTSEQ( TS).

« WG3:UTC-086R1 »

k)

For each pair of different closed edge reference value types T1 and T2 from TS whose con-

straining object types are the edge types O1 and O2, respectively:

i)

If the edge type label set of O2 is a proper subset of the edge type label set of O1, then

T1 precedes T2 in NTSEQ( TS).

ii)

If O1 is directed and O2 is undirected, then T1 precedes T2 in NTSEQ( TS).

iii)

If the closed record type R1 corresponding to the edge type property type set of O1

precedes the closed record type R2 corresponding to the edge type property type set

of O2 in NTSEQ({ R1, R2}), then T1 precedes T2 in NTSEQ( TS).

iv)

Let S1 and D1 be determined as follows.

Case:

1)

If O1 is directed, then S1 is the source node type of O1 and D1 is the destination

node type of O2.

2)

Otherwise, O1 is undirected with endpoint types E1 and E1′ and

Case:

A)

If REF( E1) precedes REF( E1′) in NTSEQ({ REF( E1), REF( E1′)}), then S1 is E1

and D1 is E1′.

B)

Otherwise, S1 is E1′ and D1 is E1.

v)

Let S2 and D2 be determined as follows.

Case:

1)

If O2 is directed, then S2 is the source node type of O2 and D2 is the destination

node type of O2.

2)

Otherwise, O2 is undirected with endpoint types E2 and E2′ and

Case:

A)

If REF( E2) precedes REF( E2′) in NTSEQ({ REF( E2), REF( E2′)}), then S2 is E2

and D2 is E2′.

B)

Otherwise, S2 is E2′ and D2 is E2.

vi)

If REF( S1) precedes REF( S2) in NTSEQ({ REF( S1), REF( S2)}), then T1 precedes T2 in NTSEQ( TS).

vii)

If neither REF( S1) precedes REF( S2) nor REF( S2) precedes REF( S1) in NTSEQ({ REF( S1), REF( S2)}) and REF( D1) precedes REF( D2) in NTSEQ({ REF( D1), REF( D2)}), then T1

precedes T2 in NTSEQ( TS).

l)

For each pair of different binding table reference value types T1 and T2 from TS, if the record

type R1 of T1 precedes the record type R2 of T2 in NTSEQ({ R1, R2}), then T1 precedes T2 in NTSEQ( T1, T2).

487

IWD 39075:202y(E)

22.18 Static value type set precedence determination

m)

For each pair of different closed graph reference value types T1 and T2 from TS whose con-

straining graph types are G1 and G2, if the set of graph element types of G1 is a proper subset

of the set of graph element types of G2, then T1 precedes T2 in NTSEQ( T1, T2).

n)

If T1 precedes T2 in NTSEQ( TS), then for every finite set of types TS′ that contains T1 and T2

it holds that T1 precedes T2 in NTSEQ( TS′).

o)

NTSEQ( TS) is NTSEQ( NTSEQ( TS)).

6)

Evaluation of the Syntax Rules is terminated and control is returned to the invoking Subclause,

which receives NTSEQ(IDTSET) as NDTLIST.

488





IWD 39075:202y(E)

23 GQLSTATUS and diagnostic records

23.1 GQLSTATUS

A character string returned as GQLSTATUS is the concatenation of a 2-character class code followed by

a 3-character subclass code, each restricted to <standard digit> s and <simple Latin upper-case letter>s,

respectively. Table 7, “GQLSTATUS class and subclass codes”, categorizes and specifies the class code for

each condition and the subclass code or codes for each subcondition defined by this document.

Class codes that begin with one of the <standard digit>s '0', '1', '2', '3', or '4' or one of the <simple Latin

upper-case letter> s 'A', 'B', 'C', 'D', 'E', 'F', 'G', or 'H' are returned only for conditions defined in this document or some other International Standard. The range of such class codes is called standard-defined classes.

Some such class codes are reserved for use by specific International Standards, as specified elsewhere

in this Clause. Subclass codes associated with such classes that also begin with one of those 13 characters

are returned only for conditions defined in this document or some other International Standard. The

range of such subclass codes is called standard-defined subclasses. Subclass codes associated with such

classes that begin with one of the <standard digit>s '5', '6', '7', '8', or '9' or one of the <simple Latin upper-

case letter>s 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', or 'Z' are reserved for implementation-defined conditions and are called implementation-defined subclasses.

Class codes that begin with one of the <standard digit>s '5', '6', '7', '8', or '9' or one of the <simple Latin

upper-case letter> s 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', or 'Z' are reserved for implementation-defined exception conditions and are called implementation-defined classes. All subclass

codes except '000', which means no subclass, associated with such classes are reserved for implementation-

defined conditions and are called implementation-defined subclasses. An implementation-defined comple-

tion condition shall be indicated by returning an implementation-defined subclass in conjunction with

one of the classes successful completion (00000), warning (01000), or no data (02000).

If a subclass code is not specified for a condition, then either subclass '000' or an implementation-defined

subclass is returned.

The “Category” column has the following meanings: 'S' means that the class code given corresponds to

a completion condition that indicates successful completion and; 'W' means that the class code given

corresponds to a completion condition that indicates successful completion but with a warning; 'N' means

that the class code given corresponds to a completion condition that indicates a no-data situation; 'X'

means that the class code given corresponds to an exception condition.

Table 7 — GQLSTATUS class and subclass codes

Category

Condition

Class

Subcondition

Subclass

S

successful completion

00

( no subclass)

000

W

warning

01

( no subclass)

000

string data, right truncation

004

graph does not exist

G03

graph type does not exist

G04

N

no data

02

( no subclass)

000

489

IWD 39075:202y(E)

23.1 GQLSTATUS

Category

Condition

Class

Subcondition

Subclass

X

connection exception

08

( no subclass)

000

transaction resolution unknown

007

X

data exception

22

( no subclass)

000

string data, right truncation

001

numeric value out of range

003

null value not allowed

004

invalid datetime format

007

datetime field overflow

008

division by zero

012

interval field overflow

015

invalid character value for cast

018

invalid argument for natural

01E

logarithm

invalid argument for power

01F

function

trim error

027

array data, right truncation

02F

negative limit value

G02

invalid value type

G03

values not comparable

G04

invalid datetime function field

G05

name

invalid datetime function value

G06

invalid duration function field

G07

name

list data, right truncation

G0B

list element error

G0C

invalid number of paths or

G0F

groups

invalid duration format

G0H

490

IWD 39075:202y(E)

23.1 GQLSTATUS

Category

Condition

Class

Subcondition

Subclass

multiple assignments to a graph

G0M

element property

number of node labels below

G0N

supported minimum

number of node labels exceeds

G0P

supported maximum

number of edge labels below

G0Q

supported minimum

number of edge labels exceeds

G0R

supported maximum

number of node properties

G0S

exceeds supported maximum

number of edge properties

G0T

exceeds supported maximum

record fields do not match

G0U

reference value, invalid base type

G0V

reference value, invalid con-

G0W

strained type

record data, field unassignable

G0X

record data, field missing

G0Y

malformed path

G0Z

path data, right truncation

G10

reference value, referent deleted

G11

invalid value type

G12

invalid group variable value

G13

incompatible temporal instant

G14

unit groups

X

invalid transaction state

25

( no subclass)

000

active GQL-transaction

G01

catalog and data statement mix-

G02

ing not supported

read-only transaction

G03

491

IWD 39075:202y(E)

23.1 GQLSTATUS

Category

Condition

Class

Subcondition

Subclass

accessing multiple graphs not

G04

supported

X

invalid transaction termination

2D

( no subclass)

000

X

transaction rollback

40

( no subclass)

000

integrity constraint violation

002

statement completion unknown

003

X

syntax error or access rule viola-

42

( no subclass)

000

tion

invalid syntax

001

invalid reference

002

cannot drop the current working

003

schema

use of visually confusable identifi-

004

ers

endpoint node type not defined

005

in graph type definition

number of edge labels below

006

supported minimum

number of edge labels exceeds

007

supported maximum

number of edge properties

008

exceeds supported maximum

number of node labels below

009

supported minimum

number of node labels exceeds

010

supported maximum

number of node properties

011

exceeds supported maximum

X

dependent object error

G1

( no subclass)

000

edges still exist

001

492





IWD 39075:202y(E)

23.1 GQLSTATUS

Category

Condition

Class

Subcondition

Subclass

X

graph type violation

G2

( no subclass)

000

23.2 Diagnostic records

Function

Define a record with diagnostic information.

General Rules

1)

When a completion condition is raised an empty record, DIAGNOSTICS, is created.

2)

When an exception condition is raised the following record, DIAGNOSTICS, is created:

RECORD {

COMMAND_FUNCTION: CF,

COMMAND_FUNCTION_CODE: CFC,

NUMBER: N,

CURRENT_SCHEMA: CS,

HOME_GRAPH: HG,

CURRENT_GRAPH: CG

}

where:

a)

CF is a string identifying the command executed. Table 8, “Command codes” , specifies the

identifier of the commands.

b)

CFC is an integer identifying the code of the GQL-statement executed. Table 8, “Command

codes” , identifies the code of the commands. Positive values are reserved for commands

defined by this document. Negative values are reserved for implementation-defined commands.

c)

N is the number of nested GQL-status objects contained in the (parent) GQL-status object of

DIAGNOSTICS.

« WG3:UTC-096R1 »

d)

Case:

i)

If a current working schema CWS is available at the innermost non-terminal instance

whose rules raise the exception condition for which DIAGNOSTICS is created, then CS

is a character string in the character repertoire of GQL source text that conforms to the

Format of <absolute catalog schema reference> and that identifies CWS

ii)

Otherwise, the null value.

e)

HG is the graph reference value of HOME_GRAPH.

f)

CG is the graph reference value of CURRENT_GRAPH.

g)

If the GQLSTATUS corresponds to syntax error or access rule violation — invalid reference

(42002), then the following field is added to DIAGNOSTICS:

INVALID_REFERENCE: R

where R is the identifier of the reference that caused the exception condition to be raised.

493

IWD 39075:202y(E)

23.2 Diagnostic records

Table 8 — Command codes

Command

Identifier

Code

<session set schema clause>

SESSION SET SCHEMA

1 (one)

<session set graph clause>

SESSION SET GRAPH

2

<session set time zone clause>

SESSION SET TIME ZONE

3

<session set parameter clause>

SESSION SET PARAMETER

4

« WG3:UTC-045R1 implicitly deleted one row »

<session close command>

SESSION CLOSE

6

« WG3:UTC-045R1 implicitly deleted one row »

« WG3:UTC-045R1 »

<session close command>

SESSION RESET

7

<start transaction command>

START TRANSACTION

8

<rollback command>

ROLLBACK

9

<commit command>

COMMIT

10

<create graph statement>

CREATE GRAPH STATEMENT

11

<create graph type statement>

CREATE GRAPH TYPE STATEMENT

12

<create schema statement>

CREATE SCHEMA STATEMENT

13

<drop graph statement>

DROP GRAPH STATEMENT

18

<drop graph type statement>

DROP GRAPH TYPE STATEMENT

19

<drop schema statement>

DROP SCHEMA STATEMENT

20

<match statement>

MATCH STATEMENT

26

<call query statement>

CALL QUERY STATEMENT

27

<call procedure statement>

CALL PROCEDURE STATEMENT

28

<insert statement>

INSERT STATEMENT

30

<set statement>

SET STATEMENT

32

<remove statement>

REMOVE STATEMENT

33

<delete statement>

DELETE STATEMENT

34

<let statement>

LET STATEMENT

37

<for statement>

FOR STATEMENT

38

494

IWD 39075:202y(E)

23.2 Diagnostic records

Command

Identifier

Code

<filter statement>

FILTER STATEMENT

40

<order by and page statement>

ORDER BY AND PAGE STATEMENT

41

<return statement>

RETURN STATEMENT

42

« WG3:UTC-064 »

<select statement>

SELECT STATEMENT

43

Implementation-defined statements

An implementation-defined character x1

string value different from the value

associated with any other command

Unrecognized statements

A zero-length character string

0 (zero)

1 An implementation-defined negative number different from the value associated with any other statement in the GQL

language.

495





IWD 39075:202y(E)

24 Conformance

24.1 Introduction to conformance

Conformance may be claimed by a GQL-program or a GQL-implementation.

24.2 Minimum conformance

Minimum conformance is defined as meeting the requirements of the data model and all syntax and

semantics not explicitly identified as belonging to an optional feature.

A claim of minimum conformance shall also include:

1)

A claim of conformance to at least one of:

a)

Feature GA00, “Graph with an open graph type”

b)

Feature GA01, “Graph with a closed graph type”

2)

A claim of conformance to a specific version of The Unicode® Standard and the synchronous versions

of Unicode Technical Standard #10, Unicode Standard Annex #15, and Unicode Standard Annex

#31. The claimed version of The Unicode® Standard shall not be less than “13.0.0”.

3)

A claim of conformance to the set of all value types that are supported as the types of property

values. At minimum, this set shall include:

—

The character string type specified by STRING or VARCHAR.

—

The Boolean type specified by BOOLEAN or BOOL.

—

The signed regular integer type specified by SIGNED INTEGER, INTEGER, or INT.

« WG3:UTC-065 »

—

The approximate numeric type specified by FLOAT.

NOTE 302 — See Subclause 4.15.3, “Predefined value types” for the definitions of these data types.

24.3 Conformance to features

In addition to the data model, syntax and semantics that are mandatory for minimum conformance to

this document this document defines optional features. These features are identified by Feature ID and

are controlled by explicit or implicit Conformance Rules (see Subclause 5.3.7, “Feature ID and Feature

Name” ).

An optional feature FEAT is defined by relaxing selected Conformance Rules, as noted at the beginning

of each Conformance Rule by the phrase “without Feature FEAT, “name of feature”, ... ”. An application

designates a set of GQL features that the application requires; the GQL language of the application shall

observe the restrictions of all Conformance Rules except those explicitly relaxed for the required features.

Conversely, conforming GQL-implementations shall identify which GQL features the GQL-implementation

supports. A GQL-implementation shall process any application whose required features are a subset of

the GQL-implementations supported features.

A feature FEAT1 may imply another feature FEAT2. A GQL-implementation that claims to support FEAT1

shall also support each feature FEAT2 implied by FEAT1. Conversely, an application need only designate

that it requires FEAT1, and can assume that this includes each feature FEAT2 implied by FEAT1. The list 496

IWD 39075:202y(E)

24.3 Conformance to features

of features that are implied by other features is shown in Table 9, “Implied feature relationships”. Note

that some features imply multiple other features.

The Syntax Rules and General Rules may define one GQL syntax in terms of another. Such transformations

are presented to define the semantics of the transformed syntax and are effectively performed after

checking the applicable Conformance Rules, unless otherwise noted in a Syntax Rule that defines a

transformation. Transformations may use GQL syntax of one GQL feature to define another GQL feature.

These transformations serve to define the behavior of the syntax, and do not have any implications for

the feature syntax that is permitted or forbidden by the features so defined, except as otherwise noted

in a Syntax Rule that defines a transformation. A conforming GQL-implementation need only process the

untransformed syntax defined by the Conformance Rules that are applicable for the set of features that

the GQL-implementation claims to support, though with the semantics implied by the transformation.

« WG3:UTC-101 »

If a claim of conformance is made to Feature GB43, “Approximate number in common notation or as

decimal integer with suffix”, Feature GB44, “Approximate number in scientific notation with suffix”,

Feature GB45, “Optional float number suffix”, or Feature GB43, “Approximate number in common notation

or as decimal integer with suffix”, then a claim of conformance to at least one of the following shall also

be made:

1)

Feature GB24, “128 bit floats”

2)

Feature GB25, “256 bit floats”

3)

Feature GB63, “16 bit floats”

4)

Feature GB64, “32 bit floats”

5)

Feature GB65, “64 bit floats”

6)

Feature GB66, “Float synonyms”

7)

Feature GB68, “Decimal numeric”

If a claim of conformance is made to Feature GB47, “Exact number in common notation without suffix”,

Feature GB48, “Exact number in common notation or as decimal integer with suffix”, or Feature GB49,

“Exact number in scientific notation with suffix”, then a claim of conformance to at least one of the following

shall also be made:

1)

Feature GB20, “128 bit signed integers”

2)

Feature GB21, “256 bit signed integers”

3)

Feature GB22, “128 bit unsigned integers”

4)

Feature GB23, “256 bit unsigned integers”

5)

Feature GB51, “8 bit signed integers”

6)

Feature GB52, “16 bit signed integers”

7)

Feature GB53, “32 bit signed integers”

8)

Feature GB54, “64 bit signed integers”

9)

Feature GB55, “8 bit unsigned integers”

10) Feature GB56, “16 bit unsigned integers”

11) Feature GB57, “32 bit unsigned integers”

12) Feature GB58, “64 bit unsigned integers”

497





IWD 39075:202y(E)

24.3 Conformance to features

13) Feature GB59, “Small unsigned integers”

14) Feature GB60, “Regular unsigned integers”

15) Feature GB61, “Big unsigned integers”

If a claim of conformance is made to Feature GD03, “Record types”, then a claim of conformance to at

least one of the following shall also be made:

1)

Feature GD04, “Closed record types”

2)

Feature GD05, “Open record types”

« WG3:UTC-015 »

If a claim of conformance is made to Feature GD13, “Dynamic union types”, then a claim of conformance

to at least one of the following shall also be made:

1)

Feature GD10, “Open dynamic union types”

2)

Feature GD11, “Closed dynamic union types”

If a claim of conformance is made to Feature GE01, “Inline procedure”, then a claim of conformance to at

least one of the following shall also be made:

1)

Feature GE02, “Inline procedure with implicit nested variable scope”

2)

Feature GE03, “Inline procedure with explicit nested variable scope”

24.4 Requirements for GQL-programs

24.4.1

Introduction to requirements for GQL-programs

A conforming GQL-program shall be processed without syntax error by a conforming GQL-implementation

if all of the following are satisfied:

—

Every command or procedure invoked by the GQL-program is syntactically correct in accordance

with this document.

—

The GQL-implementation claims conformance to all the optional features to which the GQL-program

claims conformance.

—

The graph or graphs being processed are conforming and the conformance claims of these graphs

do not include any features not included in the GQL-program’s claim of conformance.

A conforming GQL application shall not use any additional features beyond the level of conformance

claimed.

24.4.2

Claims of conformance for GQL-programs

A claim of conformance by a GQL-program to this document shall include all of the following:

—

A claim of minimum conformance.

—

Zero or more additional claims of conformance to optional features.

—

A list of the implementation-defined elements and actions that are relied on for correct performance

498





IWD 39075:202y(E)

24.5 Requirements for GQL-implementations

24.5 Requirements for GQL-implementations

24.5.1

Introduction to requirements for GQL-implementations

A conforming GQL-implementation shall correctly translate and execute all GQL-programs conforming

to both the GQL language and the implementation-defined features of the GQL-implementation.

A conforming GQL-implementation shall reject all GQL-programs that contain errors whose detection is

required by this document.

A conforming GQL-implementation that provides optional features or that provides facilities beyond

those specified in this document shall provide a GQL Flagger (See Subclause 24.6, “GQL Flagger” .)

24.5.2

Claims of conformance for GQL-implementations

A claim of conformance by a GQL-implementation to this document shall include all of the following:

1)

A claim of minimum conformance.

2)

Zero or more additional claims of conformance to optional features.

3)

The definition for every element and action, within the scope of the claim, that this document specifies

to be implementation-defined.

24.5.3

Extensions and options

A GQL-implementation may provide implementation-defined features that are additional to those specified

by this document, and may add to the list of reserved words.

« WG3:UTC-009 P00-USA-169 »

« Editorial: Align with Directives Part 2 »

NOTE 303 — If additional words are reserved, then it is possible that a conforming statement will be processed incorrectly.

A GQL-implementation may provide user options to process non-conforming statements. A GQL-imple-

mentation may provide user options to process statements so as to produce a result different from that

specified in this document.

It shall produce such results only when explicitly required by the user option.

It is implementation-defined (IA012) whether a GQL Flagger flags implementation-defined features.

« Editorial: Align with Directives Part 2 »

NOTE 304 — A GQL Flagger can flag implementation-defined features using any Feature ID not defined by this document.

However, there is no guarantee that some future edition of this document will not use such a Feature ID for a standard-

defined feature.

NOTE 305 — The implementation-defined features flagged by a GQL Flagger can include implementation-defined features

from more than one GQL-implementation.

NOTE 306 — The allocation of a Feature ID to an implementation-defined feature possibly differ between GQL Flaggers.

24.6 GQL Flagger

A GQL Flagger is a facility provided by a GQL-implementation that is able to identify GQL language

extensions, or other GQL processing alternatives, that may be provided by a conforming GQL-implement-

ation (see Subclause 24.5.3, “Extensions and options” ).

A GQL Flagger is intended to assist in the production of GQL language that is both portable and interop-

erable among different conforming GQL-implementations operating under different levels of this document.

A GQL Flagger is intended to effect a static check of GQL language. There is no requirement to detect

extensions that cannot be determined until the General Rules are applied.

499





IWD 39075:202y(E)

24.6 GQL Flagger

A GQL-implementation need only flag GQL language that is not otherwise in error as far as that GQL-

implementation is concerned.

« Editorial: Align with Directives Part 2 »

NOTE 307 — If a system is processing GQL language that contains errors, then it can be very difficult within a single statement to determine what is an error and what is an extension. As one possibility, a GQL-implementation is able to check GQL

language in two steps; first through its normal syntax analyzer and secondly through the GQL Flagger. The first step produces

error messages for non-standard GQL language that the GQL-implementation cannot process or recognize. The second step

processes GQL language that contains no errors as far as that GQL-implementation is concerned; it detects and flags at one

time all non-standard GQL language that could be processed by that GQL-implementation. Preferably, any such two-step

process will be transparent to the end user.

The GQL Flagger assists identification of conforming GQL language that can perform differently in

alternative processing environments provided by a conforming GQL-implementation. It also provides a

tool in identifying GQL elements that may have to be modified if GQL language is moved from a non-

conforming to a conforming GQL processing environment.

24.7 Implied feature relationships

The following table lists those features that imply one or more other features.

Table 9 — Implied feature relationships

Feature

Feature Name

Implied

Implied Feature Name

ID

Feature

ID

G031

Path multiset alternation: variable

G030

Path multiset alternation

length path operands

G033

Path pattern union: variable length G032

Path pattern union

path operands

G039

Simplified path pattern expression: G080

Simplified path pattern expression:

full defaulting

basic defaulting

G041

Non-local element pattern predic-

G051

Parenthesized path pattern: non-local

ates

predicates

G045

Complete abbreviated edge pat-

G044

Basic abbreviated edge patterns

terns

G048

Parenthesized path pattern: sub-

G038

Parenthesized path pattern expres-

path variable declaration

sion

G049

Parenthesized path pattern: path

G038

Parenthesized path pattern expres-

mode prefix

sion

G050

Parenthesized path pattern:

G038

Parenthesized path pattern expres-

WHERE clause

sion

G051

Parenthesized path pattern: non-

G050

Parenthesized path pattern: WHERE

local predicates

clause

G061

Unbounded graph pattern quantifi- G060

Bounded graph pattern quantifiers

ers

500

IWD 39075:202y(E)

24.7 Implied feature relationships

Feature

Feature Name

Implied

Implied Feature Name

ID

Feature

ID

G081

Simplified path pattern expression: G082

Simplified path pattern expression:

full overrides

basic overrides

G082

Simplified path pattern expression: G080

Simplified path pattern expression:

basic overrides

basic defaulting

« WG3:UTC-052 »

GA00

Graph with an open graph type

GM04

Graph management

GA01

Graph with a closed graph type

GM04

Graph management

GA02

Graph Type inline specification

GA01

Graph with a closed graph type

GA03

Graph Type like a graph

GA01

Graph with a closed graph type

« WG3:UTC-052 »

GA04

Graph from a source

GM04

Graph management

« Editorial: Correct application »

GB31

Path value construction

GD06

Path value types

« WG3:UTC-039R1 »

GB34

Graph variables

GB33

Binding variable definition block

GB34

Graph variables

GD07

Graph reference value types

GB36

Graph parameters

GD07

Graph reference value types

GB35

Binding table variables

GB33

Binding variable definition block

GB35

Binding table variables

GD08

Binding table reference value types

GB37

Binding table parameters

GD08

Binding table reference value types

« WG3:UTC-047 »

GC00

Multiple graphs in a GQL-transac-

GE06

Use Graph Support

tion

« WG3:UTC-060 »

GC04

FOR statement: WITH ORDINALITY GC03

FOR statement

and WITH OFFSET

GC15

Composite query: EXCEPT ALL

GC14

Composite query: EXCEPT DISTINCT

GC17

Composite query: INTERSECT ALL

GC16

Composite query: INTERSECT DIS-

TINCT

« WG3:UTC-117 »

GC24

Durations and temporal arithmetic GC23

Date and time support

support

501

IWD 39075:202y(E)

24.7 Implied feature relationships

Feature

Feature Name

Implied

Implied Feature Name

ID

Feature

ID

« WG3:UTC-116 »

GC26

Updatable graphs

GS15

Explicit transactions

GD01

Nested record types

GD03

Record types

GD04

Closed record types

GD03

Record types

GD05

Open record types

GD03

Record types

« WG3:UTC-015 »

GD10

Open dynamic union types

GD13

Dynamic union types

GD11

Closed dynamic union types

GD13

Dynamic union types

GE02

Inline procedure with implicit nes- GE01

Inline procedure

ted variable scope

GE03

Inline procedure with explicit nes-

GE01

Inline procedure

ted variable scope

GF04

Enhanced path functions

GD06

Path value types

« WG3:UTC-058R3 »

GM02

Graph schema management exists

GM01

Graph schema management

GM03

Graph type exists

GA01

Graph with a closed graph type

GM05

Graph management exists

GM04

Graph management

« WG3:UTC-045R1 (implicit) »

GS04

Session: reset all characteristics

GS05

Session: reset schema

GS04

Session: reset all characteristics

GS06

Session: reset property graph

GS04

Session: reset all characteristics

GS07

Session: reset timezone

GS04

Session: reset all characteristics

GS08

Session: reset all parameters

« WG3:UTC-100 »

GS09

Session-local graph parameters

GS12

Session-local graph parameters

based on subqueries

based on simple expressions or refer-

ences

GS10

Session-local binding table paramet- GS13

Session-local binding table paramet-

ers based on subqueries

ers based on simple expressions or

references

GS11

Session-local value parameters

GS14

Session-local value parameters based

based on subqueries

on simple expressions

502

IWD 39075:202y(E)

24.7 Implied feature relationships

Feature

Feature Name

Implied

Implied Feature Name

ID

Feature

ID

GS09

Session-local graph parameters

GS01

Session-local graph parameters

based on subqueries

GS10

Session-local binding table paramet- GS02

Session-local binding table paramet-

ers based on subqueries

ers

GS11

Session-local value parameters

GS03

Session-local value parameters

based on subqueries

« WG3:UTC-048R1 Deleted 1 (one) Subclause »

503





IWD 39075:202y(E)

Annex A

(informative)

GQL conformance summary

« UTC-013 P02-ISO-020 »

The contents of this Annex summarizes all the Conformance Rules.

Most optional Features of this document are specified by Conformance Rules in Subclauses, however

some are specified by implicit Conformance Rules in other text. These are summarized first.

** Editor’s Note (number 72) **

The following list is not complete. Either the new fully automated generation mechanism must be implemented or this list

must be completed/corrected before the document goes out to ballot.

1)

Specifications for Feature GA07, “Undirected edge patterns”.

a)

Subclause 4.3.4.1, “Introduction to graphs”.

i)

Without Feature GA07, “Undirected edge patterns”, a conforming graph shall not contain

undirected edges.

« A consequence of WG3:W24-027 deleted two features »

« WG3:UTC-063 »

2)

Specifications for Feature GB50, “IEEE 754 floating point operations”.

a)

Subclause 4.15.3.5.5, “Approximate numeric types” .

i)

If a GQL-implementation supports the Feature GB50, “IEEE 754 floating point opera-

tions”, <numeric value expression>s on approximate numeric types that would other-

wise result in exceptions may return additional values as defined by IEEE Std 754:2019.

b)

Subclause 20.4, “<numeric value expression>” .

i)

If a GQL-implementation supports the Feature GB50, “IEEE 754 floating point opera-

tions”, then the result of a division by zero may return additional values as defined by

IEEE Std 754:2019 instead of causing an exception condition to be raised.

ii)

If a GQL-implementation supports the Feature GB50, “IEEE 754 floating point opera-

tions”, then a mathematical result of an operation that is not within the exponent range

for the declared type of the result may return additional values as defined by IEEE Std

754:2019 instead of causing an exception condition to be raised.

« WG3:UTC-047 »

3)

Specifications for Feature GC00, “Multiple graphs in a GQL-transaction”.

a)

Subclause 9.1, “<procedure specification>”.

i)

Without Feature GC00, “Multiple graphs in a GQL-transaction”, a GQL-transaction shall

not contain two <use graph clause>s that have different <graph expression> s.

4)

Specifications for Feature GC01, “Catalog and data statement mixing”.

504

IWD 39075:202y(E)

A GQL conformance summary

a)

Subclause 9.1, “<procedure specification>”.

i)

Without Feature GC01, “Catalog and data statement mixing”, a GQL-transaction shall

not contain both a <data-modifying procedure specification> and a <catalog-modifying

procedure specification>.

The remainder of this Annex recapitulates the Conformance Rules specified in Subclauses throughout

this document, organized by feature name and Subclause.

1)

Specifications for Feature G002, “Different-edges match mode”:

a)

Subclause 16.8, “<graph pattern>” :

i)

Without Feature G002, “Different-edges match mode”, conforming GQL language shall

not contain a <different edges match mode>.

2)

Specifications for Feature G003, “Explicit REPEATABLE ELEMENTS keyword”:

a)

Subclause 16.8, “<graph pattern>” :

i)

Without Feature G003, “Explicit REPEATABLE ELEMENTS keyword”, conforming GQL

language shall not contain a <match mode> that specifies REPEATABLE ELEMENTS or

REPEATABLE ELEMENT BINDINGS.

3)

Specifications for Feature G004, “Path variables”:

a)

Subclause 16.8, “<graph pattern>” :

i)

Without Feature G004, “Path variables”, conforming GQL language shall not contain a

<path pattern> that simply contains a <path variable declaration> .

4)

Specifications for Feature G005, “Path search prefix in a path pattern”:

a)

Subclause 16.8, “<graph pattern>” :

i)

Without Feature G005, “Path search prefix in a path pattern”, conforming GQL language

shall not contain a <path pattern> that simply contains a <path pattern prefix> that is a <path search prefix>.

5)

Specifications for Feature G006, “Graph pattern KEEP clause: path mode prefix”:

a)

Subclause 16.8, “<graph pattern>” :

i)

Without Feature G006, “Graph pattern KEEP clause: path mode prefix”, conforming

GQL language shall not contain a <keep clause> that simply contains a <path mode

prefix> .

6)

Specifications for Feature G007, “Graph pattern KEEP clause: path search prefix”:

a)

Subclause 16.8, “<graph pattern>” :

i)

Without Feature G007, “Graph pattern KEEP clause: path search prefix”, conforming

GQL language shall not contain a <keep clause> that simply contains a <path search

prefix> .

7)

Specifications for Feature G010, “Explicit WALK keyword”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G010, “Explicit WALK keyword”, conforming GQL language shall not

contain a <path mode> that specifies WALK.

8)

Specifications for Feature G011, “Advanced path modes: TRAIL”:

505

IWD 39075:202y(E)

A GQL conformance summary

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G011, “Advanced path modes: TRAIL”, conforming GQL language shall

not contain a <path mode> that specifies TRAIL.

9)

Specifications for Feature G012, “Advanced path modes: SIMPLE”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G012, “Advanced path modes: SIMPLE”, conforming GQL language

shall not contain a <path mode> that specifies SIMPLE.

10) Specifications for Feature G013, “Advanced path modes: ACYCLIC”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G013, “Advanced path modes: ACYCLIC”, conforming GQL language

shall not contain a <path mode> that specifies ACYCLIC.

11) Specifications for Feature G014, “Explicit PATH/PATHS keywords”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G014, “Explicit PATH/PATHS keywords”, conforming GQL language

shall not contain a <path or paths>.

12) Specifications for Feature G015, “All path search: explicit ALL keyword”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G015, “All path search: explicit ALL keyword”, conforming GQL lan-

guage shall not contain an <all path search>.

13) Specifications for Feature G016, “Any path search”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G016, “Any path search”, conforming GQL language shall not contain

an <any path search>.

14) Specifications for Feature G017, “All shortest path search”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G017, “All shortest path search”, conforming GQL language shall not

contain <all shortest path search> .

15) Specifications for Feature G018, “Any shortest path search”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G018, “Any shortest path search”, conforming GQL language shall not

contain an <any shortest path search> .

16) Specifications for Feature G019, “Counted shortest path search”:

a)

Subclause 16.9, “<path pattern prefix>” :

i)

Without Feature G019, “Counted shortest path search”, conforming GQL language shall

not contain a <counted shortest path search> .

17) Specifications for Feature G020, “Counted shortest group search”:

a)

Subclause 16.9, “<path pattern prefix>” :

506

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature G020, “Counted shortest group search”, conforming GQL language

shall not contain a <counted shortest group search>.

18) Specifications for Feature G030, “Path multiset alternation”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G030, “Path multiset alternation”, conforming GQL language shall not

contain a <path multiset alternation>.

19) Specifications for Feature G031, “Path multiset alternation: variable length path operands”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G031, “Path multiset alternation: variable length path operands”, in

conforming GQL language, an operand of a <path multiset alternation> shall be a fixed

length path pattern.

20) Specifications for Feature G032, “Path pattern union”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G032, “Path pattern union”, conforming GQL language shall not contain

a <path pattern union> .

21) Specifications for Feature G033, “Path pattern union: variable length path operands”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G033, “Path pattern union: variable length path operands”, in conform-

ing GQL language, an operand of a <path pattern union> shall be a fixed length path

pattern.

22) Specifications for Feature G035, “Quantified paths”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G035, “Quantified paths”, conforming GQL language shall not contain

a <quantified path primary> that does not immediately contain a <path primary> that is an <edge pattern>.

23) Specifications for Feature G036, “Quantified edges”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G036, “Quantified edges”, conforming GQL language shall not contain

a <quantified path primary> that immediately contains a <path primary> that is an

<edge pattern>.

24) Specifications for Feature G037, “Questioned paths”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G037, “Questioned paths”, conforming GQL language shall not contain

a <questioned path primary> .

25) Specifications for Feature G038, “Parenthesized path pattern expression”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G038, “Parenthesized path pattern expression”, conforming GQL lan-

guage shall not contain a <parenthesized path pattern expression>.

26) Specifications for Feature G039, “Simplified path pattern expression: full defaulting”:

507

IWD 39075:202y(E)

A GQL conformance summary

a)

Subclause 16.14, “<simplified path pattern expression>” :

i)

Without Feature G039, “Simplified path pattern expression: full defaulting”, conforming

GQL language shall not contain a <simplified path pattern expression> that is not a

<simplified defaulting left> , a <simplified defaulting right>, or a <simplified defaulting

any direction>.

27) Specifications for Feature G041, “Non-local element pattern predicates”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G041, “Non-local element pattern predicates”, in conforming GQL

language, the <element pattern where clause> of an <element pattern> EP shall only reference the <element variable> declared in EP.

28) Specifications for Feature G043, “Complete full edge patterns”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G043, “Complete full edge patterns”, conforming GQL language shall

not contain a <full edge pattern> that is not a <full edge any direction> , a <full edge

pointing left> , or a <full edge pointing right>.

29) Specifications for Feature G044, “Basic abbreviated edge patterns”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G044, “Basic abbreviated edge patterns”, conforming GQL language

shall not contain an <abbreviated edge pattern> that is a <minus sign> , <left arrow> , or <right arrow> .

30) Specifications for Feature G045, “Complete abbreviated edge patterns”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G045, “Complete abbreviated edge patterns”, conforming GQL language

shall not contain an <abbreviated edge pattern> that is not a <minus sign> , <left arrow>,

or <right arrow> .

31) Specifications for Feature G046, “Relaxed topological consistency: adjacent vertex patterns”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G046, “Relaxed topological consistency: adjacent vertex patterns”, in

conforming GQL language, between any two <node pattern> s contained in a <path

pattern expression> there shall be at least one <edge pattern>, <left paren> , or <right

paren> .

32) Specifications for Feature G047, “Relaxed topological consistency: concise edge patterns”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G047, “Relaxed topological consistency: concise edge patterns”, in

conforming GQL language, any <edge pattern> shall be immediately preceded and fol-

lowed by a <node pattern> .

33) Specifications for Feature G048, “Parenthesized path pattern: subpath variable declaration”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G048, “Parenthesized path pattern: subpath variable declaration”,

conforming GQL language shall not contain a <parenthesized path pattern expression>

that simply contains a <subpath variable declaration>.

508

IWD 39075:202y(E)

A GQL conformance summary

34) Specifications for Feature G049, “Parenthesized path pattern: path mode prefix”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G049, “Parenthesized path pattern: path mode prefix”, conforming

GQL language shall not contain a <parenthesized path pattern expression> that

immediately contains a <path mode prefix>.

35) Specifications for Feature G050, “Parenthesized path pattern: WHERE clause”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G050, “Parenthesized path pattern: WHERE clause”, conforming GQL

language shall not contain a <parenthesized path pattern where clause> .

36) Specifications for Feature G051, “Parenthesized path pattern: non-local predicates”:

a)

Subclause 16.10, “<path pattern expression>” :

i)

Without Feature G051, “Parenthesized path pattern: non-local predicates”, in conforming

GQL language, a <parenthesized path pattern where clause> simply contained in a

<parenthesized path pattern expression> PPPE shall not reference an <element variable>

that is not declared in PPPE.

37) Specifications for Feature G060, “Bounded graph pattern quantifiers”:

a)

Subclause 16.13, “<graph pattern quantifier>”:

i)

Without Feature G060, “Bounded graph pattern quantifiers”, conforming GQL language

shall not contain a <fixed quantifier> or a <general quantifier> that immediately contains an <upper bound> .

38) Specifications for Feature G061, “Unbounded graph pattern quantifiers”:

a)

Subclause 16.13, “<graph pattern quantifier>”:

i)

Without Feature G061, “Unbounded graph pattern quantifiers”, conforming GQL lan-

guage shall not contain a <graph pattern quantifier> that immediately contains

<asterisk>, <plus sign>, or a <general quantifier> that does not immediately contain an <upper bound> .

39) Specifications for Feature G074, “Label expression: wildcard label”:

a)

Subclause 16.12, “<label expression>” :

i)

Without Feature G074, “Label expression: wildcard label”, conforming GQL language

shall not contain a <wildcard label>.

40) Specifications for Feature G080, “Simplified path pattern expression: basic defaulting”:

a)

Subclause 16.14, “<simplified path pattern expression>” :

i)

Without Feature G080, “Simplified path pattern expression: basic defaulting”, conform-

ing GQL language shall not contain a <simplified defaulting left>, a <simplified

defaulting right>, or a <simplified defaulting any direction> .

41) Specifications for Feature G081, “Simplified path pattern expression: full overrides”:

a)

Subclause 16.14, “<simplified path pattern expression>” :

i)

Without Feature G081, “Simplified path pattern expression: full overrides”, conforming

GQL language shall not contain a <simplified direction override> that is not a <simplified

override left>, <simplified override right>, or a <simplified override any direction>.

509

IWD 39075:202y(E)

A GQL conformance summary

42) Specifications for Feature G082, “Simplified path pattern expression: basic overrides”:

a)

Subclause 16.14, “<simplified path pattern expression>” :

i)

Without Feature G082, “Simplified path pattern expression: basic overrides”, conforming

GQL language shall not contain a <simplified override left>, a <simplified override

right> , or a <simplified override any direction> .

43) Specifications for Feature G100, “ELEMENT_ID function”:

a)

Subclause 20.24, “<element_id function>”:

i)

Without Feature G100, “ELEMENT_ID function”, conforming GQL language shall not

contain an <element_id function>.

44) Specifications for Feature G110, “IS DIRECTED predicate”:

a)

Subclause 19.8, “<directed predicate>” :

i)

Without Feature G110, “IS DIRECTED predicate”, conforming GQL language shall not

contain <directed predicate> or <directed predicate part 2>.

45) Specifications for Feature G111, “IS LABELED predicate”:

a)

Subclause 19.9, “<labeled predicate>”:

i)

Without Feature G111, “IS LABELED predicate”, conforming GQL language shall not

contain <labeled predicate> or <labeled predicate part 2>.

46) Specifications for Feature G112, “IS SOURCE and IS DESTINATION predicate”:

a)

Subclause 19.10, “<source/destination predicate>” :

i)

Without Feature G112, “IS SOURCE and IS DESTINATION predicate”, conforming GQL

language shall not contain <source/destination predicate> , <source predicate part 2> , or <destination predicate part 2> .

47) Specifications for Feature G113, “ALL_DIFFERENT predicate”:

a)

Subclause 19.11, “<all_different predicate>” :

i)

Without Feature G113, “ALL_DIFFERENT predicate”, conforming GQL language shall

not contain <all_different predicate>.

48) Specifications for Feature G114, “SAME predicate”:

a)

Subclause 19.12, “<same predicate>” :

i)

Without Feature G114, “SAME predicate”, conforming GQL language shall not contain

<same predicate> .

49) Specifications for Feature G115, “PROPERTY_EXISTS predicate”:

a)

Subclause 19.13, “<property_exists predicate>” :

i)

Without Feature G115, “PROPERTY_EXISTS predicate”, conforming GQL language shall

not contain <property_exists predicate> .

50) Specifications for Feature G121, “Grouping in OPTIONAL”:

a)

Subclause 14.4, “<match statement>” :

i)

Without Feature G121, “Grouping in OPTIONAL”, conforming GQL language shall not

contain <match statement block> .

510

IWD 39075:202y(E)

A GQL conformance summary

51) Specifications for Feature G122, “EXISTS predicate: multiple MATCH statements”:

a)

Subclause 19.4, “<exists predicate>” :

i)

Without Feature G122, “EXISTS predicate: multiple MATCH statements”, <exists pre-

dicate> shall not directly contain <match statement block>

52) Specifications for Feature GA00, “Graph with an open graph type”:

a)

Subclause 12.4, “<create graph statement>”:

i)

Without Feature GA00, “Graph with an open graph type”, in conforming GQL language

a <create graph statement> shall not contain an <open graph type>.

53) Specifications for Feature GA01, “Graph with a closed graph type”:

a)

Subclause 12.4, “<create graph statement>”:

i)

Without Feature GA01, “Graph with a closed graph type”, in conforming GQL language

a <create graph statement> shall not contain an <of graph type> .

b)

Subclause 12.6, “<create graph type statement>” :

i)

Without Feature GA01, “Graph with a closed graph type”, conforming GQL language

shall not contain a <create graph type statement> .

c)

Subclause 12.7, “<drop graph type statement>”:

i)

Without Feature GA01, “Graph with a closed graph type”, conforming GQL language

shall not contain a <drop graph type statement>.

54) Specifications for Feature GA02, “Graph Type inline specification”:

a)

Subclause 12.4, “<create graph statement>”:

i)

Without Feature GA02, “Graph Type inline specification”, in conforming GQL language

a <create graph statement> shall not contain an <of graph type> that contains a <nested

graph type specification>.

55) Specifications for Feature GA03, “Graph Type like a graph”:

a)

Subclause 12.4, “<create graph statement>”:

i)

Without Feature GA03, “Graph Type like a graph”, in conforming GQL language a

<create graph statement> shall not contain an <of graph type> that contains a <graph

type like graph>.

56) Specifications for Feature GA04, “Graph from a source”:

a)

Subclause 12.4, “<create graph statement>”:

i)

Without Feature GA04, “Graph from a source”, in conforming GQL language a <create

graph statement> shall not contain a <graph source>.

57) Specifications for Feature GA05, “Graph label set changes”:

a)

Subclause 13.3, “<set statement>” :

i)

Without Feature GA05, “Graph label set changes”, conforming GQL language shall not

contain a <set item> that is a <set label item>.

b)

Subclause 13.4, “<remove statement>”:

511

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GA05, “Graph label set changes”, conforming GQL language shall not

contain a <remove item> that is a <remove label item> .

58) Specifications for Feature GA07, “Undirected edge patterns”:

a)

Subclause 17.3, “<edge type definition>”:

i)

Without Feature GA07, “Undirected edge patterns”, conforming GQL language shall

not contain an <edge type definition> that simply contains an <edge kind> that is UNDIRECTED, an <endpoint pair definition> that is an <endpoint pair definition

undirected>, or a <full edge type pattern> that is a <full edge type pattern undirected> .

59) Specifications for Feature GA08, “Named node types in graph types”:

a)

Subclause 17.2, “<node type definition>” :

i)

Without Feature GA08, “Named node types in graph types”, conforming GQL Language

shall not contain a <node type definition> that contains a <node type phrase>.

60) Specifications for Feature GA09, “Named edge types in graph types”:

a)

Subclause 17.3, “<edge type definition>”:

i)

Without Feature GA09, “Named edge types in graph types”, conforming GQL Language

shall not contain an <edge type definition> that contains an <edge synonym> and an

<edge type phrase>.

61) Specifications for Feature GB00, “Long identifiers”:

a)

Subclause 21.3, “<token>, <separator>, and <identifier>” :

i)

Without Feature GB00, “Long identifiers”, in conforming GQL language, the maximum

length in characters of the representative form of a <non-delimited identifier> or a

<delimited identifier> shall be 27 −1 = 127.

62) Specifications for Feature GB01, “Double minus sign comments”:

a)

Subclause 21.3, “<token>, <separator>, and <identifier>” :

i)

Without Feature GB01, “Double minus sign comments”, conforming GQL language shall

not contain a <simple comment> introduced with a <double minus sign> .

63) Specifications for Feature GB02, “Double solidus comments”:

a)

Subclause 21.3, “<token>, <separator>, and <identifier>” :

i)

Without Feature GB02, “Double solidus comments”, conforming GQL language shall

not contain a <simple comment> introduced with a <double solidus>.

64) Specifications for Feature GB10, “Elementary OLAP operations”:

a)

Subclause 16.20, “<sort specification list>”:

i)

Without Feature GB10, “Elementary OLAP operations”, conforming GQL language shall

not contain a <null ordering>.

65) Specifications for Feature GB11, “External object references”:

a)

Subclause 18.8, “<external object reference>” :

i)

Without Feature GB11, “External object references”, conforming GQL language shall

not contain an <external object reference> .

512

IWD 39075:202y(E)

A GQL conformance summary

66) Specifications for Feature GB12, “Cast specification”:

a)

Subclause 20.23, “<cast specification>” :

i)

Without Feature GB12, “Cast specification”, conforming GQL language shall not contain

a <cast specification>.

67) Specifications for Feature GB13, “Hexadecimal literals”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB13, “Hexadecimal literals”, conforming GQL language shall not

contain an <unsigned hexadecimal integer> .

68) Specifications for Feature GB14, “Octal literals”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB14, “Octal literals”, conforming GQL language shall not contain an

<unsigned octal integer> .

69) Specifications for Feature GB15, “Binary literals”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB15, “Binary literals”, conforming GQL language shall not contain

an <unsigned binary integer> .

70) Specifications for Feature GB20, “128 bit signed integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB20, “128 bit signed integers”, conforming GQL language shall not

contain a <signed binary exact numeric type> that contains INT128, INTEGER128, or

SIGNED INTEGER128.

71) Specifications for Feature GB21, “256 bit signed integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB21, “256 bit signed integers”, conforming GQL language shall not

contain a <signed binary exact numeric type> that contains INT256, INTEGER256, or

SIGNED INTEGER256.

72) Specifications for Feature GB22, “128 bit unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB22, “128 bit unsigned integers”, conforming GQL language shall

not contain an <unsigned binary exact numeric type> that contains UINT128, or

UNSIGNED INTEGER128.

73) Specifications for Feature GB23, “256 bit unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB23, “256 bit unsigned integers”, conforming GQL language shall

not contain an <unsigned binary exact numeric type> that contains UINT256, or

UNSIGNED INTEGER256.

74) Specifications for Feature GB24, “128 bit floats”:

a)

Subclause 17.9, “<value type>”:

513

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GB24, “128 bit floats”, conforming GQL language shall not contain an

<approximate numeric type> that contains FLOAT128.

75) Specifications for Feature GB25, “256 bit floats”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB25, “256 bit floats”, conforming GQL language shall not contain an

<approximate numeric type> that contains FLOAT256.

76) Specifications for Feature GB26, “Byte string types”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB26, “Byte string types”, conforming GQL language shall not contain

a <byte string type> .

77) Specifications for Feature GB27, “Record types”:

a)

Subclause 20.2, “<value expression>”:

i)

Without Feature GB27, “Record types”, conforming GQL language shall not contain a

<record value expression>.

78) Specifications for Feature GB28, “List value types”:

a)

Subclause 20.13, “<list value expression>” :

i)

Without Feature GB28, “List value types”, conforming GQL language shall not contain

a <list value expression>.

b)

Subclause 20.14, “<list value function>”:

i)

Without Feature GB28, “List value types”, conforming GQL language shall not contain

a <list value function> .

79) Specifications for Feature GB30, “Named procedure calls”:

a)

Subclause 15.3, “<named procedure call>”:

i)

Without Feature GB30, “Named procedure calls”, Conforming GQL Language shall not

contain a <named procedure call>.

80) Specifications for Feature GB31, “Path value construction”:

a)

Subclause 20.18, “<path value expression>”:

i)

Without Feature GB31, “Path value construction”, conforming GQL language shall not

contain a <path value concatenation> .

b)

Subclause 20.19, “<path value constructor>” :

i)

Without Feature GB31, “Path value construction”, conforming GQL language shall not

contain a <path value constructor> .

81) Specifications for Feature GB32, “AT schema clause”:

a)

Subclause 9.2, “<procedure body>” :

i)

Without Feature GB32, “AT schema clause”, in conforming GQL language, a <procedure

body> shall not contain an <at schema clause> .

82) Specifications for Feature GB33, “Binding variable definition block”:

514

IWD 39075:202y(E)

A GQL conformance summary

a)

Subclause 9.2, “<procedure body>” :

i)

Without Feature GB33, “Binding variable definition block”, in conforming GQL language,

a <procedure body> shall not contain a <binding variable definition block> .

83) Specifications for Feature GB34, “Graph variables”:

a)

Subclause 9.2, “<procedure body>” :

i)

Without Feature GB34, “Graph variables”, in conforming GQL language, a <binding

variable definition> shall not contain a <graph variable definition>.

b)

Subclause 16.3, “<binding variable reference>” :

i)

Without Feature GB34, “Graph variables”, in conforming GQL language, the declared

type of a <binding variable reference> shall not be a graph reference value type.

84) Specifications for Feature GB35, “Binding table variables”:

a)

Subclause 9.2, “<procedure body>” :

i)

Without Feature GB35, “Binding table variables”, in conforming GQL language, a

<binding variable definition> shall not contain a <binding table variable definition> .

b)

Subclause 16.3, “<binding variable reference>” :

i)

Without Feature GB35, “Binding table variables”, in conforming GQL language, the

declared type of a <binding variable reference> shall not be a binding table reference

value type.

85) Specifications for Feature GB36, “Graph parameters”:

a)

Subclause 16.6, “<parameter>” :

i)

Without Feature GB36, “Graph parameters”, in conforming GQL language, the declared

type of a <parameter> shall not be a graph reference value type.

86) Specifications for Feature GB37, “Binding table parameters”:

a)

Subclause 16.6, “<parameter>” :

i)

Without Feature GB37, “Binding table parameters”, in conforming GQL language, the

declared type of a <parameter> shall not be a binding table reference value type.

87) Specifications for Feature GB38, “Graphs as procedure arguments”:

a)

Subclause 15.3, “<named procedure call>”:

i)

Without Feature GB38, “Graphs as procedure arguments”, in conforming GQL language,

the declared type of a <value expression> immediately contained in a <procedure

argument> shall not be a graph reference value type.

88) Specifications for Feature GB39, “Binding tables as procedure arguments”:

a)

Subclause 15.3, “<named procedure call>”:

i)

Without Feature GB39, “Binding tables as procedure arguments”, in conforming GQL

language, the declared type of a <value expression> immediately contained in a <pro-

cedure argument> shall not be a binding table reference value type.

89) Specifications for Feature GB40, “Let-binding of variables in expressions”:

a)

Subclause 20.25, “<let value expression>”:

515

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GB40, “Let-binding of variables in expressions”, conforming GQL lan-

guage shall not contain <let value expression>.

90) Specifications for Feature GB41, “Opt-out character escaping”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB41, “Opt-out character escaping”, conforming GQL language shall

not contain <no escape>.

91) Specifications for Feature GB42, “Procedure-local value variable definitions”:

a)

Subclause 9.2, “<procedure body>” :

i)

Without Feature GB42, “Procedure-local value variable definitions”, in conforming GQL

language, a <binding variable definition> shall not contain a <binding table variable

definition>.

92) Specifications for Feature GB43, “Approximate number in common notation or as decimal integer

with suffix”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB43, “Approximate number in common notation or as decimal integer

with suffix”, conforming GQL language shall not contain an <approximate numeric lit-

eral> that is an <unsigned decimal in common notation> followed by an <approximate

number suffix> or an <unsigned decimal integer> followed by an <approximate number

suffix>.

93) Specifications for Feature GB44, “Approximate number in scientific notation with suffix”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB44, “Approximate number in scientific notation with suffix”, con-

forming GQL language shall not contain an <approximate numeric literal> that is an

<unsigned decimal in scientific notation> followed by an <approximate number suffix>.

94) Specifications for Feature GB45, “Optional float number suffix”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB45, “Optional float number suffix”, conforming GQL language shall

not contain an <approximate numeric literal> that is an <unsigned decimal in scientific

notation> followed by an <approximate number suffix>.

95) Specifications for Feature GB46, “Optional double number suffix”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB46, “Optional double number suffix”, conforming GQL language

shall not contain an <approximate numeric literal> that simply contains an <approxim-

ate number suffix> that is “d” or “D”.

96) Specifications for Feature GB47, “Exact number in common notation without suffix”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB47, “Exact number in common notation without suffix”, conforming

GQL language shall not contain an <exact numeric literal> that is an <unsigned decimal

in common notation> .

97) Specifications for Feature GB48, “Exact number in common notation or as decimal integer with

suffix”:

516

IWD 39075:202y(E)

A GQL conformance summary

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB48, “Exact number in common notation or as decimal integer with

suffix”, conforming GQL language shall not contain an <exact numeric literal> that is

an <unsigned decimal in common notation> followed by an <exact number suffix> or an <unsigned decimal integer> followed by an <exact number suffix>.

98) Specifications for Feature GB49, “Exact number in scientific notation with suffix”:

a)

Subclause 21.1, “<literal>”:

i)

Without Feature GB49, “Exact number in scientific notation with suffix”, conforming

GQL language shall not contain an <exact numeric literal> that is an <unsigned decimal

in scientific notation> followed by an <exact number suffix> .

99) Specifications for Feature GB51, “8 bit signed integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB51, “8 bit signed integers”, conforming GQL language shall not

contain a <signed binary exact numeric type> that contains SIGNED INTEGER8,

INTEGER8, or INT8.

100) Specifications for Feature GB52, “16 bit signed integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB52, “16 bit signed integers”, conforming GQL language shall not

contain a <signed binary exact numeric type> that contains SIGNED INTEGER16,

INTEGER16, or INT16.

101) Specifications for Feature GB53, “32 bit signed integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB53, “32 bit signed integers”, conforming GQL language shall not

contain a <signed binary exact numeric type> that contains SIGNED INTEGER32,

INTEGER32, or INT32.

102) Specifications for Feature GB54, “64 bit signed integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB54, “64 bit signed integers”, conforming GQL language shall not

contain a <signed binary exact numeric type> that contains SIGNED INTEGER64,

INTEGER64, or INT64.

103) Specifications for Feature GB55, “8 bit unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB55, “8 bit unsigned integers”, conforming GQL language shall not

contain an <unsigned binary exact numeric type> that contains UNSIGNED INTEGER8

or UINT8.

104) Specifications for Feature GB56, “16 bit unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB56, “16 bit unsigned integers”, conforming GQL language shall not

contain an <unsigned binary exact numeric type> that contains UNSIGNED INTEGER16

or UINT16.

517

IWD 39075:202y(E)

A GQL conformance summary

105) Specifications for Feature GB57, “32 bit unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB57, “32 bit unsigned integers”, conforming GQL language shall not

contain an <unsigned binary exact numeric type> that contains UNSIGNED INTEGER32

or UINT32.

106) Specifications for Feature GB58, “64 bit unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB58, “64 bit unsigned integers”, conforming GQL language shall not

contain an <unsigned binary exact numeric type> that contains UNSIGNED INTEGER64

or UINT64.

107) Specifications for Feature GB59, “Small unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB59, “Small unsigned integers”, conforming GQL language shall not

contain an <unsigned binary exact numeric type> that contains USMALLINT.

108) Specifications for Feature GB60, “Regular unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB60, “Regular unsigned integers”, conforming GQL language shall

not contain an <unsigned binary exact numeric type> that contains UINT.

109) Specifications for Feature GB61, “Big unsigned integers”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB61, “Big unsigned integers”, conforming GQL language shall not

contain an <unsigned binary exact numeric type> that contains UBIGINT.

110) Specifications for Feature GB62, “Specified integer precision”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB62, “Specified integer precision”, conforming GQL language shall

not contain a <signed binary exact numeric type> that contains a <precision> or a

<scale> .

111) Specifications for Feature GB63, “16 bit floats”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB63, “16 bit floats”, conforming GQL language shall not contain an

<approximate numeric type> that contains FLOAT16.

112) Specifications for Feature GB64, “32 bit floats”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB64, “32 bit floats”, conforming GQL language shall not contain an

<approximate numeric type> that contains FLOAT32.

113) Specifications for Feature GB65, “64 bit floats”:

a)

Subclause 17.9, “<value type>”:

518

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GB65, “64 bit floats”, conforming GQL language shall not contain an

<approximate numeric type> that contains FLOAT64.

114) Specifications for Feature GB66, “Float synonyms”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB66, “Float synonyms”, conforming GQL language shall not contain

an <approximate numeric type> that contains REAL or DOUBLE.

115) Specifications for Feature GB67, “Specified float precision”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB67, “Specified float precision”, conforming GQL language shall not

contain an <approximate numeric type> that contains a <precision> or a <scale> .

116) Specifications for Feature GB68, “Decimal numeric”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB68, “Decimal numeric”, conforming GQL language shall not contain

an <exact numeric type> that contains DECIMAL or DEC.

117) Specifications for Feature GB69, “Specified byte string maximum length”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB69, “Specified byte string maximum length”, conforming GQL lan-

guage shall not contain a <byte string type> that contains a <max length> .

118) Specifications for Feature GB70, “Specified byte string minimum length”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB70, “Specified byte string minimum length”, conforming GQL lan-

guage shall not contain a <byte string type> that contains a <min length> .

119) Specifications for Feature GB71, “Specified byte string fixed length”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB71, “Specified byte string fixed length”, conforming GQL language

shall not contain a <byte string type> that contains a <fixed length>.

120) Specifications for Feature GB72, “Specified character string maximum length”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GB72, “Specified character string maximum length”, conforming GQL

language shall not contain a <character string type> that contains a <max length> .

121) Specifications for Feature GC02, “Universal comparison”:

a)

Subclause 19.3, “<comparison predicate>”:

i)

Without Feature GC02, “Universal comparison”, in conforming GQL language, the two

<comparison predicand> s shall be comparable.

122) Specifications for Feature GC03, “FOR statement”:

a)

Subclause 14.8, “<for statement>” :

519

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GC03, “FOR statement”, conforming GQL-language shall not contain

a <for statement>.

123) Specifications for Feature GC04, “FOR statement: WITH ORDINALITY and WITH OFFSET”:

a)

Subclause 14.8, “<for statement>” :

i)

Without Feature GC04, “FOR statement: WITH ORDINALITY and WITH OFFSET”, con-

forming GQL-language shall not contain a <for statement> that simply contains <for

ordinality or offset> .

124) Specifications for Feature GC05, “Advanced linear composition with NEXT”:

a)

Subclause 9.2, “<procedure body>” :

i)

Without Feature GC05, “Advanced linear composition with NEXT”, in conforming GQL

language, a <procedure body> shall not contain a <next statement> .

125) Specifications for Feature GC06, “ORDER BY and page statement: OFFSET clause”:

a)

Subclause 14.9, “<order by and page statement>”:

i)

Without Feature GC06, “ORDER BY and page statement: OFFSET clause”, an <order by

and page statement> in conforming GQL language shall not contain an <offset clause>.

126) Specifications for Feature GC07, “ORDER BY and page statement: LIMIT clause”:

a)

Subclause 14.9, “<order by and page statement>”:

i)

Without Feature GC07, “ORDER BY and page statement: LIMIT clause”, an <order by

and page statement> in conforming GQL language shall not contain a <limit clause>.

127) Specifications for Feature GC08, “Complex expressions in sort keys”:

a)

Subclause 14.10, “<primitive result statement>” :

i)

Without Feature GC08, “Complex expressions in sort keys”, the <value expression>

immediately contained in a <sort key> shall be a <binding variable reference> .

128) Specifications for Feature GC09, “Pre-projection aliases in sort keys”:

a)

Subclause 14.10, “<primitive result statement>” :

i)

Without Feature GC09, “Pre-projection aliases in sort keys”, he <value expression>

immediately contained in a <sort key> shall not simply contain any <binding variable

reference> that is not a <return item alias> in the preceding <return statement> .

129) Specifications for Feature GC10, “Aggregate functions in sort keys”:

a)

Subclause 14.10, “<primitive result statement>” :

i)

Without Feature GC10, “Aggregate functions in sort keys”, he <value expression>

immediately contained in a <sort key> shall not simply contain an <aggregate function> .

130) Specifications for Feature GC11, “GROUP BY clause”:

a)

Subclause 16.17, “<group by clause>”:

i)

Without Feature GC11, “GROUP BY clause”, conforming GQL-language shall not contain

<group by clause> .

131) Specifications for Feature GC12, “Composite query: OTHERWISE”:

a)

Subclause 14.2, “<composite query expression>”:

520

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GC12, “Composite query: OTHERWISE”, conforming GQL language

shall not contain a <composite query expression> that immediately contains a <query

conjunction> OTHERWISE.

132) Specifications for Feature GC13, “Composite query: UNION”:

a)

Subclause 14.2, “<composite query expression>”:

i)

Without Feature GC13, “Composite query: UNION”, conforming GQL language shall not

contain a <composite query expression> that immediately contains a <query conjunc-

tion> UNION.

133) Specifications for Feature GC14, “Composite query: EXCEPT DISTINCT”:

a)

Subclause 14.2, “<composite query expression>”:

i)

Without Feature GC14, “Composite query: EXCEPT DISTINCT”, conforming GQL language

shall not contain a <composite query expression> that immediately contains a <query

conjunction> EXCEPT.

134) Specifications for Feature GC15, “Composite query: EXCEPT ALL”:

a)

Subclause 14.2, “<composite query expression>”:

i)

Without Feature GC15, “Composite query: EXCEPT ALL”, conforming GQL language

shall not contain a <composite query expression> that immediately contains a <query

conjunction> EXCEPT ALL.

135) Specifications for Feature GC16, “Composite query: INTERSECT DISTINCT”:

a)

Subclause 14.2, “<composite query expression>”:

i)

Without Feature GC16, “Composite query: INTERSECT DISTINCT”, conforming GQL

language shall not contain a <composite query expression> that immediately contains

a <query conjunction> INTERSECT.

136) Specifications for Feature GC17, “Composite query: INTERSECT ALL”:

a)

Subclause 14.2, “<composite query expression>”:

i)

Without Feature GC17, “Composite query: INTERSECT ALL”, conforming GQL language

shall not contain a <composite query expression> that immediately contains a <query

conjunction> INTERSECT ALL.

137) Specifications for Feature GC18, “FILTER statement”:

a)

Subclause 14.6, “<filter statement>” :

i)

Without Feature GC18, “FILTER statement”, conforming GQL language shall not contain

a <filter statement>.

138) Specifications for Feature GC19, “LET statement”:

a)

Subclause 14.7, “<let statement>”:

i)

Without Feature GC19, “LET statement”, conforming GQL language shall not contain a

<let statement>.

139) Specifications for Feature GC20, “Graph pattern yield”:

a)

Subclause 16.7, “<graph pattern binding table>”:

521

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GC20, “Graph pattern yield”, conforming GQL language shall not contain

a <graph pattern binding table> that immediately contains a <graph pattern yield

clause> .

140) Specifications for Feature GC21, “Advanced aggregate functions: general set functions”:

a)

Subclause 16.19, “<aggregate function>” :

i)

Without Feature GC21, “Advanced aggregate functions: general set functions”, conform-

ing GQL language shall not contain an <aggregate function> that immediately contains

a <general set function type> that is that is COLLECT, STDDEV_SAMP, or STDDEV_POP.

141) Specifications for Feature GC22, “Advanced aggregate functions: binary set functions”:

a)

Subclause 16.19, “<aggregate function>” :

i)

Without Feature GC22, “Advanced aggregate functions: binary set functions”, conforming

GQL language shall not contain an <aggregate function> that immediately contains a

<binary set function type>.

142) Specifications for Feature GC23, “Date and time support”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GC23, “Date and time support”, conforming GQL language shall not

contain a <temporal instant type> .

b)

Subclause 20.9, “<datetime value expression>” :

i)

Without Feature GC23, “Date and time support”, conforming GQL language shall not

contain a <datetime value expression>.

c)

Subclause 20.10, “<datetime value function>”:

i)

Without Feature GC23, “Date and time support”, conforming GQL language shall not

contain a <datetime value function> .

d)

Subclause 21.1, “<literal>”:

i)

Without Feature GC23, “Date and time support”, conforming GQL language shall not

contain a <temporal literal>.

143) Specifications for Feature GC24, “Durations and temporal arithmetic support”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GC24, “Durations and temporal arithmetic support”, conforming GQL

language shall not contain a <temporal duration type> .

b)

Subclause 20.11, “<duration value expression>”:

i)

Without Feature GC24, “Durations and temporal arithmetic support”, conforming GQL

language shall not contain a <duration value expression> .

c)

Subclause 21.1, “<literal>”:

i)

Without Feature GC24, “Durations and temporal arithmetic support”, conforming GQL

language shall not contain a <duration literal> .

144) Specifications for Feature GC25, “SQL datetime and interval formats”:

a)

Subclause 21.1, “<literal>”:

522

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GC25, “SQL datetime and interval formats”, conforming GQL language

shall not contain an <SQL-datetime literal> or an <SQL-interval literal> .

145) Specifications for Feature GC26, “Updatable graphs”:

a)

Subclause 13.1, “<linear data-modifying statement>” :

i)

Without Feature GC26, “Updatable graphs”, conforming GQL language shall not contain

a <simple data-modifying statement>.

146) Specifications for Feature GC27, “Scalar subqueries”:

a)

Subclause 20.21, “<value query expression>”:

i)

Without Feature GC27, “Scalar subqueries”, conforming GQL language shall not contain

a <value query expression> .

147) Specifications for Feature GC28, “Element-wise group variable operations”:

a)

Subclause 22.7, “Evaluating an expression on a group variable” :

i)

Without Feature GC28, “Element-wise group variable operations”, EXP shall be a

<binding variable reference> to GLBV.

148) Specifications for Feature GC29, “Horizontal aggregation”:

a)

Subclause 20.2, “<value expression>”:

i)

Without Feature GC29, “Horizontal aggregation”, conforming GQL language shall not

contain a <value expression> not immediately contained in an <aggregating value

expression> that directly contains an <aggregate function> .

149) Specifications for Feature GD01, “Nested record types”:

a)

Subclause 17.6, “<property type definition>”:

i)

Without Feature GD01, “Nested record types”, conforming GQL language shall not

contain a <property type definition> that simply contains a <record type> .

b)

Subclause 17.10, “<field type>” :

i)

Without Feature GD01, “Nested record types”, conforming GQL language shall not

contain a <field type> that simply contains a <record type>.

c)

Subclause 20.17, “<field>”:

i)

Without Feature GD01, “Nested record types”, conforming GQL language shall not

contain a <field> that simply contains a <record value constructor> .

150) Specifications for Feature GD02, “List value types”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GD02, “List value types”, conforming GQL language shall not contain

a <list value type>.

b)

Subclause 20.15, “<list value constructor>” :

i)

Without Feature GD02, “List value types”, conforming GQL language shall not contain

a <list value constructor>.

151) Specifications for Feature GD03, “Record types”:

a)

Subclause 17.9, “<value type>”:

523

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GD03, “Record types”, conforming GQL language shall not contain a

<record type> .

b)

Subclause 20.16, “<record value constructor>”:

i)

Without Feature GD03, “Record types”, conforming GQL language shall not contain a

<record value constructor>.

152) Specifications for Feature GD04, “Closed record types”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GD04, “Closed record types”, conforming GQL language shall not

contain a <record type> containing a <field types specification>.

b)

Subclause 20.16, “<record value constructor>”:

i)

Without Feature GD04, “Closed record types”, the declared type of the <record value

constructor> is the record type specified by OPEN RECORD.

153) Specifications for Feature GD05, “Open record types”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GD05, “Open record types”, conforming GQL language shall not contain

a <record type> not containing a <field types specification>.

154) Specifications for Feature GD06, “Path value types”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GD06, “Path value types”, conforming GQL language shall not contain

a <path value type>.

b)

Subclause 20.18, “<path value expression>”:

i)

Without Feature GD06, “Path value types”, conforming GQL language shall not contain

a <path value expression> .

155) Specifications for Feature GD07, “Graph reference value types”:

a)

Subclause 11.1, “<graph expression>” :

i)

Without Feature GD07, “Graph reference value types”, in conforming GQL language, a

<graph expression> GE shall not be a <nested graph query specification> and shall not be an <object name or binding variable> that is a <regular identifier> that is a valid

<binding variable reference> whose incoming working record’s declared type is the

declared type of the incoming working record of GE.

NOTE 308 — Without Feature GD08, “Binding table reference value types”, <graph expression> is

limited to references to graphs in the catalog and the current working graph.

b)

Subclause 17.9, “<value type>”:

i)

Without Feature GD07, “Graph reference value types”, conforming GQL language shall

not contain a <graph reference value type>.

c)

Subclause 20.2, “<value expression>”:

i)

Without Feature GD07, “Graph reference value types”, conforming GQL language shall

not contain a <graph reference value expression>.

156) Specifications for Feature GD08, “Binding table reference value types”:

524

IWD 39075:202y(E)

A GQL conformance summary

a)

Subclause 11.2, “<binding table expression>”:

i)

Without Feature GD08, “Binding table reference value types”, in conforming GQL lan-

guage, a <binding table expression> BTE shall not be a <nested binding table query

specification> and shall not be an <object name or binding variable> that is a <regular

identifier> that is a valid <binding variable reference> whose incoming working record’s declared type is the declared type of the incoming working record of BTE.

b)

Subclause 17.9, “<value type>”:

i)

Without Feature GD08, “Binding table reference value types”, conforming GQL language

shall not contain a <binding table reference value type>.

c)

Subclause 20.2, “<value expression>”:

i)

Without Feature GD08, “Binding table reference value types”, conforming GQL language

shall not contain a <binding table reference value expression> .

157) Specifications for Feature GD09, “Value type predicate”:

a)

Subclause 19.6, “<value type predicate>”:

i)

WithoutFeature GD09, “Value type predicate”, conforming GQL language shall not

contain <value type predicate> or <value type predicate part 2> .

158) Specifications for Feature GD10, “Open dynamic union types”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GD10, “Open dynamic union types”, conforming GQL language shall

not contain an <open dynamic union type> .

159) Specifications for Feature GD11, “Closed dynamic union types”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GD11, “Closed dynamic union types”, conforming GQL language shall

not contain a <closed dynamic union type>.

160) Specifications for Feature GD12, “Dynamic property value type”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GD12, “Dynamic property value type”, conforming GQL language shall

not contain a <dynamic property value type> .

161) Specifications for Feature GD14, “Explicit value type nullability”:

a)

Subclause 17.9, “<value type>”:

i)

Without Feature GD14, “Explicit value type nullability”, conforming GQL language shall

not contain <not null> .

162) Specifications for Feature GE01, “Inline procedure”:

a)

Subclause 15.2, “<inline procedure call>”:

i)

Without Feature GE01, “Inline procedure”, conforming GQL language shall not contain

an <inline procedure call> .

163) Specifications for Feature GE02, “Inline procedure with implicit nested variable scope”:

a)

Subclause 15.2, “<inline procedure call>”:

525

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GE02, “Inline procedure with implicit nested variable scope”, in con-

forming GQL language, <inline procedure call> shall contain a <variable scope clause> .

164) Specifications for Feature GE03, “Inline procedure with explicit nested variable scope”:

a)

Subclause 15.2, “<inline procedure call>”:

i)

Without Feature GE03, “Inline procedure with explicit nested variable scope”, in con-

forming GQL language, <inline procedure call> shall not contain a <variable scope

clause> .

165) Specifications for Feature GE04, “Graph reference value expressions”:

a)

Subclause 20.1, “<value specification>”:

i)

Without Feature GE04, “Graph reference value expressions”, conforming GQL-language

shall not contain a <value expression> that simply contains a <graph reference value

expression> .

166) Specifications for Feature GE05, “Binding table reference value expressions”:

a)

Subclause 20.1, “<value specification>”:

i)

Without Feature GE05, “Binding table reference value expressions”, conforming GQL-

language shall not contain a <value expression> that simply contains a <binding table

reference value expression>.

167) Specifications for Feature GE06, “Use Graph Support”:

a)

Subclause 13.1, “<linear data-modifying statement>” :

i)

Without Feature GE06, “Use Graph Support”, conforming GQL language shall not contain

a <focused linear data-modifying statement>.

b)

Subclause 14.3, “<linear query statement> and <simple query statement>” :

i)

Without Feature GE06, “Use Graph Support”, conforming GQL language shall not contain

a <focused linear query statement> .

c)

Subclause 16.1, “<use graph clause>”:

i)

Without Feature GE06, “Use Graph Support”, conforming GQL language shall not contain

a <use graph clause> .

168) Specifications for Feature GF01, “Enhanced numeric functions”:

a)

Subclause 20.6, “<numeric value function>”:

i)

Without Feature GF01, “Enhanced numeric functions”, conforming GQL language shall

not contain an <absolute value expression>, a <modulus expression>, a <floor function> , a <ceiling function>, or a <square root>.

169) Specifications for Feature GF02, “Trigonometric functions”:

a)

Subclause 20.6, “<numeric value function>”:

i)

Without Feature GF02, “Trigonometric functions”, conforming GQL language shall not

contain a <trigonometric function> .

170) Specifications for Feature GF03, “Logarithmic functions”:

a)

Subclause 20.6, “<numeric value function>”:

526

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GF03, “Logarithmic functions”, conforming GQL language shall not

contain a <general logarithm function>, a <common logarithm> , a <natural logarithm> , an <exponential function> , or a <power function>.

171) Specifications for Feature GF04, “Enhanced path functions”:

a)

Subclause 20.6, “<numeric value function>”:

i)

Without Feature GF04, “Enhanced path functions”, conforming GQL language shall not

contain a <path length expression> .

b)

Subclause 20.14, “<list value function>”:

i)

Without Feature GF04, “Enhanced path functions”, conforming GQL language shall not

contain an <elements function>.

172) Specifications for Feature GF05, “Multi-character TRIM function”:

a)

Subclause 20.8, “<string value function>” :

i)

Without Feature GF05, “Multi-character TRIM function”, conforming GQL language

shall not contain a <multi-character trim function> .

173) Specifications for Feature GF06, “Explicit TRIM function”:

a)

Subclause 20.8, “<string value function>” :

i)

Without Feature GF06, “Explicit TRIM function”, conforming GQL language shall not

contain a <single-character trim function> that simply contains FROM.

174) Specifications for Feature GF07, “Byte string TRIM function”:

a)

Subclause 20.8, “<string value function>” :

i)

Without Feature GF07, “Byte string TRIM function”, conforming GQL language shall

not contain a <byte string trim function>.

175) Specifications for Feature GM01, “Graph schema management”:

a)

Subclause 12.2, “<create schema statement>” :

i)

Without Feature GM01, “Graph schema management”, conforming GQL language shall

not contain a <create schema statement>.

b)

Subclause 12.3, “<drop schema statement>” :

i)

Without Feature GM01, “Graph schema management”, conforming GQL language shall

not contain a <drop schema statement> .

176) Specifications for Feature GM02, “Graph schema management exists”:

a)

Subclause 12.2, “<create schema statement>” :

i)

Without Feature GM02, “Graph schema management exists”, conforming GQL language

shall not contain a <create schema statement> that includes IF NOT EXISTS.

b)

Subclause 12.3, “<drop schema statement>” :

i)

Without Feature GM02, “Graph schema management exists”, conforming GQL language

shall not contain a <drop schema statement> that includes IF EXISTS.

177) Specifications for Feature GM03, “Graph type exists”:

a)

Subclause 12.6, “<create graph type statement>” :

527

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GM03, “Graph type exists”, conforming GQL language shall not contain

a <create graph type statement> that includes IF NOT EXISTS.

b)

Subclause 12.7, “<drop graph type statement>”:

i)

Without Feature GM03, “Graph type exists”, conforming GQL language shall not contain

a <drop graph type statement> that includes IFEXISTS.

178) Specifications for Feature GM04, “Graph management”:

a)

Subclause 12.4, “<create graph statement>”:

i)

Without Feature GM04, “Graph management”, conforming GQL language shall not

contain a <create graph statement>.

b)

Subclause 12.5, “<drop graph statement>” :

i)

Without Feature GM04, “Graph management”, conforming GQL language shall not

contain a <drop graph statement>.

179) Specifications for Feature GM05, “Graph management exists”:

a)

Subclause 12.4, “<create graph statement>”:

i)

Without Feature GM05, “Graph management exists”, conforming GQL language shall

not contain a <create graph statement> that includes IF NOT EXISTS.

b)

Subclause 12.5, “<drop graph statement>” :

i)

Without Feature GM05, “Graph management exists”, conforming GQL language shall

not contain a <drop graph statement> that includes IF EXISTS.

180) Specifications for Feature GS01, “Session-local graph parameters”:

a)

Subclause 7.1, “<session set command>”:

i)

Without Feature GS01, “Session-local graph parameters”, conforming GQL language

shall not contain a <session set graph parameter clause> .

181) Specifications for Feature GS02, “Session-local binding table parameters”:

a)

Subclause 7.1, “<session set command>”:

i)

Without Feature GS02, “Session-local binding table parameters”, conforming GQL lan-

guage shall not contain a <session set binding table parameter clause>.

182) Specifications for Feature GS03, “Session-local value parameters”:

a)

Subclause 7.1, “<session set command>”:

i)

Without Feature GS03, “Session-local value parameters”, conforming GQL language

shall not contain a <session set value parameter clause>.

183) Specifications for Feature GS04, “Session: reset all characteristics”:

a)

Subclause 7.2, “<session reset command>” :

i)

Without Feature GS04, “Session: reset all characteristics”, conforming GQL language

shall not contain SESSION RESET ALL CHARACTERISTICS.

184) Specifications for Feature GS05, “Session: reset schema”:

a)

Subclause 7.2, “<session reset command>” :

528

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GS05, “Session: reset schema”, conforming GQL language shall not

contain SESSION RESET SCHEMA.

185) Specifications for Feature GS06, “Session: reset property graph”:

a)

Subclause 7.2, “<session reset command>” :

i)

Without Feature GS06, “Session: reset property graph”, conforming GQL language shall

not contain SESSION RESET PROPERTY GRAPH or SESSION RESET GRAPH.

186) Specifications for Feature GS07, “Session: reset timezone”:

a)

Subclause 7.2, “<session reset command>” :

i)

Without Feature GS07, “Session: reset timezone”, conforming GQL language shall not

contain SESSION RESET TIME ZONE.

187) Specifications for Feature GS08, “Session: reset all parameters”:

a)

Subclause 7.2, “<session reset command>” :

i)

Without Feature GS08, “Session: reset all parameters”, conforming GQL language shall

not contain SESSION RESET ALL PARAMETERS or SESSION RESET PARAMETERS.

188) Specifications for Feature GS09, “Session-local graph parameters based on subqueries”:

a)

Subclause 7.1, “<session set command>”:

i)

Without Feature GS09, “Session-local graph parameters based on subqueries”, conform-

ing GQL language shall not contain a <session set graph parameter clause> that contains

a <procedure body> .

189) Specifications for Feature GS10, “Session-local binding table parameters based on subqueries”:

a)

Subclause 7.1, “<session set command>”:

i)

Without Feature GS10, “Session-local binding table parameters based on subqueries”,

conforming GQL language shall not contain a <session set binding table parameter

clause> that contains a <procedure body> .

190) Specifications for Feature GS11, “Session-local value parameters based on subqueries”:

a)

Subclause 7.1, “<session set command>”:

i)

Without Feature GS11, “Session-local value parameters based on subqueries”, conform-

ing GQL language shall not contain a <session set value parameter clause> that contains

a <procedure body> .

191) Specifications for Feature GS12, “Session-local graph parameters based on simple expressions or

references”:

a)

Subclause 7.1, “<session set command>”:

i)

Without Feature GS12, “Session-local graph parameters based on simple expressions

or references”, conforming GQL language shall not contain a <session set graph para-

meter clause> that simply contains a <graph expression> that does not conform to

<value specification> or is a <graph reference>.

192) Specifications for Feature GS13, “Session-local binding table parameters based on simple expressions

or references”:

a)

Subclause 7.1, “<session set command>”:

529

IWD 39075:202y(E)

A GQL conformance summary

i)

Without Feature GS13, “Session-local binding table parameters based on simple

expressions or references”, conforming GQL language shall not contain a <session set

binding table parameter clause> that simply contains a <binding table expression>

that does not conform to <value specification> or is a <binding table reference>.

193) Specifications for Feature GS14, “Session-local value parameters based on simple expressions”:

a)

Subclause 7.1, “<session set command>”:

i)

Without Feature GS14, “Session-local value parameters based on simple expressions”,

conforming GQL language shall not contain a <session set value parameter clause> that

simply contains a <value expression> that does not conform to <value specification> .

194) Specifications for Feature GS15, “Explicit transactions”:

a)

Clause 6, “<GQL-program>”:

i)

Without Feature GS15, “Explicit transactions”, conforming GQL language shall not

contain a <transaction activity>.

195) Specifications for Feature GS16, “Transaction characteristics”:

a)

Subclause 8.1, “<start transaction command>” :

i)

Without Feature GS16, “Transaction characteristics”, conforming GQL language shall

not contain a <start transaction command> that contains <transaction characteristics> .

530





IWD 39075:202y(E)

Annex B

(informative)

Implementation-defined elements

This Annex references those features that are identified in the body of this document as implementation-

defined.

The term implementation-defined is used to identify characteristics that may differ between GQL-imple-

mentations, but that shall be defined for each particular GQL-implementation.

1)

References to: IA001, “The period (GQL-Session) in which consecutive GQL-requests are executed

by a GQL-client on behalf of a GQL-Agent.” are:

a)

Subclause 4.5.1, “General description of GQL-sessions”:

i)

1st paragraph

2)

References to: IA002, “The extent to which further GQL-status objects are chained.” are:

a)

Subclause 4.9.2, “GQL-status objects”:

i)

6th paragraph

3)

References to: IA003, “The result of any operation other than a normalize function or a normalized

predicate on an unnormalized character string.” are:

a)

Subclause 4.15.3.3.1, “Introduction to character strings”:

i)

4th paragraph

4)

References to: IA004, “The rules for determining the actual value of an approximate numeric type

from its apparent value.” are:

a)

Subclause 4.15.3.5.2, “Characteristics of numbers” :

i)

5th paragraph

5)

References to: IA005, “Whether rounding or truncating occurs when least significant digits are lost

on assignment.” are:

a)

Subclause 4.15.3.5.2, “Characteristics of numbers” :

i)

7th paragraph

ii)

8th paragraph

b)

Subclause 20.23, “<cast specification>” :

i)

GR 9)a)i)

ii)

GR 10)a)i)

iii)

GR 11)a)i)

c)

Subclause 21.1, “<literal>”:

531

IWD 39075:202y(E)

B Implementation-defined elements

i)

GR 3)

d)

Subclause 22.1, “Store assignment” :

i)

GR 4)b)x)2)A)

ii)

GR 4)b)xi)2)B)I)

6)

References to: IA006, “The choice of value selected when there is more than one approximation for

an exact numeric type that conforms to the criteria.” are:

a)

Subclause 4.15.3.5.2, “Characteristics of numbers” :

i)

10th paragraph

7)

References to: IA007, “Which numeric values other than exact numeric types also have approxima-

tions.” are:

a)

Subclause 4.15.3.5.2, “Characteristics of numbers” :

i)

11th paragraph

8)

References to: IA008, “The choice of value selected when there is more than one approximation for

an approximate numeric type that conforms to the criteria.” are:

a)

Subclause 4.15.3.5.2, “Characteristics of numbers” :

i)

12th paragraph

9)

References to: IA009, “Which numeric values have approximations obtained by rounding or trun-

cation for a given approximate numeric type.” are:

a)

Subclause 4.15.3.5.2, “Characteristics of numbers” :

i)

13th paragraph

b)

Subclause 20.11, “<duration value expression>”:

i)

GR 5)d)vi)

10) References to: IA010, “The boundaries within which the normal rules of arithmetic apply.” are:

a)

Subclause 4.15.3.5.2, “Characteristics of numbers” :

i)

15th paragraph

11) References to: IA011, “Whether rounding or truncating is used on division with an approximate

mathematical result.” are:

a)

Subclause 20.4, “<numeric value expression>” :

i)

GR 5)b)

12) References to: IA012, “Whether a GQL Flagger flags implementation-defined features.” are:

a)

Subclause 24.5.3, “Extensions and options” :

i)

4th paragraph

13) References to: IA013, “Whether the General Rules of Evaluation of a selective path pattern are ter-

minated if an exception condition is raised.” are:

a)

Subclause 22.4, “Evaluation of a selective <path pattern>” :

i)

GR 2)

532

IWD 39075:202y(E)

B Implementation-defined elements

14) References to: IA014, “Whether an exception condition is raised when the declared type of NULL

cannot be determined contextually.” are:

a)

Subclause 21.1, “<literal>”:

i)

SR 60)b)

15) References to: IA015, “Whether to pad character strings for comparison, or not.” are:

a)

Subclause 19.3, “<comparison predicate>”:

i)

GR 5)a)

16) References to: IA016, “Whether to treat byte string differing only in right-most X'00' bytes as equal,

or not.” are:

a)

Subclause 19.3, “<comparison predicate>”:

i)

GR 6)c)

17) References to: IA017, “Whether or not an exception condition is raised or an arbitrary value is

chosen when multiple assignments to a graph element property are specified.” are:

a)

Subclause 13.3, “<set statement>” :

i)

GR 4)

18) References to: IA018, “The rules regarding the comparison of reference values that have different

referents but are of the same base type.” are:

a)

Subclause 4.4.2, “Reference values”:

i)

2nd paragraph

19) References to: IA019, “Whether <bidirectional control character>s are permitted in string literals.”

are:

a)

Subclause 21.1, “<literal>”:

i)

SR 35)b)ii)

b)

Subclause 21.3, “<token>, <separator>, and <identifier>” :

i)

SR 10)

20) References to: IA020, “Whether characters of the Unicode General Category class “Co” are permitted

to be contained in the representative form of an identifier.” are:

a)

Subclause 21.3, “<token>, <separator>, and <identifier>” :

i)

SR 5)e)

21) References to: IA022, “Whether two records without the same set of field names are comparable

or not.” are:

a)

Subclause 4.15.2.3, “Record type”:

i)

2) list item

22) References to: IA023, “The character (code) interpreted as newline.” are:

a)

Subclause 21.3, “<token>, <separator>, and <identifier>” :

i)

SR 11)

533

IWD 39075:202y(E)

B Implementation-defined elements

23) References to: IA024, “Which of two values of different static base types that are not numbers is

less than the other.” are:

a)

Subclause 19.3, “<comparison predicate>”:

i)

GR 12)b)

24) References to: IA025, “The effect that additional values resulting from the support of Feature GB50,

“IEEE 754 floating point operations” have on the processing of a GQL-request.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

2nd paragraph

25) References to: IA026, “Whether an SQL-implementation supports leap seconds or discontinuities

in calendars, and the consequences of such support for date and interval arithmetic.” are:

a)

Subclause 20.11, “<duration value expression>”:

i)

GR 5)d)vi)

26) References to: ID001, “The object (principal) that represents a user within a GQL-implementation.”

are:

a)

Subclause 4.2.4.1, “Principals”:

i)

1st paragraph

27) References to: ID002, “The association between a principal and its home schema and home graph.”

are:

a)

Subclause 4.2.4.1, “Principals”:

i)

4th paragraph

28) References to: ID003, “The set of privileges identified by an authorization identifier.” are:

a)

Subclause 4.2.4.2, “Authorization identifiers”:

i)

2nd paragraph

29) References to: ID004, “The list element type when a <list value constructor by enumeration> contains no <list element list>. ” are:

a)

Subclause 20.15, “<list value constructor>” :

i)

SR 3)

30) References to: ID005, “The declared type of an <elements function> .” are:

a)

Subclause 20.14, “<list value function>”:

i)

SR 2)

31) References to: ID006, “The default transaction characteristics.” are:

a)

Subclause 8.1, “<start transaction command>” :

i)

SR 2)

32) References to: ID016, “The translations of condition texts.” are:

a)

Subclause 4.9.2, “GQL-status objects”:

i)

4th paragraph

534

IWD 39075:202y(E)

B Implementation-defined elements

33) References to: ID017, “The map of diagnostic information, if provided.” are:

a)

Subclause 4.9.1, “Introduction to diagnostic information”:

i)

2nd paragraph

b)

Subclause 4.9.2, “GQL-status objects”:

i)

5th list item, of the 3rd paragraph

34) References to: ID021, “The preferred name of the Boolean type.” are:

a)

Subclause 4.15.3.2, “Boolean types” :

i)

2nd list item, of the 3rd paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 5)

35) References to: ID022, “The default collation.” are:

a)

Subclause 4.15.3.3.2, “Collations”:

i)

3rd paragraph

b)

Subclause 22.15, “Collation determination”:

i)

SR 2)

ii)

SR 2)c)

36) References to: ID023, “The preferred name of the character string type.” are:

a)

Subclause 4.15.3.3.1, “Introduction to character strings”:

i)

2nd list item, of the 6th paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 9)

37) References to: ID024, “The preferred name of the fixed-length byte string type.” are:

a)

Subclause 4.15.3.4, “Byte string types”:

i)

2nd list item, of the 3rd paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 18)

38) References to: ID027, “The preferred name of the variable-length byte string type.” are:

a)

Subclause 4.15.3.4, “Byte string types”:

i)

2nd list item, of the 3rd paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 18)

39) References to: ID028, “The binary precision of a signed regular integer type.” are:

a)

Subclause 4.15.3.5.3, “Binary exact numeric types”:

535

IWD 39075:202y(E)

B Implementation-defined elements

i)

7th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 37)g)

40) References to: ID029, “The binary precision of a signed small integer type.” are:

a)

Subclause 4.15.3.5.3, “Binary exact numeric types”:

i)

8th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 37)h)

41) References to: ID030, “The binary precision of a signed big integer type.” are:

a)

Subclause 4.15.3.5.3, “Binary exact numeric types”:

i)

9th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 37)i)

42) References to: ID031, “The binary precision of a signed user-specified integer type.” are:

a)

Subclause 4.15.3.5.3, “Binary exact numeric types”:

i)

10th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 37)j)

43) References to: ID033, “The binary precision of an unsigned user-specified integer type.” are:

a)

Subclause 4.15.3.5.3, “Binary exact numeric types”:

i)

10th list item, of the 2nd paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 38)j)

44) References to: ID034, “The decimal precision of a regular decimal exact numeric type.” are:

a)

Subclause 4.15.3.5.4, “Decimal exact numeric types”:

i)

1st list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 41)c)

45) References to: ID035, “The decimal precision of a user-specified decimal exact numeric type without

a scale specification.” are:

a)

Subclause 4.15.3.5.4, “Decimal exact numeric types”:

i)

2nd list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 41)b)

536

IWD 39075:202y(E)

B Implementation-defined elements

46) References to: ID036, “The decimal precision of a user-specified decimal exact numeric type with

a scale specification.” are:

a)

Subclause 4.15.3.5.4, “Decimal exact numeric types”:

i)

3rd list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 41)a)

47) References to: ID037, “The binary precision of a regular approximate numeric type.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

6th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)f)

c)

Subclause 22.17, “Result of static value type combinations”:

i)

SR 4)c)ii)1)

48) References to: ID038, “The binary scale of a regular approximate numeric type.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

6th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)f)

49) References to: ID039, “The binary precision of a real approximate numeric type.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

7th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)g)

50) References to: ID040, “The binary scale of a real approximate numeric type.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

7th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)g)

51) References to: ID041, “The binary precision of a double approximate numeric type.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

8th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)h)

52) References to: ID042, “The binary scale of a double approximate numeric type.” are:

537

IWD 39075:202y(E)

B Implementation-defined elements

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

8th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)h)

53) References to: ID043, “The binary precision of a user-specified approximate numeric type without

a scale specification.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

9th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)i)i)

54) References to: ID044, “The binary scale of a user-specified approximate numeric type without a

scale specification.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

9th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)i)i)

55) References to: ID045, “The binary precision of a user-specified approximate numeric type with a

scale specification.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

10th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)i)ii)

56) References to: ID046, “The binary scale of a user-specified approximate numeric type with a scale

specification.” are:

a)

Subclause 4.15.3.5.5, “Approximate numeric types” :

i)

10th list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 45)i)ii)

57) References to: ID048, “The default time zone displacement.” are:

a)

Clause 6, “<GQL-program>”:

i)

GR 1)a)iii)

b)

Subclause 7.2, “<session reset command>” :

i)

GR 3)

58) References to: ID049, “The default session parameters.” are:

a)

Clause 6, “<GQL-program>”:

538

IWD 39075:202y(E)

B Implementation-defined elements

i)

GR 1)a)vi)

b)

Subclause 7.2, “<session reset command>” :

i)

GR 4)b)

ii)

GR 5)b)

59) References to: ID057, “The exact numeric type with scale 0 (zero) of list element ordinals.” are:

a)

Subclause 14.8, “<for statement>” :

i)

SR 10)b)i)3)A)

60) References to: ID058, “The exact numeric type with scale 0 (zero) of list element offsets.” are:

a)

Subclause 14.8, “<for statement>” :

i)

SR 10)b)i)3)B)

61) References to: ID059, “The declared type of the result of COUNT function.” are:

a)

Subclause 16.19, “<aggregate function>” :

i)

SR 7)b)

62) References to: ID060, “The implicit ordering of NULLs.” are:

a)

Subclause 16.20, “<sort specification list>”:

i)

SR 6)

63) References to: ID062, “The declared type of an unsigned integer specification.” are:

a)

Subclause 20.1, “<value specification>”:

i)

SR 2)

64) References to: ID063, “The declared type of the result of a dyadic arithmetic operator when either

operand is approximate numeric.” are:

a)

Subclause 20.4, “<numeric value expression>” :

i)

SR 1)a)

65) References to: ID064, “The declared type of the result of a dyadic arithmetic operator when both

operands are exact numeric.” are:

a)

Subclause 20.4, “<numeric value expression>” :

i)

SR 1)b)

66) References to: ID065, “The precision of the result of addition and subtraction of exact numeric

types.” are:

a)

Subclause 20.4, “<numeric value expression>” :

i)

SR 1)b)ii)

67) References to: ID066, “The precision of the result of multiplication of exact numeric types.” are:

a)

Subclause 20.4, “<numeric value expression>” :

i)

SR 1)b)iii)

68) References to: ID067, “The precision and scale of the result of division of exact numeric types.” are:

539

IWD 39075:202y(E)

B Implementation-defined elements

a)

Subclause 20.4, “<numeric value expression>” :

i)

SR 1)b)iv)

69) References to: ID068, “The declared type of the result of a length expression.” are:

a)

Subclause 20.6, “<numeric value function>”:

i)

SR 1)

70) References to: ID069, “The declared type of the result of trigonometric functions, general logarithm

functions, natural logarithms, exponential functions, and power functions.” are:

a)

Subclause 20.6, “<numeric value function>”:

i)

SR 3)

ii)

SR 4)

iii)

SR 5)

iv)

SR 6)

v)

SR 7)

71) References to: ID074, “The precision of an exact numeric result of a numeric value expression.” are:

a)

Subclause 20.6, “<numeric value function>”:

i)

SR 8)a)

72) References to: ID075, “The precision of an approximate numeric result of a numeric value expres-

sion.” are:

a)

Subclause 20.6, “<numeric value function>”:

i)

SR 8)b)

73) References to: ID076, “The declared type of an element_id function.” are:

a)

Subclause 20.24, “<element_id function>”:

i)

SR 3)

74) References to: ID079, “The declared type of an approximate numeric literal.” are:

a)

Subclause 21.1, “<literal>”:

i)

SR 18)c)

75) References to: ID080, “The scale of a user-specified decimal exact numeric type with a scale specific-

ation.” are:

a)

Subclause 4.15.3.5.4, “Decimal exact numeric types”:

i)

3rd list item, of the 1st paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 41)a)

76) References to: ID085, “The declared type of NULL if its declared type cannot be determined contex-

tually.” are:

a)

Subclause 21.1, “<literal>”:

540

IWD 39075:202y(E)

B Implementation-defined elements

i)

SR 60)b)

77) References to: ID086, “The default match mode.” are:

a)

Subclause 4.11.9, “Match modes” :

i)

3rd paragraph

b)

Subclause 16.8, “<graph pattern>” :

i)

SR 10)

78) References to: ID087, “The preferred name of graph types and graph reference value types (either

GRAPH or PROPERTY GRAPH).” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 57)

79) References to: ID088, “The preferred name of binding table types and binding table reference value

types (either TABLE or BINDING TABLE).” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 61)

80) References to: ID089, “The preferred name of node types and node reference value types (either

NODE or VERTEX).” are:

a)

Subclause 17.2, “<node type definition>” :

i)

SR 8)

b)

Subclause 17.9, “<value type>”:

i)

SR 63)

81) References to: ID090, “The preferred name of edge types and edge reference value types (either

EDGE or RELATIONSHIP).” are:

a)

Subclause 17.3, “<edge type definition>”:

i)

SR 21)

b)

Subclause 17.9, “<value type>”:

i)

SR 67)

82) References to: ID091, “The preferred name of the base type of node reference value types (either

NODE REFERENCE or VERTEX REFERENCE).” are:

a)

Subclause 17.9, “<value type>”:

i)

GR 11)a)

ii)

GR 12)a)

83) References to: ID092, “The preferred name of the base type of node types (either NODE DATA or

VERTEX DATA).” are:

a)

Subclause 17.9, “<value type>”:

i)

GR 11)b)

ii)

GR 12)b)

541

IWD 39075:202y(E)

B Implementation-defined elements

84) References to: ID093, “The preferred name of the base type of edge reference value types (either

EDGE REFERENCE or RELATIONSHIP REFERENCE).” are:

a)

Subclause 17.9, “<value type>”:

i)

GR 13)a)

ii)

GR 14)a)

85) References to: ID094, “The preferred name of the base type of edge types (either EDGE DATA or

RELATIONSHIP DATA).” are:

a)

Subclause 17.9, “<value type>”:

i)

GR 13)b)

ii)

GR 14)b)

86) References to: ID095, “The exact numeric result type of the SUM function.” are:

a)

Subclause 16.19, “<aggregate function>” :

i)

SR 8)d)ii)

87) References to: ID096, “The exact numeric result type of the AVG function.” are:

a)

Subclause 16.19, “<aggregate function>” :

i)

SR 8)d)iii)

88) References to: ID097, “The approximate numeric result type of the SUM and AVG functions.” are:

a)

Subclause 16.19, “<aggregate function>” :

i)

SR 8)d)iv)

89) References to: ID098, “The approximate numeric result type of the STDDEV_POP and STDDEV_SAMP

functions.” are:

a)

Subclause 16.19, “<aggregate function>” :

i)

SR 8)e)

90) References to: ID099, “The approximate numeric result type of binary set functions.” are:

a)

Subclause 16.19, “<aggregate function>” :

i)

SR 9)i)

91) References to: ID100, “The choice of wether to round or truncate the result of PERCENTILE_DISC

” are:

a)

Subclause 16.19, “<aggregate function>” :

i)

GR 6)c)vi)2)

92) References to: ID101, “The choice of wether to raise an exception when store assignment requires

rounding or truncation. ” are:

a)

Subclause 22.1, “Store assignment” :

i)

GR 4)b)x)2)

ii)

GR 4)b)xi)2)B)

542

IWD 39075:202y(E)

B Implementation-defined elements

93) References to: IE001, “The object, resource, or value identified by a URI or a URL.” are:

a)

Subclause 18.8, “<external object reference>” :

i)

SR 4)

94) References to: IE002, “The levels of transaction isolation, their interactions, their granularity of

application and the Format and Syntax Rules for <implementation-defined access mode> used to

select them.” are:

a)

Subclause 4.6.3, “Transaction isolation” :

i)

1st paragraph

b)

Subclause 8.2, “<transaction characteristics>” :

i)

SR 3)

95) References to: IE003, “The UAX31-R1-1 profile if used.” are:

a)

Subclause 21.3, “<token>, <separator>, and <identifier>” :

i)

SR 1)

ii)

SR 2)

96) References to: IE004, “Any relaxation of the assumption of the serializable transactional behavior.”

are:

a)

Subclause 4.6.1, “General description of GQL-transactions”:

i)

5th paragraph

97) References to: IE005, “The treatment of language that does not conform to the Formats and Syntax

Rules.” are:

a)

Subclause 5.3.2.2, “Terms denoting rule requirements”:

i)

1st paragraph

98) References to: IE006, “Any additional restrictions, requirements, and conditions imposed on mixed-

mode transactions.” are:

a)

Subclause 4.6.1, “General description of GQL-transactions”:

i)

7th paragraph

99) References to: IE007, “The conditions raised when the requirements on mixed-mode transactions

are violated.” are:

a)

Subclause 4.6.1, “General description of GQL-transactions”:

i)

7th paragraph

100) References to: IE008, “Additional conditions for which a completion condition warning (01000) is

raised.” are:

a)

Subclause 4.9.3, “Conditions”:

i)

4th paragraph

b)

Subclause 8.4, “<commit command>” :

i)

GR 2)b)

543

IWD 39075:202y(E)

B Implementation-defined elements

101) References to: IL001, “The minimum cardinality of a node label set.” are:

a)

Subclause 4.3.4.1, “Introduction to graphs”:

i)

1st list item, of the 1st list item, of the 3rd paragraph

b)

Subclause 4.13.3.1, “Node types” :

i)

1st list item, of the 5th paragraph

c)

Subclause 13.2, “<insert statement>” :

i)

GR 3)a)i)2)

d)

Subclause 13.4, “<remove statement>”:

i)

GR 4)b)ii)

e)

Subclause 17.2, “<node type definition>” :

i)

SR 6)

102) References to: IL002, “The minimum cardinality of an edge label set.” are:

a)

Subclause 4.3.4.1, “Introduction to graphs”:

i)

1st list item, of the 2nd list item, of the 3rd paragraph

b)

Subclause 4.13.3.2, “Edge types”:

i)

1st list item, of the 5th paragraph

c)

Subclause 13.2, “<insert statement>” :

i)

GR 3)a)ii)2)

d)

Subclause 13.4, “<remove statement>”:

i)

GR 4)b)iii)

e)

Subclause 17.3, “<edge type definition>”:

i)

SR 17)

103) References to: IL003, “The maximum cardinality of a node label set.” are:

a)

Subclause 4.3.4.1, “Introduction to graphs”:

i)

2nd list item, of the 1st list item, of the 3rd paragraph

b)

Subclause 4.13.3.1, “Node types” :

i)

2nd list item, of the 5th paragraph

c)

Subclause 13.2, “<insert statement>” :

i)

GR 3)a)i)3)

d)

Subclause 13.3, “<set statement>” :

i)

GR 5)c)ii)

e)

Subclause 17.2, “<node type definition>” :

i)

SR 7)

544

IWD 39075:202y(E)

B Implementation-defined elements

104) References to: IL004, “The maximum cardinality of a node property set.” are:

a)

Subclause 4.3.4.1, “Introduction to graphs”:

i)

1st list item, of the 1st list item, of the 3rd paragraph

b)

Subclause 4.13.3.1, “Node types” :

i)

1st list item, of the 5th paragraph

c)

Subclause 13.2, “<insert statement>” :

i)

GR 3)a)i)5)

d)

Subclause 13.3, “<set statement>” :

i)

GR 5)c)iii)

e)

Subclause 17.2, “<node type definition>” :

i)

SR 10)

105) References to: IL005, “The maximum cardinality of an edge label set.” are:

a)

Subclause 4.3.4.1, “Introduction to graphs”:

i)

2nd list item, of the 2nd list item, of the 3rd paragraph

b)

Subclause 4.13.3.2, “Edge types”:

i)

2nd list item, of the 5th paragraph

c)

Subclause 13.2, “<insert statement>” :

i)

GR 3)a)ii)3)

d)

Subclause 13.3, “<set statement>” :

i)

GR 5)c)iv)

e)

Subclause 17.3, “<edge type definition>”:

i)

SR 18)

106) References to: IL006, “The maximum cardinality of an edge property set.” are:

a)

Subclause 4.3.4.1, “Introduction to graphs”:

i)

1st list item, of the 2nd list item, of the 3rd paragraph

b)

Subclause 4.13.3.2, “Edge types”:

i)

1st list item, of the 5th paragraph

c)

Subclause 13.2, “<insert statement>” :

i)

GR 3)a)ii)5)

d)

Subclause 13.3, “<set statement>” :

i)

GR 5)c)v)

e)

Subclause 17.3, “<edge type definition>”:

i)

SR 20)

545

IWD 39075:202y(E)

B Implementation-defined elements

107) References to: IL009, “The minimum length of a variable-length byte string resulting from a byte

string concatenation.” are:

a)

Subclause 20.7, “<string value expression>”:

i)

SR 3)a)

108) References to: IL010, “The maximum number of digits permitted in an unsigned integer literal.”

are:

a)

Subclause 21.1, “<literal>”:

i)

SR 13)

109) References to: IL011, “The maximum precision of an exact numeric type.” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 44)a)

110) References to: IL012, “The maximum scale of an exact numeric type.” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 44)b)

111) References to: IL013, “The maximum length of a character string.” are:

a)

Subclause 4.15.3.3.1, “Introduction to character strings”:

i)

2nd paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 11)

c)

Subclause 20.7, “<string value expression>”:

i)

SR 1)

ii)

GR 2)b)ii)3)

d)

Subclause 20.8, “<string value function>” :

i)

GR 1)d)

ii)

GR 2)e)

112) References to: IL014, “The maximum length of a byte string.” are:

a)

Subclause 4.15.3.4, “Byte string types”:

i)

2nd paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 24)

c)

Subclause 20.7, “<string value expression>”:

i)

SR 3)

ii)

GR 3)b)i)

113) References to: IL015, “The maximum cardinality of a list type.” are:

546

IWD 39075:202y(E)

B Implementation-defined elements

a)

Subclause 20.13, “<list value expression>” :

i)

SR 2)b)

b)

Subclause 20.15, “<list value constructor>” :

i)

SR 4)

114) References to: IL016, “The maximum precision of an exact numeric type.” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 34)a)

b)

Subclause 22.17, “Result of static value type combinations”:

i)

SR 4)c)ii)2)

115) References to: IL017, “The maximum scale of an exact numeric type.” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 34)b)

116) References to: IL018, “The maximum value of the upper bound of a general qualifier.” are:

a)

Subclause 16.13, “<graph pattern quantifier>”:

i)

SR 1)

117) References to: IL019, “The maximum number of record fields.” are:

a)

Subclause 4.15.2.3, “Record type”:

i)

3rd paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 83)

c)

Subclause 20.16, “<record value constructor>”:

i)

SR 4)

118) References to: IL020, “The maximum depth of nesting of GQL-directories.” are:

a)

Subclause 4.2.5.1, “General description of the GQL-catalog” :

i)

4th paragraph

119) References to: IL021, “The maximum cardinality of a list value type for each element type.” are:

a)

Subclause 4.15.2.2, “List value types” :

i)

5th paragraph

b)

Subclause 17.9, “<value type>”:

i)

SR 76)d)i)

ii)

SR 76)d)ii)

120) References to: IL022, “The maximum cardinality of path element lists of path value types.” are:

a)

Subclause 4.15.2.4, “Path value types”:

547

IWD 39075:202y(E)

B Implementation-defined elements

i)

4th paragraph

b)

Subclause 20.18, “<path value expression>”:

i)

GR 1)b)iv)

121) References to: IL023, “The maximum and minimum values of the exponent for an approximate

numeric type.” are:

a)

Subclause 20.4, “<numeric value expression>” :

i)

GR 6)

122) References to: IL024, “The maximum value of fractional seconds precision for a temporal instant

or a temporal duration.” are:

a)

Subclause 4.15.3.6, “Temporal types” :

i)

22nd paragraph

b)

Subclause 20.11, “<duration value expression>”:

i)

GR 5)d)iii)

123) References to: IV001, “The character repertoire of GQL source text.” are:

a)

Subclause 4.7.1, “General description of GQL-requests and GQL-programs” :

i)

1st list item, of the 2nd paragraph

124) References to: IV002, “The result of an inequality comparison between two lists when not otherwise

specified.” are:

a)

Subclause 19.3, “<comparison predicate>”:

i)

GR 3)b)i)2)B)

125) References to: IV003, “The result of an inequality comparison between two records when not oth-

erwise specified.” are:

a)

Subclause 19.3, “<comparison predicate>”:

i)

GR 3)b)ii)1)B)II)

ii)

GR 3)b)ii)2)B)

126) References to: IV004, “The choice of the normal form of binding table type from amongst the equi-

valent binding table types.” are:

a)

Subclause 17.8, “<binding table type>”:

i)

SR 3)

127) References to: IV005, “The choice of the normal form of an endpoint pair from amongst the equivalent

endpoint pairs.” are:

a)

Subclause 17.3, “<edge type definition>”:

i)

SR 8)

128) References to: IV006, “The choice of the normal form of label set definition from amongst the

equivalent label set definitions.” are:

a)

Subclause 17.4, “<label set definition>”:

548

IWD 39075:202y(E)

B Implementation-defined elements

i)

SR 2)

129) References to: IV007, “The choice of the normal form of property type set definition from amongst

the equivalent property type set definitions.” are:

a)

Subclause 17.5, “<property type set definition>” :

i)

SR 2)

130) References to: IV008, “The choice of the normal form of record type from amongst the equivalent

record types.” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 80)

131) References to: IV009, “The choice of the normal form of list value type from amongst the equivalent

list value types.” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 77)

132) References to: IV010, “The result of a comparison of two operands that are not comparable.” are:

a)

Subclause 19.3, “<comparison predicate>”:

i)

GR 2)

133) References to: IV011, “The chosen dynamic property value type.” are:

a)

Subclause 4.3.2, “Properties and supported property value types”:

i)

3rd paragraph

134) References to: IV012, “The set of component types of the open dynamic union type.” are:

a)

Subclause 4.15.1.3, “Characteristics of dynamic union types” :

i)

2nd paragraph

135) References to: IV013, “The choice of the normal form of dynamic union type from amongst the

equivalent dynamic union value types.” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 91)

136) References to: IV014, “The set of value types that includes at least one supertype of every static

value type supported by the GQL-implementation.” are:

a)

Subclause 17.9, “<value type>”:

i)

GR 20)b)

137) References to: IV015, “The choice of the normal form of temporal instant types from amongst the

equivalent temporal instant types.” are:

a)

Subclause 17.9, “<value type>”:

i)

SR 55)

138) References to: IW001, “The mechanism to instruct a GQL-client to create and destroy GQL-sessions

to GQL-servers, and to submit GQL-requests to them.” are:

549

IWD 39075:202y(E)

B Implementation-defined elements

a)

Subclause 4.2.2, “GQL-agents”:

i)

1st paragraph

139) References to: IW002, “The mechanism for creating and destroying authorization identifiers, and

their mapping to principals.” are:

a)

Subclause 4.2.4.1, “Principals”:

i)

2nd paragraph

140) References to: IW003, “The mechanism and rules by which a GQL-implementation determines when

the last request has been received.” are:

a)

Subclause 4.5.1, “General description of GQL-sessions”:

i)

2nd paragraph

141) References to: IW004, “The alternative mechanism of starting and terminating of transactions.”

are:

a)

Subclause 4.6.2, “Transaction demarcation” :

i)

11th paragraph

142) References to: IW005, “The mechanism by which termination success or failure statuses are made

available to the GQL-agent or administrator.” are:

a)

Subclause 4.6.2, “Transaction demarcation” :

i)

10th paragraph

143) References to: IW006, “The mechanism for determining the dictionary of request parameters of a

GQL-request.” are:

a)

Subclause 4.7.1, “General description of GQL-requests and GQL-programs” :

i)

2nd list item, of the 2nd paragraph

b)

Subclause 4.7.2.2, “GQL-request context creation” :

i)

1st paragraph

144) References to: IW007, “The manner in which a GQL-status object is presented to a GQL-client.” are:

a)

Subclause 4.9.1, “Introduction to diagnostic information”:

i)

3rd paragraph

145) References to: IW010, “The mechanism by which an external procedure is provided.” are:

a)

Subclause 4.10.2.5, “Procedures classified by type of provisioning”:

i)

2nd list item, of the 1st paragraph

146) References to: IW011, “The mechanism by which the reference value type of an element variable

declared by a graph pattern is determined.” are:

a)

Subclause 16.3, “<binding variable reference>” :

i)

SR 12)a)i)

ii)

SR 12)a)ii)

iii)

SR 12)a)iii)

550

IWD 39075:202y(E)

B Implementation-defined elements

147) References to: IW012, “The mechanism by which the reference value type of an element variable

declared by insert node pattern is determined.” are:

a)

Subclause 13.2, “<insert statement>” :

i)

SR 4)a)i)

148) References to: IW013, “The mechanism by which the reference value type of an element variable

declared by insert edge pattern is determined.” are:

a)

Subclause 13.2, “<insert statement>” :

i)

SR 4)a)ii)

149) References to: IW014, “The mechanism used to determine if two character strings are visually

confusable with each other.” are:

a)

Subclause 4.15.3.3.1, “Introduction to character strings”:

i)

5th paragraph

150) References to: IW015, “The manner, if it so chooses, in which a GQL-implementation automatically

creates a GQL-directory.” are:

a)

Subclause 4.2.5.2, “GQL-directories” :

i)

5th paragraph

151) References to: IW016, “The manner, if it so chooses, in which a GQL-implementation automatically

populates a GQL-schema upon its creation.” are:

a)

Subclause 4.2.5.3, “GQL-schemas”:

i)

8th paragraph

152) References to: IW017, “The manner in which the result of the concatenation of non-normalized

character strings is determined.” are:

a)

Subclause 20.7, “<string value expression>”:

i)

GR 2)b)ii)2)B)

153) References to: IW018, “The exact manner in which lax casts (and supporting type tests) are generated

and included in the syntax transforms for the dynamic generation of strict casts.” are:

a)

Subclause 4.15.1.4.4, “Dynamic generation of additional type tests and lax casts for a <value

expression>”:

i)

2nd paragraph

154) References to: IW019, “The mechanism for determining the character string type that is a supertype

of every character string type in a set of character string types.” are:

a)

Subclause 22.17, “Result of static value type combinations”:

i)

SR 4)a)iii)

155) References to: IW020, “The mechanism for determining the byte string type that is a supertype of

every byte string type in a set of byte string types.” are:

a)

Subclause 22.17, “Result of static value type combinations”:

i)

SR 4)b)iii)

551

IWD 39075:202y(E)

B Implementation-defined elements

156) References to: IW021, “The mechanism for determining a permutation of all value types of a set of

value types.” are:

a)

Subclause 22.18, “Static value type set precedence determination” :

i)

SR 5)

157) References to: IW022, “The mechanism for determining if the null value is not actually going to be

assigned to a site.” are:

a)

Subclause 4.16.4.3, “Nullability inference” :

i)

1) list item

158) References to: IW023, “The mechanism for determining the canonical name form of a <delimited

identifier> or <non-delimited identifier>. ” are:

a)

Subclause 21.3, “<token>, <separator>, and <identifier>” :

i)

SR 21)

159) References to: IW024, “The mechanism for determining the value type that is a supertype of every

reference value type with the same associated base type in a set of value types.” are:

a)

Subclause 22.17, “Result of static value type combinations”:

i)

SR 4)k)iv)

552





IWD 39075:202y(E)

Annex C

(informative)

Implementation-dependent elements

This Annex references those places where this document states explicitly that the actions of a conforming

GQL-implementation are implementation-dependent.

The term implementation-dependent is used to identify characteristics that may differ between GQL-

implementations, but that are not necessarily specified for any particular GQL-implementation.

1)

References to: UA001, “The interaction between multiple GQL-environments.” are:

a)

Subclause 4.2.1, “General description of GQL-environments”:

i)

2nd paragraph

2)

References to: UA002, “Whether or not diagnostic information pertaining to more than one condition

is made available.” are:

a)

Subclause 4.9.3, “Conditions”:

i)

10th paragraph

3)

References to: UA003, “Which of two unequal reference values is less than the other.” are:

a)

Subclause 19.3, “<comparison predicate>”:

i)

GR 11)b)

4)

References to: UA004, “Whether or not that exception condition is actually raised when the evaluation

of an inessential part of an expression or search condition would cause an exception to be raised.”

are:

a)

Subclause 5.3.2.3, “Rule evaluation order”:

i)

10th paragraph

5)

References to: UA005, “Which path bindings are retained in an any paths search if the number of

candidates exceeds the required number.” are:

a)

Subclause 22.4, “Evaluation of a selective <path pattern>” :

i)

GR 13)a)ii)

6)

References to: UA006, “Which additional path bindings are actually probed to establish whether

they might also raise an exception when the GQL-implementation has terminated the evaluation

of a selective path pattern.” are:

a)

Subclause 22.4, “Evaluation of a selective <path pattern>” :

i)

GR 2)

7)

References to: UD001, “The node type names of node types without explicitly specified names.”

are:

a)

Subclause 17.2, “<node type definition>” :

553

IWD 39075:202y(E)

C Implementation-dependent elements

i)

SR 4)

8)

References to: UD002, “The edge type names of edge types without explicitly specified names.” are:

a)

Subclause 17.3, “<edge type definition>”:

i)

SR 11)

9)

References to: US001, “The sequence of records in an unordered binding table.” are:

a)

Subclause 4.3.5, “Binding tables” :

i)

2) list item

ii)

10th paragraph

b)

Subclause 16.21, “<limit clause>” :

i)

GR 2)

c)

Subclause 16.22, “<offset clause>” :

i)

GR 2)

10) References to: US005, “The order of path bindings that have the same number of edges.” are:

a)

Subclause 22.4, “Evaluation of a selective <path pattern>” :

i)

GR 13)b)i)2)

11) References to: US006, “The relative ordering of peers in a sort.” are:

a)

Subclause 16.20, “<sort specification list>”:

i)

GR 1)k)

12) References to: US007, “The relative ordering of items in a sort whose comparison is Unknown.” are:

a)

Subclause 16.20, “<sort specification list>”:

i)

GR 1)i)

13) References to: US008, “The actual order of expression evaluation.” are:

a)

Subclause 5.3.2.3, “Rule evaluation order”:

i)

4th paragraph

14) References to: US009, “The point in time at which the request timestamp is set.” are:

a)

Subclause 20.10, “<datetime value function>”:

i)

GR 1)

15) References to: US010, “The order of binding variable names in comma-separated lists of <binding

variable reference> s.” are:

a)

Subclause 14.4, “<match statement>” :

i)

SR 5)b)

ii)

SR 5)d)

16) References to: UV001, “The value of an object identifier.” are:

a)

Subclause 4.3.1, “General introduction to GQL-objects”:

554

IWD 39075:202y(E)

C Implementation-dependent elements

i)

2nd paragraph

17) References to: UV002, “The value of the alias in an <exists predicate> syntactic substitution ” are: a)

Subclause 19.4, “<exists predicate>” :

i)

SR 2)a)

ii)

SR 3)a)

18) References to: UV003, “The <value expression> whose evaluation raises the exception condition:

data exception — invalid value type (22G12).” are:

a)

Subclause 4.15.1.4.2, “Dynamic generation of type tests and strict casts for a <value expression>

without operands” :

i)

7) list item

b)

Subclause 4.15.1.4.3, “Dynamic generation of type tests and strict casts for a <value expression>

with operands”:

i)

5) list item

19) References to: UV004, “The value of the result of an element id function.” are:

a)

Subclause 20.24, “<element_id function>”:

i)

GR 2)b)

20) References to: UV005, “The physical representation of an instance of a data type.” are:

a)

Subclause 4.12.1, “General introduction to data types and base types”:

i)

1st paragraph

21) References to: UV007, “The declared type of a site that contains an intermediate result.” are:

a)

Subclause 5.3.2.3, “Rule evaluation order”:

i)

11th paragraph

22) References to: UV008, “The implicit identifiers required in path pattern evaluation.” are:

a)

Subclause 16.7, “<graph pattern binding table>”:

i)

SR 22)c)ii)

b)

Subclause 16.10, “<path pattern expression>” :

i)

SR 9)d)

23) References to: UV009, “Which arbitrary value is chosen when multiple assignments to a graph ele-

ment property are specified.” are:

a)

Subclause 13.3, “<set statement>” :

i)

GR 4)b)

24) References to: UV010, “The implicit identifiers required in the evaluation of HAVING clauses.” are:

a)

Subclause 14.12, “<select statement>” :

i)

SR 8)a)iii)2)

555

IWD 39075:202y(E)

C Implementation-dependent elements

25) References to: UV011, “The implicit <element variable declaration> used in an <insert statement>. ”

are:

a)

Subclause 16.11, “<insert graph pattern>” :

i)

SR 3)a)

26) References to: UV012, “The implicit identifiers required in dynamic generation of type tests and

strict casts.” are:

a)

Subclause 4.15.1.4.2, “Dynamic generation of type tests and strict casts for a <value expression>

without operands” :

i)

5) list item

b)

Subclause 4.15.1.4.3, “Dynamic generation of type tests and strict casts for a <value expression>

with operands”:

i)

2) list item

c)

Subclause 16.7, “<graph pattern binding table>”:

i)

SR 16)b)

27) References to: UV013, “The implicit order of <element variable declaration>s in the enumeration

used in an <all_different predicate> or a <same predicate> .” are:

a)

Subclause 19.11, “<all_different predicate>” :

i)

GR 1)

b)

Subclause 19.12, “<same predicate>” :

i)

GR 1)

28) References to: UV014, “The implicit identifiers required in the generation of column names for

<return item alias>es. ” are:

a)

Subclause 14.10, “<primitive result statement>” :

i)

SR 4)c)i)2)A)VII)2)

29) References to: UV015, “The start datetime used for converting intervals to scalars for subtraction

purposes.” are:

a)

Subclause 20.11, “<duration value expression>”:

i)

GR 5)d)v)

556





IWD 39075:202y(E)

Annex D

(informative)

GQL feature taxonomy

This Annex describes a taxonomy of features defined in this document.

Table D.1, “Feature taxonomy for optional features”, contains a taxonomy of the optional features of the

GQL language.

In this table, the first column contains a counter that can be used to quickly locate rows of the table; these

values otherwise have no use and are not stable — that is, they are subject to change in future editions

of or even Technical Corrigenda to this document without notice.

The “Feature ID” column of this table specifies the formal identification of each feature and each subfeature

contained in the table.

The “Feature Name” column of this table contains a brief description of the feature or subfeature associated

with the Feature ID value.

Table D.1, “Feature taxonomy for optional features”, does not provide definitions of the features; the

definition of those features is found in the Conformance Rules that are further summarized in Annex A,

“GQL conformance summary” .

Table D.1 — Feature taxonomy for optional features

Feature ID

Feature Name

1

G002

Different-edges match mode

2

G003

Explicit REPEATABLE ELEMENTS keyword

3

G004

Path variables

4

G005

Path search prefix in a path pattern

5

G006

Graph pattern KEEP clause: path mode prefix

6

G007

Graph pattern KEEP clause: path search prefix

7

G010

Explicit WALK keyword

8

G011

Advanced path modes: TRAIL

9

G012

Advanced path modes: SIMPLE

10

G013

Advanced path modes: ACYCLIC

11

G014

Explicit PATH/PATHS keywords

12

G015

All path search: explicit ALL keyword

557

IWD 39075:202y(E)

D GQL feature taxonomy

Feature ID

Feature Name

13

G016

Any path search

14

G017

All shortest path search

15

G018

Any shortest path search

16

G019

Counted shortest path search

17

G020

Counted shortest group search

18

G030

Path multiset alternation

19

G031

Path multiset alternation: variable length path operands

20

G032

Path pattern union

21

G033

Path pattern union: variable length path operands

22

G035

Quantified paths

23

G036

Quantified edges

24

G037

Questioned paths

25

G038

Parenthesized path pattern expression

26

G039

Simplified path pattern expression: full defaulting

27

G041

Non-local element pattern predicates

28

G043

Complete full edge patterns

29

G044

Basic abbreviated edge patterns

30

G045

Complete abbreviated edge patterns

31

G046

Relaxed topological consistency: adjacent vertex patterns

32

G047

Relaxed topological consistency: concise edge patterns

33

G048

Parenthesized path pattern: subpath variable declaration

34

G049

Parenthesized path pattern: path mode prefix

35

G050

Parenthesized path pattern: WHERE clause

36

G051

Parenthesized path pattern: non-local predicates

37

G060

Bounded graph pattern quantifiers

38

G061

Unbounded graph pattern quantifiers

39

G074

Label expression: wildcard label

40

G080

Simplified path pattern expression: basic defaulting

558

IWD 39075:202y(E)

D GQL feature taxonomy

Feature ID

Feature Name

41

G081

Simplified path pattern expression: full overrides

42

G082

Simplified path pattern expression: basic overrides

43

G100

ELEMENT_ID function

44

G110

IS DIRECTED predicate

45

G111

IS LABELED predicate

46

G112

IS SOURCE and IS DESTINATION predicate

47

G113

ALL_DIFFERENT predicate

48

G114

SAME predicate

49

G115

PROPERTY_EXISTS predicate

50

G121

Grouping in OPTIONAL

51

G122

EXISTS predicate: multiple MATCH statements

52

GA00

Graph with an open graph type

53

GA01

Graph with a closed graph type

54

GA02

Graph Type inline specification

55

GA03

Graph Type like a graph

56

GA04

Graph from a source

57

GA05

Graph label set changes

58

GA07

Undirected edge patterns

59

GA08

Named node types in graph types

60

GA09

Named edge types in graph types

61

GB00

Long identifiers

62

GB01

Double minus sign comments

63

GB02

Double solidus comments

64

GB10

Elementary OLAP operations

65

GB11

External object references

66

GB12

Cast specification

67

GB13

Hexadecimal literals

68

GB14

Octal literals

559

IWD 39075:202y(E)

D GQL feature taxonomy

Feature ID

Feature Name

69

GB15

Binary literals

70

GB20

128 bit signed integers

71

GB21

256 bit signed integers

72

GB22

128 bit unsigned integers

73

GB23

256 bit unsigned integers

74

GB24

128 bit floats

75

GB25

256 bit floats

76

GB26

Byte string types

77

GB27

Record types

78

GB28

List value types

79

GB30

Named procedure calls

80

GB31

Path value construction

81

GB32

AT schema clause

82

GB33

Binding variable definition block

83

GB34

Graph variables

84

GB35

Binding table variables

85

GB36

Graph parameters

86

GB37

Binding table parameters

87

GB38

Graphs as procedure arguments

88

GB39

Binding tables as procedure arguments

89

GB40

Let-binding of variables in expressions

90

GB41

Opt-out character escaping

91

GB42

Procedure-local value variable definitions

92

GB43

Approximate number in common notation or as decimal integer with

suffix

93

GB44

Approximate number in scientific notation with suffix

94

GB45

Optional float number suffix

95

GB46

Optional double number suffix

560

IWD 39075:202y(E)

D GQL feature taxonomy

Feature ID

Feature Name

96

GB47

Exact number in common notation without suffix

97

GB48

Exact number in common notation or as decimal integer with suffix

98

GB49

Exact number in scientific notation with suffix

99

GB50

IEEE 754 floating point operations

100 GB51

8 bit signed integers

101 GB52

16 bit signed integers

102 GB53

32 bit signed integers

103 GB54

64 bit signed integers

104 GB55

8 bit unsigned integers

105 GB56

16 bit unsigned integers

106 GB57

32 bit unsigned integers

107 GB58

64 bit unsigned integers

108 GB59

Small unsigned integers

109 GB60

Regular unsigned integers

110 GB61

Big unsigned integers

111 GB62

Specified integer precision

112 GB63

16 bit floats

113 GB64

32 bit floats

114 GB65

64 bit floats

115 GB66

Float synonyms

116 GB67

Specified float precision

117 GB68

Decimal numeric

118 GB69

Specified byte string maximum length

119 GB70

Specified byte string minimum length

120 GB71

Specified byte string fixed length

121 GB72

Specified character string maximum length

122 GC00

Multiple graphs in a GQL-transaction

123 GC01

Catalog and data statement mixing

561

IWD 39075:202y(E)

D GQL feature taxonomy

Feature ID

Feature Name

124 GC02

Universal comparison

125 GC03

FOR statement

126 GC04

FOR statement: WITH ORDINALITY and WITH OFFSET

127 GC05

Advanced linear composition with NEXT

128 GC06

ORDER BY and page statement: OFFSET clause

129 GC07

ORDER BY and page statement: LIMIT clause

130 GC08

Complex expressions in sort keys

131 GC09

Pre-projection aliases in sort keys

132 GC10

Aggregate functions in sort keys

133 GC11

GROUP BY clause

134 GC12

Composite query: OTHERWISE

135 GC13

Composite query: UNION

136 GC14

Composite query: EXCEPT DISTINCT

137 GC15

Composite query: EXCEPT ALL

138 GC16

Composite query: INTERSECT DISTINCT

139 GC17

Composite query: INTERSECT ALL

140 GC18

FILTER statement

141 GC19

LET statement

142 GC20

Graph pattern yield

143 GC21

Advanced aggregate functions: general set functions

144 GC22

Advanced aggregate functions: binary set functions

145 GC23

Date and time support

146 GC24

Durations and temporal arithmetic support

147 GC25

SQL datetime and interval formats

148 GC26

Updatable graphs

149 GC27

Scalar subqueries

150 GC28

Element-wise group variable operations

151 GC29

Horizontal aggregation

562

IWD 39075:202y(E)

D GQL feature taxonomy

Feature ID

Feature Name

152 GD01

Nested record types

153 GD02

List value types

154 GD03

Record types

155 GD04

Closed record types

156 GD05

Open record types

157 GD06

Path value types

158 GD07

Graph reference value types

159 GD08

Binding table reference value types

160 GD09

Value type predicate

161 GD10

Open dynamic union types

162 GD11

Closed dynamic union types

163 GD12

Dynamic property value type

164 GD13

Dynamic union types

165 GD14

Explicit value type nullability

166 GE01

Inline procedure

167 GE02

Inline procedure with implicit nested variable scope

168 GE03

Inline procedure with explicit nested variable scope

169 GE04

Graph reference value expressions

170 GE05

Binding table reference value expressions

171 GE06

Use Graph Support

172 GF01

Enhanced numeric functions

173 GF02

Trigonometric functions

174 GF03

Logarithmic functions

175 GF04

Enhanced path functions

176 GF05

Multi-character TRIM function

177 GF06

Explicit TRIM function

178 GF07

Byte string TRIM function

179 GM01

Graph schema management

563

IWD 39075:202y(E)

D GQL feature taxonomy

Feature ID

Feature Name

180 GM02

Graph schema management exists

181 GM03

Graph type exists

182 GM04

Graph management

183 GM05

Graph management exists

184 GS01

Session-local graph parameters

185 GS02

Session-local binding table parameters

186 GS03

Session-local value parameters

187 GS04

Session: reset all characteristics

188 GS05

Session: reset schema

189 GS06

Session: reset property graph

190 GS07

Session: reset timezone

191 GS08

Session: reset all parameters

192 GS09

Session-local graph parameters based on subqueries

193 GS10

Session-local binding table parameters based on subqueries

194 GS11

Session-local value parameters based on subqueries

195 GS12

Session-local graph parameters based on simple expressions or refer-

ences

196 GS13

Session-local binding table parameters based on simple expressions or

references

197 GS14

Session-local value parameters based on simple expressions

198 GS15

Explicit transactions

199 GS16

Transaction characteristics

564





IWD 39075:202y(E)

Annex E

(informative)

Maintenance and interpretation of GQL

ISO/IEC JTC 1 provides formal procedures for revision, maintenance, and interpretation of JTC 1 Standards,

including creation and processing of “Defect Reports”. Defect reports may result in technical corrigenda,

amendments, interpretations, or other commentary on an existing International Standard.

A defect report may be submitted by a national standards body that is a P-member or O-member, a Liaison

Organization, a member of the defect editing group for the subject document, or a working group of the

committee responsible for the document. A defect identified by the user of the standard, or someone

external to the committee, shall be processed via one of the official channels listed above. The submitter

shall complete part 2 of the defect report form (see the Defect Report form in the Templates folder at the

JTC 1 web site, as well as its attachment 1) and shall send the form to the Convenor or WG Secretariat

with which the relevant defect editing group is associated.

** Editor’s Note (number 73) **

Every time we republish SQL/Framework, we must consult the ISO Directives and/or JTC 1 Standing Document 21 to see

whether the instructions have changed.

Potential new questions or new defect reports addressing the specifications of this document should be

communicated to:

Secretariat, ISO/IEC JTC1/SC32

American National Standards Institute

11 West 42nd Street

New York, NT 10036

USA

565





IWD 39075:202y(E)

Bibliography

« WG3:UTC-013 P00-CAN-003 deleted three bibliographic references »

[1]

The Unicode Consortium. Unicode Security Considerations [online]. Mountain View, California,

USA: The Unicode Consortium, Available at https://www.unicode.org/reports/tr36/

[2]

Common vulnerabilities and exposures database [online]. Bedford, Massachusetts, USA: The Mitre

Corporation, 2021 . CVE-2021-42574. Available at https://www.cve.org/-

CVERecord?id=CVE-2021-42574

566





IWD 39075:202y(E)

Index

Index entries appearing in boldface indicate the page where the word, phrase, or BNF non-terminal was defined; index entries appearing in italics indicate a page where the BNF non-terminal was used in a Format; and index entries appearing in roman type indicate a page where the word, phrase, or BNF non-terminal was used in a heading, Function, Syntax Rule, Access Rule,

General Rule, Conformance Rule, Table, or other descriptive text.

— A —

alias name • 184

<all path search> • 218, 219, 220, 221, 506

ABS • 347, 373, 425

<all shortest path search> • 59, 218, 219, 221, 506

ACOS • 347, 351, 425

<all_different predicate> • 316, 317, 333, 476, 510, 556

ACYCLIC • 58, 218, 221, 428, 449, 450, 506

alphabet • 447

AGGREGATE • 428

<ambient linear data-modifying statement> • 117, 144

AGGREGATES • 428

<ambient linear data-modifying statement body> • 144, 145

ALL • 106, 107, 162, 163, 164, 182, 183, 213, 218, 250, 251,

<ambient linear query statement> • 117, 161, 165, 388

252, 253, 425, 521, 528, 529

ambient statement • 52

ALL_DIFFERENT • 333, 425

<ampersand> • 54, 151, 235, 240, 436, 437

ALTER • 428

annotated path • 448

AND • 70, 340, 341, 356, 425

anonymous edge symbol • 446

ANY • 218, 219, 280, 425, 481

anonymous node symbol • 446

ARRAY • 280, 425

<any path search> • 59, 218, 219, 221, 458, 506

AS • 136, 140, 180, 182, 183, 187, 188, 245, 323, 393, 394,

395, 396, 397, 400, 401, 402, 403, 404, 418, 426, 444

<any shortest path search> • 218, 219, 221, 506

ASC • 256, 426

apparent value • 81

ASCENDING • 256, 426

<approximate number suffix> • 398, 412, 414, 415, 421, 516

ASIN • 347, 351, 426

approximate numbers • 76

AT • 199, 426

<approximate numeric literal> • 81, 398, 412, 414, 415, 419,

421, 516

ATAN • 347, 352, 426

<approximate numeric type> • 80, 277, 278, 283, 286, 293, AVG • 250, 252, 426

298, 514, 518, 519

<abbreviated edge pattern> • 54, 223, 224, 226, 231, 454,

approximate numeric types • 76

508

<arc type filler> • 265

<abbreviated edge type pattern> • 265, 266, 267, 268

<arc type pointing left> • 265

<abbreviated edge type pattern pointing left> • 266

<arc type pointing right> • 265

<abbreviated edge type pattern pointing right> • 265, 266

<arc type undirected> • 265

<abbreviated edge type pattern undirected> • 266, 267, 268

array data, right truncation • 445

<absolute catalog schema reference> • 301, 312, 493

assignable • 19

<absolute directory path> • 134, 135, 301, 302

assignment • 88

<absolute value expression> • 347, 349, 351, 354, 526

assignment-aligned • 88

<accent quoted character representation> • 411, 415, 416

<asterisk> • 182, 183, 185, 237, 238, 250, 251, 343, 344, 370,

<accent quoted character sequence> • 410, 415, 416, 425,

371, 436, 437, 509

432

<at schema clause> • 40, 45, 116, 119, 199, 514

accessing multiple graphs not supported • 114, 142, 371, 475

at the same depth of graph pattern matching • 212

active GQL-transaction • 37, 109

authorization identifier • 26

acyclic • 53

<aggregate function> • 57, 179, 180, 181, 186, 188, 230, 250,

— B —

251, 255, 339, 345, 389, 477, 478, 520, 522, 523

<aggregating value expression> • 182, 183, 184, 186, 187, B is appended to A • 34

251, 253, 256, 338, 339, 523

BIG • 76, 82, 83, 278, 283, 284, 285, 426

567

IWD 39075:202y(E)

BIGINT • 76, 82, 278, 283, 284, 426

<boolean type> • 77, 277, 281, 292

BINARY • 75, 79, 277, 282, 426

<boolean value expression> • 77, 209, 315, 338, 340, 341

BINDING • 76, 102, 122, 275, 288, 338, 428

bound insert element pattern • 233

BINDINGS • 168, 182, 183, 211, 216, 428, 505

bounded quantifier • 238

BNF non-terminal symbol • 90

bracket index • 446

BOOL • 75, 77, 277, 281, 426, 496

<bracket right arrow> • 223, 232, 265, 429, 430

BOOLEAN • 75, 77, 277, 281, 426, 496

bracket symbol binding • 447

BOTH • 358, 360, 362, 363, 426

bracket symbols • 446

BTRIM • 358, 360, 426

<bracket tilde right arrow> • 223, 429, 430

BY • 247, 249, 426

<bracketed comment> • 431, 432, 434

BYTES • 75, 79, 277, 282, 426

<bracketed comment contents> • 432, 433

BYTE_LENGTH • 347, 426

<bracketed comment introducer> • 432

Boolean type • 77, 281

<bracketed comment terminator> • 432, 433

Boolean types • 75

<byte length expression> • 347, 350

Booleans • 75

byte string • 78

base type • 60

<byte string concatenation> • 355, 357

base type name prefix • 60

<byte string factor> • 355, 357

be included in • 95

<byte string function> • 358

begin subpath symbol • 446

<byte string literal> • 410, 412, 417, 420, 425, 433

<bidirectional control character> • 416, 431, 433, 533

<byte string primary> • 355, 356

<binary digit> • 413, 414, 436

<byte string trim function> • 359, 362, 363, 527

<binary exact numeric type> • 277, 278, 284

<byte string trim operands> • 359

<binary set function> • 250, 251, 252, 253, 254

<byte string trim source> • 359, 362

<binary set function type> • 250, 255, 522

<byte string type> • 78, 79, 277, 282, 292, 298, 514, 519

binding • 216, 457

byte string types • 75

<binding table expression> • 45, 105, 122, 123, 129, 130,

<byte string value expression> • 347, 350, 355, 357, 359

338, 525, 530

byte strings • 75

<binding table initializer> • 103, 122

<binding table name> • 307, 422, 424

— C —

<binding table reference> • 105, 129, 130, 307, 312, 530

CALL • 168, 172, 190, 191, 208, 426

<binding table reference value expression> • 337, 338, 339, CASE • 390, 391, 426

525, 526

CAST • 393, 394, 395, 396, 397, 400, 401, 402, 403, 404, 418,

<binding table reference value type> • 104, 122, 279, 281,

426, 444

288, 294, 299, 525

CATALOG • 428

<binding table type> • 66, 275, 279, 288

CEIL • 348, 426

<binding table variable> • 122, 423, 424

CEILING • 348, 426

<binding table variable definition> • 116, 119, 122, 515, 516

CGT • 127

<binding variable> • 149, 167, 168, 172, 200, 245, 246, 423, CHARACTERISTICS • 106, 107, 426, 528

424, 466

CHARACTER_LENGTH • 347, 400, 401, 402, 403, 426, 472

<binding variable definition> • 51, 116, 119, 515, 516

CHAR_LENGTH • 347, 426

<binding variable definition block> • 51, 116, 117, 118, 119,

172, 515

CLEAR • 428

<binding variable reference> • 17, 126, 128, 129, 130, 151,

CLONE • 428

152, 153, 155, 156, 167, 168, 172, 179, 180, 181, 183, 184, CLOSE • 108, 426

185, 193, 200, 202, 203, 204, 207, 208, 247, 248, 253, 339, COALESCE • 390, 391, 426

345, 467, 478, 515, 520, 523, 524, 525, 554

COLLECT • 250, 252, 254, 255, 426, 522

<binding variable reference list> • 193

COMMIT • 38, 112, 426

binds • 447

CONNECTING • 266, 428

<boolean factor> • 209, 340

CONSTRAINT • 428

<boolean literal> • 410, 415, 420

COPY • 136, 140, 426

<boolean predicand> • 318, 340

COS • 347, 352, 426

<boolean primary> • 340, 341

COSH • 347, 352, 426

<boolean term> • 340

COT • 347, 352, 426

<boolean test> • 340, 341

568

IWD 39075:202y(E)

COUNT • 250, 251, 254, 426

character string types • 75

CREATE • 134, 136, 137, 140, 426

<character string value expression> • 347, 350, 355, 356,

CSMAXL • 282

358, 360, 361

CURRENT_DATE • 366, 367, 426

character strings • 75

CURRENT_GRAPH • 126, 426, 493

child execution context • 44

CURRENT_PROPERTY_GRAPH • 126, 426

<circumflex> • 437

CURRENT_ROLE • 428

closed • 61

CURRENT_SCHEMA • 301, 302, 426

<closed dynamic union type> • 280, 291, 299, 525

CURRENT_TIME • 366, 367, 426

<closed edge reference value type> • 267, 270, 280, 289,

CURRENT_TIMESTAMP • 366, 367, 426

295

CURRENT_USER • 336, 426

<closed graph reference value type> • 279, 288, 294

Cartesian product • 34

closed list value type • 289

calendar date • 21

<closed node reference value type> • 263, 264, 279, 280,

288, 294, 295

<call catalog-modifying procedure statement> • 132, 143

closed record type • 290

<call data-modifying procedure statement> • 144, 159

closed record type R corresponding to a set of property types

<call procedure statement> • 143, 159, 170, 191, 494

PTSET • 485

<call query statement> • 165, 170, 494

collation • 22

canonical column name sequence • 32

<collection value constructor> • 345

<case abbreviation> • 390, 391

<colon> • 223, 314, 329, 382, 436, 437

<case expression> • 69, 70, 345, 390, 391, 392, 480, 482

column name-disjoint • 33

<case operand> • 390, 391

column name-equal • 33

<case specification> • 390, 391, 392

column-combinable • 33

case-normal form • 434

column-comparable • 33

<cast operand> • 393

combined columns • 33

<cast specification> • 68, 77, 345, 393, 394, 395, 397, 405,

combined field types • 73

513

<comma> • 110, 151, 155, 157, 172, 182, 187, 193, 195, 206,

<cast target> • 393

211, 223, 232, 237, 245, 247, 250, 256, 261, 271, 272, 277, catalog and data statement mixing not supported • 114, 337

278, 280, 333, 334, 335, 347, 348, 358, 370, 377, 379, 380,

<catalog binding table parent and name> • 307, 312

385, 390, 436, 437

<catalog graph parent and name> • 136, 139, 304, 312

command • 50

<catalog graph type parent and name> • 137, 140, 142, 306,

<comment> • 431

312

<commercial at> • 411, 436, 437

catalog object • 28

<commit command> • 25, 98, 112, 494

catalog object descriptor • 28

<common logarithm> • 347, 348, 350, 354, 527

catalog object name • 28

<common value expression> • 318, 338

<catalog object parent reference> • 136, 139, 140, 142, 304,

<comp op> • 257, 258, 318, 319, 320, 321, 322

306, 307, 309, 310

<comparison predicand> • 318, 319, 322, 476, 477, 519

<catalog procedure parent and name> • 309, 313

<comparison predicate> • 209, 258, 316, 317, 318, 476, 477

<catalog schema parent and name> • 134, 135, 301

<comparison predicate part 2> • 318, 390

<catalog-modifying procedure specification> • 113, 114,

completion condition • 47

143, 505

<component type> • 281

catalog-modifying side effects • 42

<component type list> • 280, 281, 291, 297

catalog-modifying statement • 52

component types • 67

<ceiling function> • 347, 348, 350, 353, 354, 526

<composite query expression> • 45, 160, 161, 162, 164, 478,

<char length expression> • 347, 350

521

<character representation> • 411, 416

<composite query primary> • 161

character string • 77

<composite query statement> • 114, 116, 160

<character string concatenation> • 355, 356

compressed binding • 447

<character string factor> • 355, 356

compressed path binding • 448

<character string function> • 358

<concatenation operator> • 355, 375, 383, 429, 430

<character string literal> • 410, 415, 417, 420, 429, 433, 434

conditions • 46

<character string primary> • 355, 356

connection exception • 25

<character string type> • 61, 77, 78, 277, 281, 292, 298, 519

<connector pointing right> • 266

569

IWD 39075:202y(E)

<connector undirected> • 266

DEGREES • 347, 352, 426

consistent • 449

DELETE • 157, 426

constitute • 93

DESC • 256, 257, 426

constraining object type • 87

DESCENDING • 256, 257, 426

constructed • 60

DESTINATION • 331, 332, 428

<constructed type> • 277, 280

DETACH • 157, 426

contain • 92

DIFFERENT • 59, 211, 428

contained in • 92

DIRECTED • 150, 266, 267, 328, 428

containing • 92

DIRECTORY • 428

<copy of graph type> • 140

DISTINCT • 161, 162, 163, 179, 180, 183, 186, 187, 250, 251,

<counted shortest group search> • 59, 218, 219, 220, 221,

253, 426, 478

458, 507

DOUBLE • 76, 83, 278, 286, 287, 298, 415, 426, 519

<counted shortest path search> • 59, 218, 219, 221, 458,

DROP • 135, 136, 139, 141, 142, 426

506

DURATION • 76, 85, 279, 371, 373, 400, 401, 403, 413, 418,

<create graph statement> • 132, 136, 138, 494, 511, 528

419, 426

<create graph type statement> • 132, 137, 140, 141, 494,

DURATION_BETWEEN • 86, 321, 370, 426

511, 528

data exception • 35, 69, 70, 147, 148, 149, 150, 153, 154, 156,

<create schema statement> • 132, 134, 494, 527

158, 175, 202, 253, 254, 333, 334, 337, 344, 351, 352, 353, current authorization identifier • 36

354, 357, 361, 362, 364, 367, 368, 371, 372, 373, 375, 377, current execution context • 41, 42

383, 385, 387, 395, 396, 397, 398, 399, 400, 401, 402, 404,

405, 443, 444, 445, 457, 475, 555

current execution outcome • 43

data object • 29

current execution result • 43

data type • 59

current execution stack • 39

<data-modifying procedure specification> • 113, 114, 159,

<current graph> • 126, 127

505

current home graph • 26

data-modifying side effects • 42

current home schema • 26

data-modifying statement • 52

current principal • 36

date • 84

current request context • 36

<date function> • 366, 367

current request outcome • 39

<date function parameters> • 366, 367, 368

current request parameters • 39

<date literal> • 413, 418, 420

current request timestamp • 40

<date string> • 366, 368, 413, 418, 420, 429

current session graph • 36

<date type> • 279, 287

current session parameters • 36

datetime • 85

current session schema • 36

<datetime factor> • 364

current termination flag • 36

<datetime function> • 366, 367, 368

current time zone displacement • 36

<datetime function parameters> • 366, 368

current transaction • 36

<datetime literal> • 413, 418, 420

current transaction access mode • 36

<datetime primary> • 364, 371

current working graph • 40

<datetime string> • 366, 368, 413, 418, 420, 429

current working graph of A • 40

<datetime subtraction> • 370, 371

current working record • 42

<datetime subtraction parameters> • 370

current working schema • 40

<datetime term> • 364, 371, 372

current working schema of A • 40

<datetime type> • 279, 287

current working table • 43

<datetime value expression> • 86, 338, 364, 365, 370, 371,

372, 522

— D —

<datetime value expression 1> • 370, 371

DATA • 428

<datetime value expression 2> • 370, 371

DATE • 76, 84, 279, 366, 367, 368, 400, 402, 403, 404, 413,

<datetime value function> • 39, 364, 366, 367, 368, 369, 522

418, 426

<decimal exact numeric type> • 277, 278, 284, 285

DATETIME • 76, 84, 279, 364, 367, 413, 418, 426

decimal numbers • 76

DAY • 426

decimal types • 76

DEC • 76, 83, 278, 283, 286, 298, 426, 519

declared • 228

DECIMAL • 76, 83, 278, 283, 286, 298, 426, 519

declared names • 75

570

IWD 39075:202y(E)

defining insert element pattern • 233

<duration term 2> • 370, 371

degree of exposure • 214, 228

<duration type> • 279, 287, 288

degree of reference • 200

<duration value expression> • 338, 364, 370, 371, 372, 373,

<delete item> • 157, 158

522

<delete item list> • 157

<duration value expression 1> • 370, 371

<delete statement> • 144, 157, 158, 494

<duration value function> • 370, 373

<delimited binding table name> • 307, 422, 424

<dynamic property value type> • 30, 280, 291, 299, 525

<delimited graph name> • 304, 422, 424

<dynamic union type> • 67, 68, 277, 280, 291, 296, 297

<delimited identifier> • 98, 422, 423, 425, 429, 432, 433,

434, 435, 512, 552

— E —

<delimiter token> • 226, 425, 429, 433

EDGE • 6, 76, 270, 289, 428, 432

dependent object error • 158

EDGES • 59, 428, 432

<dependent value expression> • 57, 250, 251, 252, 253, 339

ELEMENT • 211, 216, 428, 505

<destination node type name> • 266, 267, 269

ELEMENTS • 59, 211, 216, 377, 428, 505

<destination node type reference> • 265, 266, 268

ELEMENT_ID • 406, 426

<destination predicate part 2> • 331, 332, 390, 391, 510

ELSE • 390, 391, 392, 426

<different edges match mode> • 53, 58, 211, 213, 214, 215, END • 390, 391, 408, 426

216, 505

EXACT • 428

different-edges-matched • 214

EXCEPT • 161, 162, 163, 164, 426, 478, 521

<digit> • 398, 413, 414, 415, 419, 436

EXISTING • 428

directed pointing left • 53

EXISTS • 102, 103, 104, 134, 135, 136, 138, 139, 140, 141, directed pointing right • 53

142, 323, 426, 527, 528

<directed predicate> • 316, 317, 328, 510

EXP • 348, 353, 426

<directed predicate part 2> • 328, 390, 391, 510

edge • 235

directionality constraint • 454

<edge bindings or edges> • 211

directly contained in • 92, 93

<edge kind> • 150, 265, 266, 267, 270, 512

directly containing • 93

<edge pattern> • 54, 55, 56, 57, 222, 223, 224, 226, 227, 228, directly contains • 92

230, 231, 241, 242, 243, 452, 453, 454, 507, 508

<directory name> • 301, 422, 423, 470

<edge reference> • 331

division by zero • 344, 351

<edge reference value expression> • 338, 385, 386

<dollar sign> • 422, 436, 437

<edge reference value type> • 269, 279, 280, 281, 289

double approximate numeric type • 83, 287

edge symbol binding • 447

<double colon> • 277, 429, 430

<edge synonym> • 211, 265, 270, 280, 432, 512

<double minus sign> • 429, 430, 432, 435, 512

edge type • 64

<double period> • 301, 303, 429, 430

<edge type definition> • 65, 261, 262, 265, 267, 269, 270,

<double quote> • 411, 416, 417, 436, 437

280, 289, 512

<double quoted character representation> • 411, 415, 416

<edge type filler> • 265, 268

<double quoted character sequence> • 410, 415, 416, 425,

<edge type label set definition> • 265, 267, 268

432

<edge type name> • 261, 265, 267, 268, 269

<double solidus> • 431, 435, 512

<edge type pattern> • 265

<drop graph statement> • 132, 136, 139, 494, 528

<edge type phrase> • 265, 267, 270, 512

<drop graph type statement> • 132, 141, 142, 494, 511, 528

<edge type property type set definition> • 265, 267, 269

<drop schema statement> • 132, 135, 494, 527

edge variable • 228

duration • 21

<edges synonym> • 211, 432

<duration absolute value function> • 373

effective binary precision • 485

<duration factor> • 370, 371

effectively • 93

<duration function> • 373

<element bindings or elements> • 211

<duration function parameters> • 373

<element pattern> • 53, 54, 55, 56, 222, 226, 227, 228, 231,

<duration literal> • 410, 413, 418, 419, 420, 421, 522

232, 452, 453, 454, 508

<duration primary> • 370, 371

<element pattern filler> • 54, 208, 222, 223, 226

<duration string> • 373, 413, 414, 418, 429

<element pattern predicate> • 208, 222, 223, 226

<duration term> • 364, 370, 371

<element pattern where clause> • 54, 56, 201, 223, 226, 228,

231, 447, 508

<duration term 1> • 370

571

IWD 39075:202y(E)

<element property specification> • 208, 223, 232, 233

execution outcome • 45

<element type definition> • 261

execution stack • 41

<element type definition list> • 261

<exists predicate> • 168, 316, 317, 323, 324, 511, 555

<element type name> • 263, 265, 266, 422, 424

<exponent> • 81, 413, 419

<element variable> • 147, 200, 201, 208, 215, 216, 222, 225,

<exponential function> • 347, 348, 349, 352, 354, 527

226, 228, 231, 233, 234, 423, 424, 457, 508, 509

expression • 184

<element variable declaration> • 54, 55, 206, 208, 222, 226,

<extended identifier> • 425

228, 232, 233, 556

exterior variable • 220

<element variable reference> • 203, 206, 328, 329, 331, 333,

<external object reference> • 140, 314, 512

334, 335, 390, 391, 406, 447, 476

external procedure • 50

<element_id function> • 345, 406, 407, 510

extracted path • 448

elementary binding • 447

elementary binding of LET • 447

— F —

<elements function> • 377, 378, 527, 534

FALSE • 340, 399, 410, 420, 426

<else clause> • 390, 391, 392

FILTER • 171, 188, 426

emitting result statement • 388

FINISH • 145, 161, 179, 181, 208, 426

emitting statement • 388

FIRST • 256, 257, 258, 428

empty • 226

FLOAT • 76, 83, 84, 278, 287, 415, 426, 496

empty binding table • 32

FLOAT128 • 76, 83, 278, 287, 298, 426, 514

<empty grouping set> • 247, 248

FLOAT16 • 76, 83, 278, 286, 298, 426, 518

empty list value • 72

FLOAT256 • 76, 83, 278, 287, 298, 426, 514

end bracket symbol binding • 447

FLOAT32 • 76, 83, 278, 286, 298, 426, 518

end subpath symbol • 446

FLOAT64 • 76, 83, 278, 286, 298, 426, 519

<end transaction command> • 38, 98

FLOOR • 348, 426

<endpoint definition> • 265, 266

FOR • 174, 426

endpoint node type not defined in graph type definition • 269

FROM • 187, 358, 359, 360, 363, 426, 527

<endpoint pair definition> • 266, 267, 268, 270, 512

FUNCTION • 428

<endpoint pair definition pointing left> • 266

<factor> • 343, 370, 371

<endpoint pair definition pointing right> • 266

failed • 41

<endpoint pair definition undirected> • 266, 267, 270, 512

failed outcome • 45

equality operation • 476

<field> • 380, 382, 419, 523

<equals operator> • 120, 122, 124, 151, 172, 212, 224, 318,

319, 320, 321, 322, 436, 437, 476, 477

<field list> • 380, 382, 419

<escaped backspace> • 411, 412, 417

<field name> • 245, 300, 367, 368, 373, 382, 422, 424

<escaped carriage return> • 411, 412, 417

field name-disjoint • 72

<escaped character> • 39, 411, 416, 417

field name-equal • 72

<escaped double quote> • 411, 417

<field type> • 275, 280, 290, 296, 300, 523

<escaped form feed> • 411, 412, 417

<field type list> • 280, 290, 300

<escaped grave accent> • 411, 417

field type-combinable • 73

<escaped newline> • 411, 412, 417

field type-comparable • 73

<escaped quote> • 411, 417

<field types specification> • 275, 280, 290, 299, 524

<escaped reverse solidus> • 411, 417

field value • 382

<escaped tab> • 411, 417

field value expression • 382

<exact number suffix> • 398, 412, 415, 421, 517

<fields specification> • 380

exact numbers • 75

<filter statement> • 165, 171, 495, 521

<exact numeric literal> • 81, 398, 412, 413, 415, 419, 421,

<fixed length> • 277, 282, 298, 519

516, 517

fixed length path pattern • 224

<exact numeric type> • 80, 277, 283, 284, 285, 292, 298, 519

<fixed quantifier> • 229, 237, 238, 509

exact numeric types • 75

fixed-length byte string type • 79

exception condition • 47

floating point numbers • 76

<exclamation mark> • 54, 235, 240, 436, 437

<floor function> • 347, 348, 350, 353, 354, 526

executing GQL-request • 35

<focused linear data-modifying statement> • 117, 144, 145, execution context • 42

197, 526

572

IWD 39075:202y(E)

<focused linear data-modifying statement body> • 144, 145,

Feature G020, “Counted shortest group search” • 221, 506,

197

507

<focused linear query and primitive result statement part>

Feature G030, “Path multiset alternation” • 230, 500, 507

• 165, 197

Feature G031, “Path multiset alternation: variable length

<focused linear query statement> • 117, 161, 165, 166, 197, path operands” • 230, 500, 507

526

Feature G032, “Path pattern union” • 230, 500, 507

<focused linear query statement part> • 165, 197

Feature G033, “Path pattern union: variable length path

<focused nested data-modifying procedure specification> •

operands” • 230, 500, 507

144, 198

Feature G035, “Quantified paths” • 230, 507

<focused nested query specification> • 165, 197, 388

Feature G036, “Quantified edges” • 231, 507

<focused primitive result statement> • 165, 197

Feature G037, “Questioned paths” • 231, 507

focused statement • 52

Feature G038, “Parenthesized path pattern expression” •

<fold> • 358, 360, 361

231, 500, 507

<for item> • 174

Feature G039, “Simplified path pattern expression: full

<for item alias> • 174

defaulting” • 243, 500, 507, 508

<for ordinality or offset> • 174, 176, 520

Feature G041, “Non-local element pattern predicates” • 231,

<for statement> • 165, 174, 176, 494, 520

500, 508

<full edge any direction> • 223, 227, 231, 455, 508

Feature G043, “Complete full edge patterns” • 231, 508

<full edge left or right> • 223, 227, 454

Feature G044, “Basic abbreviated edge patterns” • 231, 500,

508

<full edge left or undirected> • 223, 227, 454

Feature G045, “Complete abbreviated edge patterns” • 231,

<full edge pattern> • 54, 55, 223, 226, 231, 454, 508

500, 508

<full edge pointing left> • 150, 223, 227, 231, 454, 508

Feature G046, “Relaxed topological consistency: adjacent

<full edge pointing right> • 223, 227, 231, 454, 508

vertex patterns” • 231, 508

<full edge type pattern> • 265, 268, 270, 512

Feature G047, “Relaxed topological consistency: concise edge

<full edge type pattern pointing left> • 265, 268

patterns” • 231, 508

<full edge type pattern pointing right> • 265, 268

Feature G048, “Parenthesized path pattern: subpath variable

<full edge type pattern undirected> • 265, 270, 512

declaration” • 231, 500, 508

<full edge undirected> • 150, 223, 227, 454

Feature G049, “Parenthesized path pattern: path mode

<full edge undirected or right> • 223, 227, 454

prefix” • 231, 500, 509

Feature G050, “Parenthesized path pattern: WHERE clause”

— G —

• 231, 500, 509

Feature G051, “Parenthesized path pattern: non-local

Feature G002, “Different-edges match mode” • 216, 505

predicates” • 231, 500, 509

Feature G003, “Explicit REPEATABLE ELEMENTS keyword”

Feature G060, “Bounded graph pattern quantifiers” • 238,

• 216, 505

500, 509

Feature G004, “Path variables” • 217, 505

Feature G061, “Unbounded graph pattern quantifiers” • 238,

Feature G005, “Path search prefix in a path pattern” • 217,

500, 509

505

Feature G074, “Label expression: wildcard label” • 236, 509

Feature G006, “Graph pattern KEEP clause: path mode prefix”

Feature G080, “Simplified path pattern expression: basic

• 217, 505

defaulting” • 243, 500, 501, 509

Feature G007, “Graph pattern KEEP clause: path search

Feature G081, “Simplified path pattern expression: full

prefix” • 217, 505

overrides” • 243, 501, 509

Feature G010, “Explicit WALK keyword” • 221, 505

Feature G082, “Simplified path pattern expression: basic

Feature G011, “Advanced path modes: TRAIL” • 221, 505,

overrides” • 243, 501, 510

506

Feature G100, “ELEMENT_ID function” • 407, 510

Feature G012, “Advanced path modes: SIMPLE” • 221, 506

Feature G110, “IS DIRECTED predicate” • 328, 510

Feature G013, “Advanced path modes: ACYCLIC” • 221, 506

Feature G111, “IS LABELED predicate” • 330, 510

Feature G014, “Explicit PATH/PATHS keywords” • 221, 506

Feature G112, “IS SOURCE and IS DESTINATION predicate”

Feature G015, “All path search: explicit ALL keyword” • 221,

• 332, 510

506

Feature G113, “ALL_DIFFERENT predicate” • 333, 510

Feature G016, “Any path search” • 221, 506

Feature G114, “SAME predicate” • 334, 510

Feature G017, “All shortest path search” • 221, 506

Feature G115, “PROPERTY_EXISTS predicate” • 335, 510

Feature G018, “Any shortest path search” • 221, 506

Feature G121, “Grouping in OPTIONAL” • 169, 510

Feature G019, “Counted shortest path search” • 221, 506

Feature G122, “EXISTS predicate: multiple MATCH

statements” • 324, 511

573

IWD 39075:202y(E)

Feature GA00, “Graph with an open graph type” • 138, 496,

Feature GB47, “Exact number in common notation without

501, 511

suffix” • 421, 497, 516

Feature GA01, “Graph with a closed graph type” • 138, 141,

Feature GB48, “Exact number in common notation or as

142, 496, 501, 502, 511

decimal integer with suffix” • 421, 497, 516, 517

Feature GA02, “Graph Type inline specification” • 138, 501,

Feature GB49, “Exact number in scientific notation with

511

suffix” • 421, 497, 517

Feature GA03, “Graph Type like a graph” • 138, 501, 511

Feature GB50, “IEEE 754 floating point operations” • 84, 344,

Feature GA04, “Graph from a source” • 138, 501, 511

504, 534

Feature GA05, “Graph label set changes” • 154, 156, 511, 512

Feature GB51, “8 bit signed integers” • 297, 497, 517

Feature GA07, “Undirected edge patterns” • 31, 65, 223, 270, Feature GB52, “16 bit signed integers” • 297, 497, 517

504, 512

Feature GB53, “32 bit signed integers” • 297, 497, 517

Feature GA08, “Named node types in graph types” • 264, 512

Feature GB54, “64 bit signed integers” • 297, 497, 517

Feature GA09, “Named edge types in graph types” • 270, 512

Feature GB55, “8 bit unsigned integers” • 297, 497, 517

Feature GB00, “Long identifiers” • 435, 512

Feature GB56, “16 bit unsigned integers” • 297, 497, 517

Feature GB01, “Double minus sign comments” • 435, 512

Feature GB57, “32 bit unsigned integers” • 297, 497, 518

Feature GB02, “Double solidus comments” • 435, 512

Feature GB58, “64 bit unsigned integers” • 297, 497, 518

Feature GB10, “Elementary OLAP operations” • 258, 512

Feature GB59, “Small unsigned integers” • 297, 498, 518

Feature GB11, “External object references” • 314, 512

Feature GB60, “Regular unsigned integers” • 298, 498, 518

Feature GB12, “Cast specification” • 405, 513

Feature GB61, “Big unsigned integers” • 298, 498, 518

Feature GB13, “Hexadecimal literals” • 420, 513

Feature GB62, “Specified integer precision” • 298, 518

Feature GB14, “Octal literals” • 420, 513

Feature GB63, “16 bit floats” • 298, 497, 518

Feature GB15, “Binary literals” • 420, 513

Feature GB64, “32 bit floats” • 298, 497, 518

Feature GB20, “128 bit signed integers” • 297, 497, 513

Feature GB65, “64 bit floats” • 298, 497, 518, 519

Feature GB21, “256 bit signed integers” • 297, 497, 513

Feature GB66, “Float synonyms” • 298, 497, 519

Feature GB22, “128 bit unsigned integers” • 298, 497, 513

Feature GB67, “Specified float precision” • 298, 519

Feature GB23, “256 bit unsigned integers” • 298, 497, 513

Feature GB68, “Decimal numeric” • 298, 497, 519

Feature GB24, “128 bit floats” • 298, 497, 513, 514

Feature GB69, “Specified byte string maximum length” • 298,

Feature GB25, “256 bit floats” • 298, 497, 514

519

Feature GB26, “Byte string types” • 298, 514

Feature GB70, “Specified byte string minimum length” • 298,

Feature GB27, “Record types” • 339, 514

519

Feature GB28, “List value types” • 376, 378, 514

Feature GB71, “Specified byte string fixed length” • 298, 519

Feature GB30, “Named procedure calls” • 196, 514

Feature GB72, “Specified character string maximum length”

• 298, 519

Feature GB31, “Path value construction” • 384, 385, 501, 514

Feature GC00, “Multiple graphs in a GQL-transaction” • 114,

Feature GB32, “AT schema clause” • 119, 514

501, 504

Feature GB33, “Binding variable definition block” • 119, 501,

Feature GC01, “Catalog and data statement mixing” • 37, 114,

514, 515

504, 505

Feature GB34, “Graph variables” • 119, 202, 501, 515

Feature GC02, “Universal comparison” • 62, 73, 162, 322, Feature GB35, “Binding table variables” • 119, 202, 501, 515

473, 475, 519

Feature GB36, “Graph parameters” • 205, 501, 515

Feature GC03, “FOR statement” • 176, 501, 519, 520

Feature GB37, “Binding table parameters” • 205, 501, 515

Feature GC04, “FOR statement: WITH ORDINALITY and WITH

Feature GB38, “Graphs as procedure arguments” • 196, 515

OFFSET” • 176, 501, 520

Feature GB39, “Binding tables as procedure arguments” •

Feature GC05, “Advanced linear composition with NEXT” •

196, 515

119, 520

Feature GB40, “Let-binding of variables in expressions” •

Feature GC06, “ORDER BY and page statement: OFFSET

409, 515, 516

clause” • 178, 520

Feature GB41, “Opt-out character escaping” • 420, 516

Feature GC07, “ORDER BY and page statement: LIMIT clause”

Feature GB42, “Procedure-local value variable definitions”

• 178, 520

• 119, 516

Feature GC08, “Complex expressions in sort keys” • 181, 520

Feature GB43, “Approximate number in common notation

Feature GC09, “Pre-projection aliases in sort keys” • 181,

or as decimal integer with suffix” • 421, 497, 516

520

Feature GB44, “Approximate number in scientific notation

Feature GC10, “Aggregate functions in sort keys” • 181, 520

with suffix” • 421, 497, 516

Feature GC11, “GROUP BY clause” • 248, 520

Feature GB45, “Optional float number suffix” • 421, 497, 516

Feature GC12, “Composite query: OTHERWISE” • 164, 520,

Feature GB46, “Optional double number suffix” • 421, 516

521

574

IWD 39075:202y(E)

Feature GC13, “Composite query: UNION” • 164, 521

Feature GE05, “Binding table reference value expressions”

Feature GC14, “Composite query: EXCEPT DISTINCT” • 164,

• 337, 526

501, 521

Feature GE06, “Use Graph Support” • 145, 166, 198, 501, 526

Feature GC15, “Composite query: EXCEPT ALL” • 164, 501,

Feature GF01, “Enhanced numeric functions” • 354, 526

521

Feature GF02, “Trigonometric functions” • 354, 526

Feature GC16, “Composite query: INTERSECT DISTINCT” •

Feature GF03, “Logarithmic functions” • 354, 526, 527

164, 501, 521

Feature GF04, “Enhanced path functions” • 354, 378, 502,

Feature GC17, “Composite query: INTERSECT ALL” • 164,

527

501, 521

Feature GF05, “Multi-character TRIM function” • 363, 527

Feature GC18, “FILTER statement” • 171, 521

Feature GF06, “Explicit TRIM function” • 363, 527

Feature GC19, “LET statement” • 173, 521

Feature GF07, “Byte string TRIM function” • 363, 527

Feature GC20, “Graph pattern yield” • 210, 521, 522

Feature GM01, “Graph schema management” • 134, 135, 502,

Feature GC21, “Advanced aggregate functions: general set

527

functions” • 255, 522

Feature GM02, “Graph schema management exists” • 134,

Feature GC22, “Advanced aggregate functions: binary set

135, 502, 527

functions” • 255, 522

Feature GM03, “Graph type exists” • 141, 142, 502, 527, 528

Feature GC23, “Date and time support” • 298, 365, 369, 421, Feature GM04, “Graph management” • 138, 139, 501, 502,

501, 522

528

Feature GC24, “Durations and temporal arithmetic support”

Feature GM05, “Graph management exists” • 138, 139, 502,

• 298, 372, 421, 501, 522

528

Feature GC25, “SQL datetime and interval formats” • 421,

<GQL language character> • 39, 436, 438

522, 523

GQL source text • 39

Feature GC26, “Updatable graphs” • 145, 502, 523

<GQL special character> • 429, 436

Feature GC27, “Scalar subqueries” • 389, 523

<GQL terminal character> • 436

Feature GC28, “Element-wise group variable operations” •

GQL-catalog • 26

467, 523

GQL-data • 29

Feature GC29, “Horizontal aggregation” • 339, 523

GQL-directory • 27

Feature GD01, “Nested record types” • 273, 300, 382, 502,

523

GQL-directory descriptor • 27

Feature GD02, “List value types” • 299, 379, 523

GQL-directory name • 28

Feature GD03, “Record types” • 299, 381, 498, 502, 523, 524

GQL-implementation • 24

Feature GD04, “Closed record types” • 299, 381, 498, 502,

GQL-object • 29

524

GQL-object type • 59

Feature GD05, “Open record types” • 299, 498, 502, 524

GQL-procedure • 50

Feature GD06, “Path value types” • 299, 384, 501, 502, 524

<GQL-program> • 39, 40, 43, 49, 68, 69, 98, 208, 259, 260

Feature GD07, “Graph reference value types” • 128, 299, 339,

GQL-request context • 39

501, 524

GQL-schema • 28

Feature GD08, “Binding table reference value types” • 128,

GQL-schema name • 28

130, 299, 339, 501, 524, 525

GQL-status object • 46

Feature GD09, “Value type predicate” • 326, 525

GQL-transaction • 37

Feature GD10, “Open dynamic union types” • 299, 498, 502,

GQLSTATUS • 428

525

GRANT • 428

Feature GD11, “Closed dynamic union types” • 299, 498, 502,

GRAPH • 76, 102, 106, 107, 120, 136, 137, 139, 140, 141, 142,

525

261, 279, 288, 338, 428, 529

Feature GD12, “Dynamic property value type” • 299, 525

GROUP • 213, 219, 247, 280, 289, 426

Feature GD13, “Dynamic union types” • 480, 498, 502

GROUPS • 219, 220, 428

Feature GD14, “Explicit value type nullability” • 299, 525

Feature GS01, “Session-local graph parameters” • 105, 503,

GE • 328

528

Feature GE01, “Inline procedure” • 194, 498, 502, 525

Feature GS02, “Session-local binding table parameters” •

Feature GE02, “Inline procedure with implicit nested variable

105, 503, 528

scope” • 194, 498, 502, 525, 526

Feature GS03, “Session-local value parameters” • 105, 503,

Feature GE03, “Inline procedure with explicit nested variable

528

scope” • 194, 498, 502, 526

Feature GS04, “Session: reset all characteristics” • 107, 502,

Feature GE04, “Graph reference value expressions” • 337,

528

526

Feature GS05, “Session: reset schema” • 107, 502, 528, 529

575

IWD 39075:202y(E)

Feature GS06, “Session: reset property graph” • 107, 502,

graph type • 62

529

<graph type like graph> • 136, 137, 138, 140, 511

Feature GS07, “Session: reset timezone” • 107, 502, 529

<graph type name> • 62, 137, 140, 142, 306, 422, 424

Feature GS08, “Session: reset all parameters” • 107, 502, 529

<graph type reference> • 136, 137, 140, 306, 312

Feature GS09, “Session-local graph parameters based on

<graph type source> • 140

subqueries” • 105, 502, 503, 529

<graph type specification> • 261, 279, 288

Feature GS10, “Session-local binding table parameters based

<graph type specification body> • 261, 262, 263, 264, 267,

on subqueries” • 105, 502, 503, 529

268, 269, 270

Feature GS11, “Session-local value parameters based on

graph type violation • 63, 137, 150, 154, 156, 158

subqueries” • 105, 502, 503, 529

<graph variable> • 120, 423, 424

Feature GS12, “Session-local graph parameters based on

<graph variable definition> • 116, 119, 120, 515

simple expressions or references” • 105, 502, 529

<grave accent> • 411, 416, 417, 437

Feature GS13, “Session-local binding table parameters based

on simple expressions or references” • 105, 502, 529, 530

<greater than operator> • 257, 318, 319, 321, 429, 430

Feature GS14, “Session-local value parameters based on

<greater than or equals operator> • 318, 319, 321, 429, 430

simple expressions” • 105, 502, 530

<group by clause> • 62, 179, 180, 182, 183, 184, 185, 187,

Feature GS15, “Explicit transactions” • 101, 502, 530

188, 247, 248, 389, 478, 520

Feature GS16, “Transaction characteristics” • 109, 530

group degree of reference • 56

Graph pattern matching • 52

group list value type • 71

Gregorian calendar • 21

<grouping element> • 184, 247

<general literal> • 410

<grouping element list> • 247

<general logarithm argument> • 347, 348, 352

grouping operation • 478

<general logarithm base> • 347, 348, 352

grouping record • 185

<general logarithm function> • 347, 349, 352, 354, 527

— H —

<general quantifier> • 229, 237, 238, 453, 509

<general set function> • 250, 251, 253, 254

HAVING • 187, 426

<general set function type> • 250, 251, 255, 522

HOME_GRAPH • 304, 426, 493

global object identifier • 29

HOME_PROPERTY_GRAPH • 304, 426

global unconditional singleton • 213

HOME_SCHEMA • 301, 302, 426

globally identifiable • 29

HOUR • 426

globally resolved reference • 30

<having clause> • 187, 188

graph descriptor • 31

<hex digit> • 412, 413, 414, 417, 420, 436, 439

<graph expression> • 45, 102, 104, 105, 114, 120, 121, 126,

<home graph> • 304, 312

127, 128, 136, 137, 140, 187, 189, 197, 338, 504, 524, 529

<graph initializer> • 31, 103, 120, 121

— I —

<graph name> • 136, 139, 304, 305, 422, 423

IF • 102, 103, 104, 134, 135, 136, 138, 139, 140, 141, 142, 426,

<graph pattern> • 52, 55, 56, 57, 58, 59, 188, 200, 201, 202,

527, 528

206, 209, 211, 212, 213, 215, 235, 323, 450, 462, 468

IN • 174, 408, 426

<graph pattern binding table> • 55, 56, 167, 168, 206, 210,

INSERT • 146, 426

228, 468, 522

INSTANT • 428

<graph pattern quantifier> • 54, 214, 222, 227, 229, 237,

INT • 76, 82, 278, 283, 284, 426, 496

238, 240, 242, 509

INT128 • 76, 82, 278, 284, 297, 426, 513

<graph pattern variable> • 55, 423, 424, 468

INT16 • 76, 82, 278, 284, 297, 426, 517

<graph pattern where clause> • 56, 188, 200, 201, 211, 212, INT256 • 76, 82, 278, 284, 297, 426, 513

216, 463

INT32 • 76, 82, 278, 284, 297, 426, 517

<graph pattern yield clause> • 56, 200, 206, 207, 210, 468,

522

INT64 • 76, 82, 278, 284, 297, 426, 517

<graph pattern yield item> • 206

INT8 • 82, 278, 284, 297, 426, 517

<graph pattern yield item list> • 206

INTEGER • 76, 82, 83, 278, 283, 284, 285, 426, 496

<graph reference> • 105, 126, 127, 304, 312, 529

INTEGER128 • 76, 82, 278, 284, 285, 297, 298, 426, 513

<graph reference value expression> • 337, 338, 339, 524, INTEGER16 • 76, 82, 278, 284, 285, 297, 426, 517

526

INTEGER256 • 76, 82, 278, 284, 285, 297, 298, 426, 513

<graph reference value type> • 103, 120, 121, 279, 281, 288, INTEGER32 • 76, 82, 278, 284, 285, 297, 426, 517, 518

299, 524

INTEGER64 • 76, 82, 278, 284, 285, 297, 426, 517, 518

<graph source> • 136, 137, 138, 511

INTEGER8 • 82, 278, 284, 285, 297, 426, 517

576

IWD 39075:202y(E)

INTERSECT • 161, 162, 163, 164, 426, 478, 521

invalid transaction state • 37, 109, 114, 133, 145

INTERVAL • 426

invalid transaction termination • 111, 112

IS • 223, 242, 243, 325, 326, 327, 328, 329, 331, 340, 341, 356, invalid value type • 69, 70, 387, 555

361, 391, 426

invalidated • 35

<identifier> • 174, 175, 179, 180, 182, 184, 185, 187, 208,

<is label expression> • 208, 222, 223, 226

225, 422, 425, 446, 447

<is labeled or colon> • 329

<identifier extend> • 425, 432

<is or colon> • 151, 155, 223, 271

<identifier start> • 425, 432

is the result of NT • 45

identify a path • 74

is the value of NT • 45

immediately contain • 92

implementation-assigned variable names • 233

— K —

<implementation-defined access mode> • 110, 543

KEEP • 212, 213, 428

include • 95

<keep clause> • 211, 212, 213, 217, 505

incoming working record • 43

<key word> • 6, 52, 62, 157, 214, 331, 425, 434

incoming working table • 43

known not nullable • 88

incompatible temporal instant unit groups • 371

<independent value expression> • 250, 252, 253, 254

— L —

inessential • 94

LABEL • 271, 429

inline procedure • 49

LABELED • 329, 429

<inline procedure call> • 143, 159, 170, 191, 192, 193, 194,

525, 526

LABELS • 271, 429

innermost • 93

LAST • 256, 257, 258, 429

<insert edge pattern> • 146, 148, 232, 233, 234

LEADING • 358, 362, 363, 426

<insert edge pointing left> • 232

LEFT • 428

<insert edge pointing right> • 232

LET • 172, 208, 408, 426

<insert edge undirected> • 232

LIKE • 136, 137, 426

insert element pattern • 233

LIMIT • 259, 389, 426

<insert element pattern filler> • 232

LIST • 280, 426

<insert graph pattern> • 146, 232

LN • 348, 353, 426

<insert node pattern> • 146, 147, 149, 232, 233, 234

LOCAL • 76, 84, 85, 279, 364, 367, 418, 426

<insert path pattern> • 146, 147, 232

LOCAL_DATETIME • 366, 367, 368, 402, 403, 426

<insert path pattern list> • 232

LOCAL_TIME • 366, 367, 368, 400, 401, 403, 426

<insert statement> • 144, 146, 233, 494, 556

LOCAL_TIMESTAMP • 366, 367, 426

instant • 21

LOG • 347, 350, 426

integer numbers • 76

LOG10 • 348, 426

integer types • 76

LOWER • 358, 361, 426

integers • 76

LTRIM • 358, 360, 362, 426

interior variable • 220

<label and property set specification> • 232, 233

intermediate results • 94

<label conjunction> • 235, 460

internal object identifiers • 29

<label disjunction> • 235, 460

interval field overflow • 372

<label expression> • 54, 58, 223, 235, 242, 243, 329, 453,

460

invalid argument for natural logarithm • 352

<label factor> • 235, 460

invalid argument for power function • 353

<label name> • 54, 151, 153, 154, 156, 235, 240, 243, 271,

invalid character value for cast • 397, 399, 405

422, 424, 460

invalid datetime function field name • 367, 368

<label name set> • 271

invalid datetime function value • 368

<label negation> • 235, 460

invalid duration format • 404

<label primary> • 235, 460

invalid duration function field name • 373

<label set definition> • 263, 264, 265, 271

invalid group variable value • 202

<label set specification> • 147, 148, 151, 155, 232

invalid number of paths or groups • 457

<label term> • 235, 460

invalid reference • 40, 112, 205, 493

<labeled predicate> • 316, 317, 329, 330, 510

invalid syntax • 47, 158, 253, 357, 361, 398, 399, 418, 443,

<labeled predicate part 2> • 329, 330, 390, 391, 510

444

577

IWD 39075:202y(E)

<left angle bracket> • 240, 280, 431, 437, 438

local time • 85

<left arrow> • 224, 227, 231, 266, 429, 430, 508

<local time function> • 366, 367

<left arrow bracket> • 223, 232, 265, 429, 430

<localdatetime type> • 279, 287

<left arrow tilde> • 224, 227, 240, 429, 430

<localtime type> • 279, 287

<left arrow tilde bracket> • 223, 429, 430

<lower bound> • 225, 227, 237, 453

left boundary variable • 220

<left brace> • 113, 151, 167, 223, 237, 261, 272, 280, 323, 380,

— M —

437

MATCH • 167, 230, 323, 426

<left bracket> • 280, 379, 385, 437, 438

MAX • 250, 251, 252, 254, 426, 477

<left minus right> • 224, 227, 429, 430

MIN • 250, 251, 252, 254, 426, 477

<left minus slash> • 239, 241, 430

MINUTE • 426

<left paren> • 167, 193, 195, 222, 224, 231, 232, 235, 240,

MOD • 347, 426

247, 250, 263, 266, 271, 277, 278, 323, 333, 334, 335, 340, MONTH • 426

345, 347, 348, 358, 359, 366, 370, 373, 377, 390, 393, 406,

437, 438, 508

malformed path • 383, 385, 396

<left tilde slash> • 239, 241, 430

<mantissa> • 81, 398, 413, 414, 419

left to right • 53

match • 216

<length expression> • 347, 349

<match mode> • 59, 211, 213, 216, 505

<less than operator> • 257, 318, 319, 320, 321, 430

<match statement> • 56, 165, 167, 168, 187, 188, 189, 494

<less than or equals operator> • 318, 319, 321, 430, 431

<match statement block> • 167, 168, 169, 323, 324, 510, 511

<let statement> • 165, 172, 173, 208, 494, 521

material • 61

<let value expression> • 345, 408, 409, 516

material variant • 61

<let variable definition> • 172

<max length> • 277, 280, 281, 282, 289, 298, 519

<let variable definition list> • 172, 408

<min length> • 277, 282, 298, 519

<limit clause> • 177, 178, 187, 189, 259, 389, 520

minimum node count • 227

<linear catalog-modifying statement> • 114, 116, 117, 132

minimum path length • 224

<linear data-modifying statement> • 114, 116, 144, 145, 207

<minus left bracket> • 223, 224, 232, 265, 430, 431

<linear query statement> • 117, 161, 164, 165, 207, 388

<minus sign> • 223, 224, 227, 231, 240, 343, 344, 364, 370,

412, 419, 437, 438, 508

<list concatenation> • 375

<minus slash> • 224, 239, 241, 430, 431

list data, right truncation • 253, 254, 375, 396

<modulus expression> • 347, 351, 354, 526

<list element> • 379, 419

most specific static value type • 60

list element error • 377

<multi-character trim function> • 358, 360, 363, 527

<list element list> • 379, 419, 534

multi-path binding • 450

list element type • 71

multiple assignments to a graph element property • 149, 150,

<list literal> • 410, 414, 419, 420

153

list of graph elements bound to ER • 464

multiset alternation operand • 225

<list primary> • 375

<multiset alternation operator> • 54, 222, 239, 425, 429

list value • 71

<list value constructor> • 345, 379, 523

— N —

<list value constructor by enumeration> • 379, 414, 419,

420, 534

NEXT • 116, 189, 190, 427

<list value expression> • 174, 338, 375, 376, 377, 480, 482,

NFC • 327, 358, 360, 429

514

NFD • 358, 429

<list value expression 1> • 375

NFKC • 358, 429

<list value function> • 375, 377, 378, 514

NFKD • 358, 429

<list value type> • 71, 72, 280, 289, 295, 296, 299, 523

NO • 168, 182, 183, 429

<list value type name> • 280, 289, 379

NODE • 6, 76, 264, 288, 429, 432

<list value type name synonym> • 280

NODETACH • 157, 427

<literal> • 219, 336, 397, 399, 400, 401, 402, 404, 405, 410, NORMALIZE • 356, 358, 361, 427

419

NORMALIZED • 327, 356, 361, 429

local • 56

NOT • 102, 103, 104, 134, 136, 138, 140, 141, 319, 320, 325, local datetime • 84

326, 327, 328, 329, 331, 340, 341, 391, 427, 527, 528

<local datetime function> • 366, 367

NOTHING • 428

NULL • 62, 281, 325, 390, 391, 392, 393, 395, 414, 418, 427

578

IWD 39075:202y(E)

NULLIF • 390, 391, 427

<non-reserved word> • 425, 428, 434

NULLS • 256, 257, 258, 427

<normal form> • 77, 271, 272, 281, 282, 283, 286, 290, 327, NUMERIC • 428

358, 360

name • 55, 423

normal form of LVT • 290

named graph • 32

<normalize function> • 77, 358, 360, 361

named graph type • 63

<normalized predicate> • 77, 316, 317, 327

named procedure • 49

<normalized predicate part 2> • 327

<named procedure call> • 143, 159, 170, 191, 192, 195, 196,

<not equals operator> • 318, 319, 321, 322, 430, 431, 476,

514

477

named procedure descriptor • 49

<not null> • 277, 278, 279, 280, 281, 299, 525

named subobjects • 95

<null literal> • 410, 414, 418, 420

natural join • 34

<null ordering> • 256, 257, 258, 512

<natural logarithm> • 347, 348, 349, 352, 354, 527

<null predicate> • 316, 317, 325

naturally joinable • 33

<null predicate part 2> • 325, 390

negative duration • 22

nullability • 88

<nested binding table query specification> • 129, 130, 525

nullable • 61

<nested data-modifying procedure specification> • 113, 144,

nullable variant • 61

145, 198

number of edge labels below supported minimum • 148, 156,

<nested graph query specification> • 126, 127, 128, 524

269

<nested graph type specification> • 136, 137, 138, 140, 141, number of edge labels exceeds supported maximum • 149, 154

261, 262, 511

number of edge properties exceeds supported maximum • 149,

<nested procedure specification> • 113, 143, 159, 170, 193

154, 270, 444

<nested query specification> • 113, 126, 129, 130, 165, 179,

<number of groups> • 219, 457

187, 189, 197, 323, 388, 389

number of node labels below supported minimum • 147, 156,

<newline> • 417, 431, 432, 433, 434

264

<next statement> • 116, 117, 118, 119, 520

number of node labels exceeds supported maximum • 148,

no data • 47, 48, 489

154, 264

<no escape> • 410, 411, 416, 420, 516

number of node properties exceeds supported maximum • 148,

154, 264

node • 235

<number of paths> • 218, 219, 457

<node pattern> • 54, 55, 57, 220, 222, 224, 226, 227, 228,

231, 235, 452, 453, 454, 508

numbers • 75

<node reference> • 331

<numeric primary> • 343, 344

<node reference value expression> • 338, 385, 386

<numeric type> • 79, 277, 283, 287

<node reference value type> • 279, 281, 288

numeric types • 75

node symbol binding • 447

<numeric value expression> • 84, 250, 251, 252, 338, 343,

344, 347, 348, 349, 350, 351, 352, 353, 359, 377, 504

<node synonym> • 263, 280, 432

<numeric value expression base> • 348, 353

node type • 63

<numeric value expression dividend> • 347, 351

<node type definition> • 64, 261, 262, 263, 264, 268, 269,

280, 288, 512

<numeric value expression divisor> • 347, 351

<node type filler> • 263, 266, 268, 269

<numeric value expression exponent> • 348, 353

<node type label set definition> • 263, 264

<numeric value function> • 343, 347

<node type name> • 261, 263, 268, 269

— O —

<node type pattern> • 263

<node type phrase> • 263, 264, 512

OCTET_LENGTH • 347, 427

<node type property type set definition> • 263, 264

OF • 136, 140, 331, 427

<node type reference> • 266, 267

OFFSET • 174, 175, 176, 260, 427

node variable • 228

ON • 428

<non-delimited identifier> • 98, 423, 425, 432, 433, 434, ONLY • 110, 133, 145, 429

435, 512, 552

OPEN • 76, 136, 279, 280, 427

<non-delimiter token> • 14, 425, 433

OPTIONAL • 167, 168, 191, 192, 427

<non-parenthesized value expression primary> • 340, 345,

OR • 136, 140, 141, 319, 340, 341, 392, 427

390, 391

ORDER • 249, 427

<non-parenthesized value expression primary special case>

ORDINALITY • 174, 175, 176, 429

• 131, 345

579

IWD 39075:202y(E)

OTHERWISE • 161, 163, 164, 427, 521

POWER • 348, 350, 427

object base type name • 87

PRECISION • 76, 83, 278, 286, 287, 427

<object expression primary> • 126, 129, 131

PROCEDURE • 428

<object name> • 310, 422, 423

PRODUCT • 428

<object name or binding variable> • 126, 127, 128, 129, 130, PROJECT • 428

422, 423, 524, 525

PROPERTY • 76, 102, 106, 107, 120, 136, 139, 140, 142, 261,

<octal digit> • 413, 414, 436

279, 280, 288, 338, 429, 529

of a node type • 64

PROPERTY_EXISTS • 335, 427

of an edge type • 65

<parameter> • 205, 312, 336, 515

<of graph type> • 136, 137, 138, 511

<parameter name> • 102, 103, 106, 107, 205, 336, 422, 424, of the graph type • 63

425

of the result of NT • 45

<parameter value specification> • 336

of the value of NT • 45

parent directory • 27

<offset clause> • 177, 178, 187, 189, 260, 520

<parenthesized boolean value expression> • 340

<offset synonym> • 260

<parenthesized label expression> • 235, 460

omitted result • 45

<parenthesized path pattern expression> • 15, 54, 55, 56,

open • 61

57, 58, 201, 213, 214, 215, 216, 219, 220, 222, 224, 225,

227, 228, 229, 230, 231, 446, 447, 449, 450, 452, 453, 457,

<open dynamic union type> • 280, 291, 299, 525

463, 507, 508, 509

<open edge reference value type> • 280, 289, 295

<parenthesized path pattern where clause> • 56, 200, 201,

<open graph reference value type> • 279, 288, 293, 294

216, 224, 230, 231, 458, 463, 509

<open graph type> • 136, 137, 138, 511

<parenthesized value expression> • 131, 345

<open node reference value type> • 279, 280, 288, 294

path binding • 447

open record type • 290

<path concatenation> • 55, 222, 224, 226, 227, 229, 449, operand of a grouping operation • 478

452, 453, 455

operand of an equality operation • 476

path data, right truncation • 383

operand of an ordering operation • 477

<path element list> • 74, 385

operation • 41

<path element list start> • 385

<opt typed binding table initializer> • 102, 103, 122

<path element list step> • 385

<opt typed graph initializer> • 102, 103, 120

<path factor> • 222, 229, 452, 453, 455

<opt typed value initializer> • 102, 104, 124

<path length expression> • 347, 350, 354, 527

<optional match statement> • 167, 168, 182

<path mode> • 53, 58, 213, 214, 218, 219, 220, 221, 229,

<optional operand> • 167, 168

449, 450, 505, 506

<order by and page statement> • 165, 177, 178, 179, 181,

<path mode prefix> • 212, 217, 218, 219, 220, 224, 229, 231,

389, 495, 520

449, 505, 509

<order by clause> • 177, 179, 181, 187, 189, 249

<path multiset alternation> • 55, 57, 220, 222, 224, 225, 227, ordered • 32

229, 230, 455, 507

ordering operation • 477

<path or paths> • 218, 219, 221, 506

<ordering specification> • 256

<path or subpath variable> • 423, 424

<other digit> • 436, 439

<path pattern> • 15, 52, 53, 55, 56, 57, 58, 59, 211, 212, 213,

214, 215, 217, 220, 221, 228, 230, 448, 450, 452, 456, 457,

<other language character> • 39, 436, 438

463, 465, 505

outermost • 93

<path pattern expression> • 53, 54, 55, 211, 212, 213, 222, outgoing working record • 43

224, 225, 226, 227, 228, 229, 230, 231, 451, 452, 455, 508

outgoing working table • 43

<path pattern list> • 209, 211, 212, 213, 446, 451, 456

— P —

<path pattern prefix> • 53, 211, 212, 213, 217, 218, 219, 220,

505

PARAMETER • 106, 427

<path pattern union> • 55, 56, 57, 58, 220, 222, 224, 225, PARAMETERS • 106, 107, 427, 529

227, 229, 230, 452, 455, 507

PARTITION • 428

path pattern union operand • 225

PATH • 218, 219, 281, 385, 427

<path primary> • 222, 225, 226, 227, 229, 230, 231, 452,

PATHS • 218, 219, 220, 427

453, 455, 507

PATH_LENGTH • 347, 427

<path search prefix> • 53, 58, 59, 212, 217, 218, 220, 456,

457, 505

PERCENTILE_CONT • 250, 254, 427, 477

<path term> • 55, 222, 225, 226, 228, 229, 452, 453, 455

PERCENTILE_DISC • 250, 255, 427, 477

580

IWD 39075:202y(E)

path value • 74

<property key value pair> • 146, 148, 149, 152, 153, 154,

<path value concatenation> • 383, 384, 514

208, 223, 233

<path value constructor> • 345, 385, 514

<property key value pair list> • 148, 149, 151, 208, 223, 233

<path value constructor by enumeration> • 385

<property name> • 147, 148, 149, 151, 152, 154, 155, 156,

<path value expression> • 338, 347, 350, 377, 378, 383, 384,

208, 223, 233, 273, 335, 386, 422, 424

524

<property reference> • 56, 345, 386

<path value expression 1> • 383

<property source> • 386

<path value primary> • 383

<property type definition> • 272, 273, 523

<path value type> • 74, 281, 289, 296, 299, 524

<property type definition list> • 272, 273

<path variable> • 200, 201, 202, 212, 214, 225, 423, 424

<property type set definition> • 263, 264, 265, 269, 272

<path variable declaration> • 53, 56, 206, 211, 212, 213, 217,

<property value type> • 273, 274

505

<property_exists predicate> • 316, 317, 335, 510

<path variable reference> • 204, 206

peers • 258

— Q —

<percent> • 235, 437, 438

QUERY • 428

<period> • 81, 151, 155, 301, 302, 310, 386, 398, 413, 415,

<quantified path primary> • 56, 57, 214, 222, 225, 226, 227,

437, 438

229, 230, 231, 450, 452, 453, 455, 507

phrase binding table NT obtained as a copy of the binding

<query conjunction> • 161, 162, 163, 164, 521

table T without the columns identified by NAMES • 33

<query specification> • 113, 114, 170

<plus sign> • 237, 238, 343, 344, 364, 370, 412, 437, 438, 509

query statement • 52

possibly nullable • 88

<question mark> • 55, 222, 240, 437, 438

possibly variable length path pattern • 224

<questioned path primary> • 55, 222, 224, 225, 226, 227,

<power function> • 347, 348, 350, 353, 354, 527

229, 231, 452, 453, 455, 507

<pre-reserved word> • 428

<quote> • 411, 412, 416, 417, 437, 438

precede • 258

<precision> • 80, 278, 283, 284, 285, 286, 287, 298, 518,

— R —

519

R restricted to the fields identified by FS • 74

predefined • 61

R without the fields identified by FS • 74

<predefined parameter> • 336

R1 amended with R2 • 73

<predefined schema reference> • 301, 302

RADIANS • 347, 352, 427

<predefined type> • 277, 281

READ • 109, 110, 133, 145, 429

<predefined type literal> • 410

REAL • 76, 83, 278, 287, 298, 427, 519

<predicate> • 77, 316, 317, 340

RECORD • 280, 380, 396, 427, 493

preferred name • 75

RECORDS • 428

primary • 29

REFERENCE • 428

primary object • 29

RELATIONSHIP • 6, 76, 270, 289, 429, 432

<primitive catalog-modifying statement> • 132

RELATIONSHIPS • 429, 432

<primitive data-modifying statement> • 144

REMOVE • 155, 427

<primitive query statement> • 165

RENAME • 428

<primitive result statement> • 117, 118, 119, 144, 145, 161, REPEATABLE • 59, 211, 216, 429, 505

165, 179, 197, 388

REPLACE • 136, 140, 141, 427

<procedure argument> • 195, 196, 515

RESET • 106, 107, 427, 528, 529

<procedure argument list> • 195

RETURN • 168, 172, 182, 183, 189, 190, 323, 427

<procedure body> • 51, 92, 105, 113, 114, 116, 119, 180,

199, 251, 514, 515, 520, 529

REVOKE • 428

<procedure call> • 143, 159, 170, 191

RIGHT • 428

procedure logic • 48

ROLLBACK • 38, 111, 427

<procedure name> • 309, 422, 424

RT restricted to the fields identified by FS • 74

<procedure reference> • 49, 143, 159, 170, 195, 309, 313

RT without the fields identified by FS • 74

<procedure specification> • 49, 98, 113, 114

RT1 amended with RT2 • 73

production rule • 90

RTRIM • 358, 360, 362, 427

<program activity> • 98, 100

read-only transaction • 133, 139, 145, 158, 175, 337, 364,

371, 395

projected field value • 463

real approximate numeric type • 83, 287

581

IWD 39075:202y(E)

record • 72

<right arrow> • 224, 227, 231, 266, 430, 431, 508

record data, field missing • 445

right boundary variable • 220

record data, field unassignable • 445

<right brace> • 113, 151, 167, 223, 237, 261, 272, 280, 323,

record fields do not match • 396

380, 437, 438

<record literal> • 410, 414, 419, 420

<right bracket> • 280, 379, 385, 437, 438

<record type> • 60, 72, 273, 280, 290, 296, 299, 300, 380,

<right bracket minus> • 223, 224, 232, 265, 430, 431

523, 524

<right bracket tilde> • 223, 232, 265, 430, 431

<record value constructor> • 345, 366, 368, 373, 380, 381,

<right paren> • 167, 193, 195, 222, 224, 231, 232, 235, 240,

382, 414, 419, 420, 523, 524

247, 250, 263, 266, 271, 277, 278, 323, 333, 334, 335, 340,

<record value expression> • 338, 339, 386, 514

345, 347, 348, 358, 359, 366, 370, 373, 377, 390, 393, 406, reduced match • 216

437, 438, 508

reference base type name • 87

right to left • 53

<reference parameter> • 301, 304, 306, 307, 309, 312

<rollback command> • 38, 98, 111, 494

reference value • 34, 87

— S —

<reference value expression> • 338

<reference value type> • 61, 87, 277, 279, 281

SAME • 334, 427

reference value, invalid base type • 443

SCHEMA • 102, 106, 107, 134, 135, 427, 529

reference value, invalid constrained type • 443

SECOND • 427

reference value, referent deleted • 35

SELECT • 187, 427

referenced binding variable • 200

SESSION • 102, 106, 107, 108, 427, 528, 529

referenced path • 74

SET • 102, 151, 427

referent • 11, 30

SHORTEST • 213, 218, 219, 220, 429

regular approximate numeric type • 83, 287

SIGNED • 76, 82, 83, 278, 283, 284, 285, 297, 427, 496, 513,

517

regular decimal exact numeric type • 83, 286

SIMPLE • 58, 59, 218, 221, 429, 449, 506

<regular identifier> • 55, 126, 128, 129, 130, 422, 423, 425,

524, 525

SIN • 347, 352, 427

regular language of BNT • 452

SINH • 347, 352, 427

regular list value type • 71

SKIP • 260, 427

regular result • 45

SMALL • 76, 82, 278, 283, 284, 285, 427

regular variant • 71

SMALLINT • 76, 82, 278, 283, 284, 427

<relative catalog schema reference> • 301, 302, 312

SOURCE • 331, 332, 429

<relative directory path> • 301, 302, 303

<SQL-datetime literal> • 413, 418, 421, 523

<remove item> • 155, 156, 512

<SQL-interval literal> • 414, 418, 419, 421, 523

<remove item list> • 155

SQRT • 254, 348, 427

<remove label item> • 155, 156, 512

START • 109, 427

<remove property item> • 155, 156

STDDEV_POP • 250, 254, 255, 427, 522

<remove statement> • 144, 155, 494

STDDEV_POP • 252

<repeatable elements match mode> • 211, 213

STDDEV_SAMP • 250, 252, 254, 255, 427, 522

representation with reduced precision • 22

STRING • 75, 78, 277, 281, 400, 401, 402, 403, 404, 427, 496

representative form • 432

STZV • 103

request parameters • 39

SUBSTRING • 428

request source • 39

SUM • 250, 252, 254, 427

<reserved word> • 425, 434

<same predicate> • 316, 317, 334, 476, 510, 556

restrictive • 220

satisfied • 315

<result> • 45, 390, 391, 392

satisfies • 460

<result expression> • 390, 392

<scale> • 80, 278, 284, 285, 286, 287, 298, 518, 519

<return item> • 179, 180, 182, 183, 184, 186, 389, 478

<schema name> • 134, 135, 301, 302, 422, 423

<return item alias> • 179, 180, 181, 182, 183, 184, 520, 556

<schema reference> • 102, 103, 199, 301, 310, 312

<return item list> • 172, 180, 182, 183

<search condition> • 54, 56, 58, 77, 171, 187, 188, 209, 212,

216, 223, 224, 244, 315, 316, 356, 361, 390, 392, 458, 462

<return statement> • 179, 181, 182, 183, 388, 478, 495, 520

<searched case> • 390, 391, 392

<return statement body> • 182

<searched when clause> • 390, 391, 392

<reverse solidus> • 411, 412, 416, 417, 437, 438

secondary • 29

<right angle bracket> • 240, 280, 430, 437

582

IWD 39075:202y(E)

secondary object • 29

signed 8-bit integer type • 82, 284

<select graph match> • 187, 188, 189

signed big integer type • 82, 284

<select graph match list> • 187, 188, 189

<signed binary exact numeric type> • 278, 284, 297, 298,

<select item> • 187, 478

513, 517, 518

<select item alias> • 187

<signed decimal integer> • 81, 413

<select item list> • 187, 188

signed exact numbers • 76

<select query specification> • 187, 189

signed exact numeric types • 76

<select statement> • 117, 165, 187, 388, 478, 495

<signed numeric literal> • 397, 410, 412, 419, 420

<select statement body> • 187, 188

signed regular integer type • 82, 284

selective • 220

signed small integer type • 82, 284

<semicolon> • 437, 438

signed user-specified integer type • 285

separable • 449

signed user-specified integer types • 82

<separated identifier> • 422, 425

simple • 53

<separator> • 224, 343, 410, 411, 412, 414, 415, 416, 417,

<simple Latin letter> • 436

431, 433

<simple Latin lower-case letter> • 434, 436, 439

<session activity> • 98

<simple Latin upper-case letter> • 434, 436, 439, 489

<session activity command> • 98

<simple case> • 69, 390, 391

<session close command> • 35, 98, 100, 108, 494

<simple catalog-modifying statement> • 132

session command • 50

<simple comment> • 431, 433, 435, 512

<session reset arguments> • 106

<simple comment character> • 431, 432, 433

<session reset command> • 98, 106

<simple comment introducer> • 224, 431

<session set binding table parameter clause> • 102, 103,

<simple data-accessing statement> • 144, 145

105, 528, 529, 530

<simple data-modifying statement> • 118, 119, 144, 145,

<session set command> • 98, 102, 103

197, 523

<session set graph clause> • 102, 104, 494

<simple directory path> • 301, 302, 303, 470

<session set graph parameter clause> • 102, 103, 104, 105,

<simple linear data-accessing statement> • 144, 197

528, 529

<simple linear query statement> • 165, 197

<session set parameter clause> • 102, 103, 104, 494

<simple match statement> • 167, 168

<session set parameter name> • 102, 103

<simple query statement> • 144, 165

<session set schema clause> • 102, 103, 104, 494

<simple when clause> • 390, 391

<session set time zone clause> • 102, 104, 494

<simplified concatenation> • 239, 241, 242

<session set value parameter clause> • 102, 104, 105, 528,

<simplified conjunction> • 239, 240, 241, 242

529, 530

<simplified contents> • 239, 240, 241, 243

session-modifying side effects • 41

<simplified defaulting any direction> • 223, 239, 243, 508,

<set all properties item> • 151, 152, 153, 154

509

<set item> • 151, 152, 153, 154, 511

<simplified defaulting left> • 239, 243, 508, 509

<set item list> • 151

<simplified defaulting left or right> • 239

<set label item> • 151, 152, 153, 154, 511

<simplified defaulting left or undirected> • 239

set of local matches to BNT • 452

<simplified defaulting right> • 239, 243, 508, 509

<set operator> • 161, 162, 163

<simplified defaulting undirected> • 239

<set property item> • 151, 152, 153

<simplified defaulting undirected or right> • 239

<set quantifier> • 161, 179, 180, 182, 183, 187, 250, 251,

<simplified direction override> • 240, 241, 242, 243, 509

252, 253

<simplified factor high> • 239, 240

<set statement> • 144, 151, 494

<simplified factor low> • 239, 240, 242

<set time zone value> • 102, 103

<simplified multiset alternation> • 239, 241, 242

shall • 93

<simplified negation> • 240, 241, 243

<shortest path search> • 218, 219, 458

<simplified override any direction> • 223, 240, 243, 509,

<sign> • 343, 370, 412, 413, 419

510

signed 128-bit integer type • 82, 284

<simplified override left> • 240, 242, 243, 509, 510

signed 16-bit integer type • 82, 284

<simplified override left or right> • 240, 243

signed 256-bit integer type • 82, 284

<simplified override left or undirected> • 240, 242

signed 32-bit integer type • 82, 284

<simplified override right> • 240, 243, 509, 510

signed 64-bit integer type • 82, 284

<simplified override undirected> • 240, 242

583

IWD 39075:202y(E)

<simplified override undirected or right> • 240, 243

<string value function> • 355, 358

<simplified path pattern expression> • 222, 239, 240, 241,

subpath symbol binding • 447

243, 508

<subpath variable> • 224, 225, 228, 423, 424

<simplified path union> • 239, 242

<subpath variable declaration> • 54, 56, 224, 225, 228, 231,

<simplified primary> • 240, 243

452, 508

<simplified quantified> • 240, 241, 242

successful • 41

<simplified questioned> • 240, 241, 242

successful completion • 47, 48, 489

<simplified secondary> • 240, 242

successful outcome • 45

<simplified term> • 239, 242

supported property value type • 30

<simplified tertiary> • 240, 242

symbols • 447

simply contained in • 92, 93

syntactically resolved reference • 30

simply containing • 93

syntax error or access rule violation • 40, 47, 98, 135, 205, simply contains • 92

264, 269, 270, 302, 305, 306, 308, 309, 418, 470, 493

<single quoted character representation> • 411, 415, 416

— T —

<single quoted character sequence> • 410, 415, 416

<single-character trim function> • 358, 360, 363, 527

TABLE • 76, 102, 122, 275, 288, 338, 429

single-node path value • 74

TAN • 347, 352, 427

singleton degree of reference • 56

TANH • 347, 352, 427

<slash minus> • 224, 239, 241, 430, 431

TEMP • 208, 222, 228, 429

<slash minus right> • 239, 241, 430, 431

TEMPORAL • 428

<slash tilde> • 239, 241, 430, 431

THEN • 390, 391, 392, 427

<slash tilde right> • 239, 241, 430, 431

TIME • 76, 84, 85, 102, 106, 107, 279, 367, 413, 418, 427, 529

<solidus> • 301, 310, 343, 344, 370, 437, 438

TIMESTAMP • 279, 413, 427

sort direction • 257

TIMEZONE • 279, 429

<sort key> • 179, 180, 181, 256, 257, 477, 520

TO • 266, 429

<sort specification> • 32, 256, 257, 258

TRAIL • 58, 59, 213, 214, 218, 221, 429, 449, 506

<sort specification list> • 249, 256, 257, 477

TRAILING • 358, 362, 363, 427

<source node type name> • 266, 267, 268, 269

TRANSACTION • 109, 429

<source node type reference> • 265, 266, 268

TRIM • 61, 358, 359, 360, 377, 427

<source predicate part 2> • 331, 332, 390, 391, 510

TRUE • 323, 340, 399, 410, 420, 427

<source/destination predicate> • 316, 317, 331, 332, 510

TYPE • 136, 137, 140, 141, 142, 261, 263, 265, 429

<space> • 320, 360, 412, 417, 433, 434, 436, 437

TYPED • 277, 427

specified by • 92

<temporal duration type> • 279, 293, 298, 522

specify • 92

<temporal instant type> • 85, 279, 293, 298, 522

<square root> • 347, 348, 350, 354, 526

<temporal literal> • 410, 413, 421, 522

standard description • 46

<temporal type> • 277, 279, 287

<standard digit> • 436, 439, 489

<term> • 343, 370, 371

standard-defined classes • 489

<tilde> • 224, 227, 240, 266, 437, 438

standard-defined features • 96

<tilde left bracket> • 223, 232, 265, 430, 431

standard-defined subclasses • 489

<tilde right arrow> • 224, 227, 430, 431

start bracket symbol binding • 447

<tilde slash> • 239, 241, 430, 431

<start transaction command> • 37, 38, 98, 109, 494, 530

time • 21, 85

<statement> • 114, 116, 117, 118, 119, 388

<time function> • 366, 367, 368

<statement block> • 51, 116, 117

<time function parameters> • 366, 367, 368

statement completion unknown • 25, 135, 253, 254, 344, 351,

<time literal> • 413, 418, 420

352, 353, 354, 396, 397, 444

time of day • 21

static type • 60

time scale • 21

status • 45

time shift • 21

status description • 46

<time string> • 366, 368, 413, 418, 420, 430

strict interior variable • 220

<time type> • 279, 287

<string length> • 359

<token> • 224, 425, 433

<string literal character> • 411, 416

trail • 53

<string value expression> • 102, 103, 327, 338, 355, 356

<transaction access mode> • 36, 110

584

IWD 39075:202y(E)

<transaction activity> • 98, 101, 114, 530

<unicode 4 digit escape value> • 412

<transaction characteristics> • 109, 110, 530

<unicode 6 digit escape value> • 412

transaction command • 50

<unicode escape value> • 411, 412, 417

<transaction mode> • 109, 110

unit binding table • 32

transaction resolution unknown • 25, 269, 400, 401, 402, 404

unit binding table type • 67

transaction rollback • 25, 112

unit record type • 72

transaction-modifying side effects • 42

unordered • 32

transient • 87

unsigned 128-bit integer type • 82, 285

<trigonometric function> • 347, 349, 351, 352, 354, 526

unsigned 16-bit integer type • 82, 285

<trigonometric function name> • 347, 351

unsigned 256-bit integer type • 82, 285

<trim byte string> • 359, 362

unsigned 32-bit integer type • 82, 285

<trim character string> • 358, 360, 361, 362

unsigned 64-bit integer type • 82, 285

trim error • 361, 362

unsigned 8-bit integer type • 82, 285

<trim function> • 358

unsigned big integer type • 83, 285

<trim list function> • 377

<unsigned binary exact numeric type> • 278, 284, 285, 297,

<trim operands> • 358

298, 513, 517, 518

<trim source> • 358, 360, 361, 362

<unsigned binary integer> • 412, 413, 414, 420, 513

<trim specification> • 358, 359, 360, 362, 363

<unsigned decimal in common notation> • 412, 413, 421,

<truth value> • 340, 341

516, 517

truth values • 75

<unsigned decimal in scientific notation> • 412, 413, 414,

421, 516, 517

<typed> • 120, 122, 124, 136, 273, 277, 300, 326

<unsigned decimal integer> • 81, 278, 412, 413, 414, 415,

— U —

421, 516, 517

unsigned exact numbers • 76

UBIGINT • 76, 83, 278, 283, 285, 298, 427, 518

unsigned exact numeric types • 76

UINT • 76, 82, 83, 278, 283, 285, 298, 427, 518

<unsigned hexadecimal integer> • 398, 412, 413, 414, 420, UINT128 • 76, 82, 278, 285, 298, 427, 513

513

UINT16 • 76, 82, 278, 285, 297, 427, 517

<unsigned integer> • 81, 219, 237, 277, 336, 398, 412, 414, UINT256 • 76, 82, 278, 285, 298, 427, 513

419

UINT32 • 76, 82, 278, 285, 297, 427, 518

<unsigned integer specification> • 59, 218, 219, 259, 260,

UINT64 • 76, 82, 278, 285, 297, 427, 518

336, 337

UINT8 • 82, 278, 285, 297, 427, 517

<unsigned literal> • 336, 410

UNDIRECTED • 150, 266, 267, 270, 429, 512

<unsigned numeric literal> • 397, 410, 412, 425

UNION • 161, 162, 163, 164, 427, 478, 521

<unsigned octal integer> • 412, 413, 414, 420, 513

UNIQUE • 428

unsigned regular integer type • 82, 285

UNIT • 428

unsigned small integer type • 82, 285

UNKNOWN • 340, 410, 420, 427

unsigned user-specified integer type • 285

UNSIGNED • 76, 82, 83, 278, 283, 285, 297, 298, 427, 513, unsigned user-specified integer types • 83

517, 518

<unsigned value specification> • 336, 345

UPPER • 358, 361, 427

<upper bound> • 229, 237, 238, 453, 509

USE • 189, 197, 427

<use graph clause> • 40, 45, 52, 114, 144, 165, 197, 198, 504, USMALLINT • 76, 82, 278, 283, 285, 427

526

unbounded quantifier • 238

use of visually confusable identifiers • 98, 302, 305, 306, 308,

<unbroken accent quoted character sequence> • 410, 411,

309, 333, 334, 337, 399, 405, 470

415, 416

user-defined • 60

<unbroken character string literal> • 410, 413, 414, 415, user-specified approximate numeric type • 287

416, 418, 420

user-specified approximate numeric types • 83

<unbroken double quoted character sequence> • 410, 411,

user-specified decimal exact numeric type • 286

415, 416

user-specified decimal exact numeric types • 83

<unbroken single quoted character sequence> • 410, 411,

415, 416

— V —

unconditional singleton scope index • 213

VALUE • 102, 124, 172, 280, 388, 427

<underscore> • 413, 414, 432, 434, 437, 438

VALUES • 428

undirected • 53

VARBINARY • 75, 79, 277, 282, 427

585

IWD 39075:202y(E)

VARCHAR • 75, 78, 277, 281, 427, 496

YEAR • 428

VARIABLE • 126, 127, 129, 130, 131, 427

YIELD • 206, 245, 428

VERTEX • 6, 76, 264, 288, 429, 432

<yield clause> • 116, 118, 188, 195, 196, 245

<value expression> • 45, 56, 57, 67, 68, 69, 70, 105, 124, 125,

<yield item> • 245, 246

147, 148, 149, 151, 152, 153, 157, 158, 172, 180, 181, 195,

<yield item alias> • 245, 246

196, 209, 223, 233, 250, 251, 253, 256, 257, 318, 319, 320,

<yield item list> • 245

337, 338, 339, 345, 368, 379, 382, 390, 392, 393, 394, 395,

<yield item name> • 245, 246

408, 419, 462, 466, 477, 478, 515, 520, 523, 526, 530, 555

<value expression primary> • 127, 129, 130, 131, 325, 326,

— Z —

338, 343, 345, 355, 364, 370, 371, 375, 383

<value initializer> • 104, 124, 408

ZONE • 102, 106, 107, 429, 529

<value query expression> • 345, 388, 389, 523

ZONED • 76, 84, 279, 364, 367, 418, 428

<value specification> • 88, 105, 336, 337, 529, 530

ZONED_DATETIME • 366, 367, 368, 369, 404, 428

<value type> • 59, 104, 124, 274, 277, 280, 281, 289, 291,

ZONED_TIME • 366, 367, 368, 369, 401, 402, 428

300, 326, 393, 481

zoned datetime • 84

<value type predicate> • 326, 525

zoned time • 84

<value type predicate part 2> • 326, 390, 525

<value variable> • 124, 172, 408, 423, 424

<value variable definition> • 116, 124, 172

<variable> • 422, 424

variable quantifier • 238

<variable scope clause> • 193, 194, 526

variable-length byte string type • 79

<verbose binary exact numeric type> • 278

<vertical bar> • 54, 222, 235, 239, 281, 437, 438, 481

visually confusable • 78

— W —

WALK • 58, 214, 218, 219, 220, 221, 429, 450, 505

WHEN • 390, 391, 392, 427

WHERE • 171, 209, 212, 223, 224, 230, 244, 427, 463

WITH • 174, 175, 176, 279, 427

WITHOUT • 279, 429

WRITE • 109, 110, 429

warning • 47, 48, 139, 142, 399, 405, 489

<when operand> • 390, 391

<when operand list> • 390, 391

<where clause> • 146, 151, 155, 157, 171, 182, 187, 188, 191,

244

<whitespace> • 356, 361, 396, 397, 399, 400, 401, 402, 403,

404, 405, 416, 431, 433, 443

<wildcard label> • 54, 235, 236, 460, 509

with an intervening instance of • 92

without an intervening instance of • 92

word • 447, 448

working graph • 40

working object • 40

working schema • 40

— X —

XOR • 340, 341, 427

— Y —

586

Editor’s Notes for IWD 39075:202y(E)

Introduction

Editor’s Notes

Some possible problem and language opportunities have been observed with the specifications contained in this

document. Further contributions to this list are welcome. Deletions from the list (resulting from change proposals

that correct the problems or from research indicating that the problems do not, in fact, exist) are even more welcome.

Because of the dynamic nature of this list (problems being removed because they are solved, new problems being

added), each problem or opportunity has been assigned a "fixed" number. These numbers do not change from draft

to draft.

Editor’s Notes (Introduction) Notes–1

Editor’s Notes for IWD 39075:202y(E)

Possible Problems

Possible Problems: Major Technical

GQL-000 The following Possible Problem has been noted:

Severity: major technical

Reference:

Note At: None.

Source: Your humble Editors.

Possible Problem:

In the body of the Working Draft, there occasionally appears a point that requires particular$

attention, highlighted thus:

** Editor’s Note (number 74) **

Text of the problem.

Solution:

None provided with comment.

Notes–2 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Language Opportunities

GQL-003 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.10.2, “Procedures”, Subclause 15.3, “<named procedure call>” .

Note At: Editor’s Note number 4, Editor’s Note number 26.

Source: Editors.

Language Opportunity:

Bindings for host languages should be defined. This should include calling GQL procedures from

other languages, e.g., Java, C++, Python, and calling functions and/or procedure, which are written

in another language, from with GQL .

Solution:

None provided with comment.

GQL-004 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Clause 12, “Catalog-modifying statements” .

Note At: Clause 12, “Catalog-modifying statements” , Editor’s Note number 13.

Source: Editors.

Language Opportunity:

The GQL schema and meta-graph need to be defined together with the statements to manipulate

it.

Solution:

None provided with comment.

GQL-005 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: All Access Rule sections.

Note At: None.

Source: Editors, W12-012, BER-040R3.

Language Opportunity:

The Security Model for GQL and related concepts such as roles need to be defined.

Solution:

None provided with comment.

GQL-011 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Clause 21, “Lexical elements” .

Note At: Editor’s Note number 65, Editor’s Note number 50, Editor’s Note number 12.

Source: Editors.

Editor’s Notes (Language Opportunities) Notes–3

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Language Opportunity:

SQL pays a lot of attention as to whether an expression is deterministic or not, as this has con-

sequences for its use in constraints. If GQL is to have a schema for graphs that includes constraints,

then this will also need considerable attention.

Solution:

None provided with comment.

GQL-012 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 19.3, “<comparison predicate>”, Subclause 22.12, “Equality operations” ,

Subclause 22.13, “Ordering operations”.

Note At: Editor’s Note number 48, Editor’s Note number 70, Editor’s Note number 71.

Source: Editors, WG3:W21-058.

Language Opportunity:

Consider explicit support for additional collations other than UCS_BASIC and UNICODE (e.g., case

insensitive variants, use of alternative collation tables).

Solution:

None provided with comment.

GQL-017 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 14.11, “<return statement>”, Subclause 14.12, “<select statement>” ,

Subclause 16.17, “<group by clause>” , Subclause 16.19, “<aggregate function>” , Subclause 20.5, “<value

expression primary>”.

Note At: Editor’s Note number 41, Editor’s Note number 22, Editor’s Note number 23, Editor’s Note

number 40, Editor’s Note number 40, Editor’s Note number 51.

Source: Editors.

Language Opportunity:

Aggregation would benefit from being improved for the needs of GQL:

—

Revisit the set of provided aggregation functions in light of existing products and market needs

(e.g., add TIMES or graph-specific aggregation functions).

—

Provide means to better control how aggregation functions behave on empty inputs (no rows),

e.g., by allowing the user to specify a default value or default failure behavior for aggregation

on empty inputs.

—

Allow aggregation to scope over whole subqueries (partition by), possibly taking advantage

of using fixed variables as implicit grouping keys and supporting the evaluation of aggregation

functions over the incoming working table in every statement.

See also Language Opportunity GQL-186 .

Solution:

None provided with comment.

GQL-025 The following Language Opportunity has been noted:

Severity: Language Opportunity

Notes–4 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Reference: Subclause 16.10, “<path pattern expression>” .

Note At: Editor’s Note number 36.

Source: SXM-052.

Language Opportunity:

Path pattern union is not defined using left recursion. SXM-052 believed that it should be possible

to support left recursion but declined to do so for expediency. It is a Language Opportunity to support

left recursion.

Linked to Language Opportunity PGQ-019 .

Solution:

None provided with comment.

GQL-030 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.6.2, “Transaction demarcation” , and others.

Note At: Editor’s Note number 3.

Source: Editors.

Language Opportunity:

Currently transaction demarcation is defined such that any failure within a GQL-request procedure

will cause a rollback attempt. Rollback on failure may not be the best option here. Consider an

application that has multiple procedure invocations within a transaction context where the first N

procedures succeed but procedure n+1 fails. It would be preferable to decide in the application

logic whether to commit or rollback, e.g., by using a session level configuration mechanism or by

providing options to transaction demarcation commands.

Solution:

None provided with comment.

GQL-032 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.8, “<string value function>” .

Note At: Editor’s Note number 57, Editor’s Note number 59, Editor’s Note number 58.

Source: Editors.

Language Opportunity:

SQL, Cypher, and possibly other property graph query languages have various styles of regular

expression substring functions as well as other possibly relevant string value functions that GQL

currently is missing. It is a Language Opportunity to add functionality equivalent to at least that of

SQL to GQL.

Solution:

None provided with comment.

GQL-034 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.14, “<simplified path pattern expression>” .

Editor’s Notes (Language Opportunities) Notes–5

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Note At: Editor’s Note number 39.

Source: MMX-060.

Language Opportunity:

It has been proposed that a macro name may be a <simplified primary> in a <simplified path pattern

expression>.

Linked to Language Opportunity PGQ-035 .

Solution:

None provided with comment.

GQL-035 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 13.2, “<insert statement>” .

Note At: Editor’s Note number 14.

Source: MMX-047.

Language Opportunity:

Discussion paper MMX-047 suggests the addition of a “Time To Live” option, which would require

specified graph elements be deleted after a certain time to save storage space.

Solution:

None provided with comment.

GQL-036 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.10, “<path pattern expression>” .

Note At: Editor’s Note number 35 (SR 8)).

Source: W01-014.

Language Opportunity:

It may be possible to permit nested quantifiers. WG3:W01-014 contained a discussion of a way to

support aggregates at different depths of aggregation if there are nested quantifiers.

Linked to Language Opportunity PGQ-036 .

Solution:

None provided with comment.

GQL-044 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 22.3, “Evaluation of a <path pattern expression>”.

Note At: Editor’s Note number 67.

Source: W04-009R1.

Language Opportunity:

It may be possible to enforce implicit joins of unconditional singletons exposed by a <path concat-

enation> as part of the GRs for <path concatenation>. This was discussed in a SQL/PG ad hoc Notes–6 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

meeting on September 8, 2020. It was decided not to attempt that change as part of WG3:W04-

009R1, leaving it as a future possibility.

Linked to Language Opportunity PGQ-047 .

Solution:

None provided with comment.

GQL-051 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.10, “<path pattern expression>” .

Note At: Editor’s Note number 38.

Source: W04-009R1.

Language Opportunity:

WG3:W04-009R1 recognized that a graph query may have a sequence of MATCH clauses, with the

bindings of one MATCH clause MC1 visible in all subsequent MATCH clauses in the same invocation

of <graph table> , and that it should be permissible to reference such variables in any <parenthesized

path pattern where clause> simply contained in a subsequent MATCH clause MC2. The relevance

of this LO to GQL needs to be investigated.

Linked to Language Opportunity PGQ-051 .

Solution:

None provided with comment.

GQL-052 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.9, “<path pattern prefix>” .

Note At: Editor’s Note number 29.

Source: W04-009R1.

Language Opportunity:

The ability to specify “cheapest” queries (analogous to SHORTEST but minimizing the sum of costs

along a path) is desirable.

Linked to Language Opportunity PGQ-052 .

Solution:

None provided with comment.

GQL-053 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.9, “<path pattern prefix>” .

Note At: Editor’s Note number 32.

Source: W04-009R1.

Language Opportunity:

In addition to SHORTEST GROUP, it has been proposed to support SHORTEST [ k ] WITH TIES, with

the semantics to return the first k matches (where k defaults to 1) when sorting matches in

Editor’s Notes (Language Opportunities) Notes–7

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

ascending order on number of edges, and also return any matches that have the same number of

edges as the last of the k matches. This is the semantics of WITH TIES in Subclause 7.17, “<query

expression>” in SQL/Foundation.

Linked to Language Opportunity PGQ-053 .

Solution:

None provided with comment.

GQL-054 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: No specific location.

Source: W04-009R1, W09-031.

Language Opportunity:

WG3:W04-009R1 believed it should be possible to support nested selectors using recursion but did

not undertake that. It is a Language Opportunity to support nested selectors.

Linked to Language Opportunity PGQ-054 .

Solution:

None provided with comment.

GQL-055 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: No specific location.

Source: W04-009R1, W09-031.

Language Opportunity:

WG3:W04-009R1 believed it should be possible to support selectors within quantifiers with a finite

upper bound, but did not undertake that. (This comment applies to a static upper bound, not dynamic,

since we are forbidding multiple selectors within a restrictor.) It is a Language Opportunity to

support selectors within quantifiers with a finite upper bound.

Linked to Language Opportunity PGQ-055 .

Solution:

None provided with comment.

GQL-056 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.9, “<path pattern prefix>” .

Note At: Editor’s Note number 33.

Source: W04-009R1.

Language Opportunity:

With more work, it is possible to recognize when a node variable is declared uniformly in the first

or the last position in every operand of a <path pattern union> . However, WG3:W04-009R1 declined

Notes–8 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

to make the effort because it is easy for the user to factor out such a node pattern. For example,

instead of

(X) -> (Y) | (X) -> (Z)

the user can write

(X) ( -> (Y) | -> (Z))

Thus, a more general definition of right or left boundary variable is possible.

Linked to Language Opportunity PGQ-056 .

Solution:

None provided with comment.

GQL-057 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.8, “<graph pattern>” .

Note At: Editor’s Note number 28.

Source: W04-009R1, W09-031.

Language Opportunity:

It has been suggested that it might be possible to treat the <path pattern prefix> specified in <keep

clause> as merely providing a default <path pattern prefix> rather than a mandatory one for each

<path pattern>. Whereas nested <path pattern prefix> is prohibited, this may be a feasible avenue of growth. On the other hand, perhaps a less definitive verb than KEEP may be appropriate when

specifying a default <path pattern prefix>.

Linked to Language Opportunity PGQ-049 .

Solution:

None provided with comment.

GQL-161 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.21, “<limit clause>” .

Note At: Editor’s Note number 43.

Source: Editors.

Language Opportunity:

Additional, commonly supported subclauses of <limit clause> should be added.

Solution:

None provided with comment.

GQL-162 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.22, “<offset clause>”.

Note At: Editor’s Note number 44.

Source: Editors.

Language Opportunity:

Editor’s Notes (Language Opportunities) Notes–9

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Additional, commonly supported subclauses of <offset clause> should be added.

Solution:

None provided with comment.

GQL-163 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 14.9, “<order by and page statement>”.

Note At: Editor’s Note number 20.

Source: Editors, W15-020.

Language Opportunity:

Additional support for PARTITION BY, WITH TIES, WITH OFFSET, and WITH ORDINALITY should

be considered.

Solution:

None provided with comment.

GQL-168 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 15.1, “<call procedure statement> and <procedure call>”.

Note At: Editor’s Note number 25.

Source: Editors.

Language Opportunity:

« WG3:UTC-117 »

Stand-alone calls need to be added (standalone calls are short-hand syntax for just calling a single

GQL-procedure). Such support should consider using the 9075 “period” terminology rather than

the 8601 “interval” terminology.

Solution:

None provided with comment.

GQL-169 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 15.1, “<call procedure statement> and <procedure call>”.

Note At: Editor’s Note number 24, Editor’s Note number 15, Editor’s Note number 16, Editor’s Note

number 17, Editor’s Note number 18, Editor’s Note number 21.

Source: Editors.

Language Opportunity:

The addition of optional <where clause> s should be considered throughout the document.

Solution:

None provided with comment.

GQL-175 The following Language Opportunity has been noted:

Severity: Language Opportunity

Notes–10 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Reference: Subclause 20.2, “<value expression>” , Subclause 20.14, “<list value function>”.

Note At: None.

Source: Editors.

Language Opportunity:

It needs to be decided which additional value functions on collections and graph elements should

be included.

Solution:

None provided with comment.

GQL-176 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.6, “<numeric value function>”.

Note At: Editor’s Note number 52, Editor’s Note number 53, Editor’s Note number 54, Editor’s Note

number 55, Editor’s Note number 56.

Source: Editors.

Language Opportunity:

It needs to be decided which additional numeric value functions should be included.

Solution:

None provided with comment.

GQL-177 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 19.2, “<predicate>”.

Note At: Editor’s Note number 45, Editor’s Note number 46, Editor’s Note number 47.

Source: Editors.

Language Opportunity:

It needs to be decided which additional predicates should be included.

Solution:

None provided with comment.

GQL-181 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: No specific location.

Source: W08-018, W09-031.

Language Opportunity:

W08-018 prohibited a selector contained in a <path pattern union> or <path multiset alternation>

PU, but believed that if PU is at the “top” of a path pattern, and a selector is at the “top” of an operand

of PU, then this scenario does not violate compositionality. It is a Language Opportunity to permit

this scenario.

Linked to Language Opportunity PGQ-060 .

Editor’s Notes (Language Opportunities) Notes–11

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Solution:

None provided with comment.

GQL-185 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.15.3.6, “Temporal types” .

Note At: Editor’s Note number 7.

Source: Editors.

Language Opportunity:

Support for system-versioned graphs should be added.

Solution:

None provided with comment.

GQL-186 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 15.1, “<call procedure statement> and <procedure call>” , Subclause 16.19,

“<aggregate function>” .

Note At: Editor’s Note number 42.

Source: Editors.

Language Opportunity:

Support for grouped procedure calls needs to be specified. A grouped procedure call invokes a

procedure for each partition of the binding table and combines (concatenates) all results received.

Partitions may be determined by a user-specified grouping key or perhaps sets of grouping keys.

See also Language Opportunity GQL-017 .

Solution:

A possible solution might all a syntactic form like:

CALL proc(args) PER key YIELD results

or perhaps rely on per-query block partitioning:

PER key

...

CALL proc(args) YIELD results

...

GQL-194 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.8, “<graph pattern>” , Subclause 22.2, “Machinery for graph pattern matching”.

Note At: Editor’s Note number 27.

Source: Editors.

Language Opportunity:

Projection and handling of subpath variables needs to be specified.

Solution:

Notes–12 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

None provided with comment.

GQL-196 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.10, “<datetime value function>”.

Note At: Editor’s Note number 60.

Source: Editors.

Language Opportunity:

Cypher contains additional datetime functions. It is a Language Opportunity to add equivalent

functionality to GQL.

Solution:

None provided with comment.

GQL-197 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.12, “<duration value function>” .

Note At: Editor’s Note number 61.

Source: Editors.

Language Opportunity:

Cypher contains additional duration functions. It is a Language Opportunity to add equivalent

functionality to GQL.

Solution:

None provided with comment.

GQL-212 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.10, “<path pattern expression>” .

Note At: Editor’s Note number 34.

Source: W09-017, W09-036.

Language Opportunity:

In the BNF for <full edge any direction>, the delimiter tokens <~[ ]~> have been suggested as a synonym for -[ ]- as part of Feature GA07, “Undirected edge patterns”. The synonym for the

<abbreviated edge pattern> - (<minus sign> ) would then be <~>, the synonym for <simplified

defaulting any direction> would use the delimiter tokens <~/ /~> and the synonym for <simplified

override any direction> would use the tokens <~ and > surrounding a label as originally proposed

in MMX-060. These synonyms might be considered to make the table of edge patterns more harmo-

nious and internally consistent.

Linked to Language Opportunity PGQ-062 .

Solution:

None provided with comment.

GQL-213 The following Language Opportunity has been noted:

Editor’s Notes (Language Opportunities) Notes–13

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Severity: Language Opportunity

Reference: Subclause 19.2, “<predicate>”.

Note At: None.

Source: W10-017.

Language Opportunity:

SQL/Foundation defines five operators that use XQuery regular expression syntax:

LIKE_REGEX

OCCURRENCES_REGEX

POSITION_REGEX

SUBSTRING_REGEX

TRANSLATE_REGEX

These REGEX operators could be very useful and should be considered.

Solution:

None provided with comment.

GQL-217 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.15.3.5, “Numeric types”.

Note At: Editor’s Note number 6.

Source: W12-029.

Language Opportunity:

Support for approximate numeric types that are compatible with the arithmetic formats for which

ISO/IEC 60559:2020/IEEE 754:2019 defines interchange formats should be added. This needs to

include provisions for infinity values and literals, NaN values and literals, rounding, casting, error

handling, data types, the modification of existing operations, and related conformance features.

Solution:

None provided but see paper W11-015 for a discussion.

GQL-218 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.15.3.5, “Numeric types”.

Note At: None.

Source: W12-029.

Language Opportunity:

In SQL, it is implementation-defined whether the loss of non-zero bytes due to truncation raises an

exception or not. This should be reconsidered by GQL.

Solution:

None provided with comment.

GQL-219 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 3.9, “Value terms and definitions”.

Notes–14 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Note At: Editor’s Note number 2.

Source: W12-019.

Language Opportunity:

In a system implementing both SQL and GQL, how would GQL consume a SQL table? Besides

providing syntax, a solution to this LO has to answer the question how GQL should support mapping

SQL tables with multiple columns with the same name into GQL?

Solution:

None provided with comment.

GQL-221 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.23, “<cast specification>” .

Note At: None.

Source: W13-012

Language Opportunity:

Many programming languages support converting boolean types to numerics where True converts

to 1 (one) and False converts to 0 (zero). Such conversions could be useful to GQL users.

Solution:

None provided with comment.

GQL-222 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.23, “<cast specification>” .

Note At: None.

Source: W13-012

Language Opportunity:

Many databases and programming languages include individual type conversion functions such as:

—

toBoolean

—

toInteger

—

toFloat

—

toString

If there is a need at some point to add individual conversion functions to GQL, they could be specified

as syntactic transformations to the appropriate CAST function.

Solution:

None provided with comment.

GQL-223 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.23, “<cast specification>” .

Editor’s Notes (Language Opportunities) Notes–15

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Note At: None.

Source: W13-012

Language Opportunity:

In ISO/IEC 9075-2:2023, <cast specification> includes an optional FORMAT <cast template> that allows a user to provide a format when converting a datetime to a character string. A similar capability could be useful in GQL.

Solution:

None provided with comment.

GQL-224 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.23, “<cast specification>” .

Note At: None.

Source: W13-012

Language Opportunity:

In a CAST expression, it could be useful to specify what the result should be if the CAST would oth-

erwise raise an exception. For example:

CAST ('abc' AS INT ON EXCEPTION NULL)

CAST ('abc' AS INT ON EXCEPTION 0)

CAST (a.prop1 AS INT ON EXCEPTION a.prop2)

An ON EXCEPTION capability would be particularly useful when loading large volumes of data.

Solution:

None provided with comment.

GQL-225 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.23, “<cast specification>” .

Note At: None.

Source: W13-012

Language Opportunity:

<cast specification> does not currently support converting byte strings to character strings or

character strings to byte strings (using some well-known encoding). Such a capability might be

useful.

Solution:

None provided with comment.

GQL-226 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.23, “<cast specification>” .

Note At: None.

Notes–16 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Source: Editors.

Language Opportunity:

The ability to extract individual time scale components from temporal instances and duration would

be useful and might be used to simplify the specification of <cast specification>. SQL has an EXTRACT

function which satisfies a similar need and openCypher in its CIP2015-08-06 Date and Time spe-

cification has defined the ability to extract all individual time scale components.

Solution:

None provided with comment.

GQL-227 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 12.3, “<drop schema statement>” .

Note At: None.

Source: W13-024.

Language Opportunity:

<drop schema statement> only allows dropping a schema if it does not contain any catalog object.

More user convenience could potentially be added to the <drop schema statement> by including a

new option for cascading drop statements or by developing a general invalidation model for catalog

objects.

Solution:

None provided with comment.

GQL-229 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: W15-018.

Language Opportunity:

Pattern Macros could provide powerful capabilities for GQL Users by providing a multi-use template.

A Pattern Macro could be created in several places:

—

As a preamble to a single query that lasts for the life of the query.

—

As a catalog object that can be created, used in multiple queries, and lasts until explicitly

dropped.

This capability should be considered for a future GQL version.

Solution:

None provided with comment.

GQL-230 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.18, “<order by clause>” .

Editor’s Notes (Language Opportunities) Notes–17

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Note At: None.

Source: W15-020.

Language Opportunity:

WITH ORDINALITY, WITH OFFSET, WITH GROUP ORDINALITY and WITH GROUP OFFSET to be

added.

Solution:

None provided with comment.

GQL-231 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 19.10, “<source/destination predicate>” .

Note At: No specific location.

Source: WG3:W15-022.

Language Opportunity:

The <source/destination predicate> is expressed as a predicate about the node, while it is most

often used to pose questions about the edge. If an alternative form of these predicates was available

that put the edge as the first operand, this predicate would be more useful in combination with

<simple case>.

Linked to Language Opportunity PGQ-071 .

Solution:

None provided with comment.

GQL-233 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 22.6, “Applying bindings to evaluate an expression”.

Note At: Editor’s Note number 68.

Source: MMX-035r2, WG3:W13-018.

Language Opportunity:

The bindings of a group reference flatten nested lists. This may be acceptable for SQL aggregates,

which have no support for nested groupings, but may be inadequate to fully capture the semantics

of a group reference in a graph pattern. MMX-035r2 section 4.1 “Desynchronized lists” pointed out

a problem with reducing group variables to lists: two lists may be interleaved, but the reduction to

separate lists can lose this information. The example given is

( (A:Person) -[:SPOUSE]-> ()

| (B:Person) -[:FRIEND]-> () ){3}

A solution may find matches to A and B in any order. With separate lists of matches of A and B, it

will not be easy to reconstruct the precise sequence of interleaved matches to A and B.

A similar problem can arise with nested quantifiers. MMX-035r2 section 4.2 “Nested quantifiers”

gives this example:

( (C1:CORP) (-[:TRANSFERS]->(B:BANK))*

-[:TRANSFERS]-> (C2:CORP) )*

Notes–18 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

With this pattern, there can be 0 or more bindings to B between any two consecutive bindings to

C1 and C2. With just independent lists of matches to C1, B and C2, it will not be easy to determine

which bindings to B lie between which bindings to C1 and C2.

Linked to Language Opportunity PGQ-069 .

Solution:

None provided with comment.

GQL-234 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 14.2, “<composite query expression>” .

Note At: None.

Source: W15-017.

Language Opportunity:

Subclause 14.2, “<composite query expression>”, General Rules are written to compose the binding

tables generated by pairs of queries. There might be a benefit in expanding the GRs to also support

operations directly on graphs such that GQL gains the capability to do, e.g., union of graphs.

Solution:

None provided with comment.

GQL-235 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: W16-038.

Language Opportunity:

The ability to create, reference, and drop constants as catalog objects could be very useful when

constructing GQL queries. This capability should be considered for a future GQL version.

Solution:

None provided with comment.

GQL-237 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: W16-041.

Language Opportunity:

The ability to query a catalog to identify graphs with particular characteristics would be useful.

Solution:

None provided with comment.

Editor’s Notes (Language Opportunities) Notes–19

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

GQL-241 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 17.5, “<property type set definition>” .

Note At: None.

Source: W19-019R1.

Language Opportunity:

Several future extensions of the GQL language (See Language Opportunity GQL-241 , Language

Opportunity GQL-242 , Language Opportunity GQL-243 ) depend on properties being directly

referenceable as graph elements in their own rights. Currently properties only exist (from a schema

point of view) as members in property type sets attached to either nodes or edges. A definition

point of a property type as such is needed. Such a graph element will be necessary for future concept

relationships between properties and, e.g., other properties, other edges and other nodes than the

ones that the current property set “belongs to”.

Solution:

None provided with comment.

GQL-242 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Language Opportunity GQL-241 .

Note At: None.

Source: W19-019R1.

Language Opportunity:

Functional dependencies in a more specific manner (minimizing the need for inferencing in query

planning) require explicit concept relationships between properties (e.g., keys and non-keys) for

dealing with uniqueness and key formation.

Solution:

None provided with comment.

GQL-243 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Language Opportunity GQL-241 .

Note At: None.

Source: W19-019R1.

Language Opportunity:

Versioning (of both data and metadata) and timeline handling require explicit concept relationships

between properties (e.g., keys and non-keys) for dealing with uniqueness and key formation.

Solution:

None provided with comment.

GQL-244 The following Language Opportunity has been noted:

Severity: Language Opportunity

Notes–20 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Reference: Language Opportunity GQL-241 .

Note At: None.

Source: W19-019R1.

Language Opportunity:

Coexistence between LPG(s) of different breeds and also RDF require meta transformations between

concept systems describing: a source graph type, a “universal” abstract graph type system and a

target graph type. This requires GQL properties to be directly referenceable as such in combinations

with other graph elements, including other properties, edges and relationships.

Solution:

None provided with comment.

GQL-245 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: W19-017.

Language Opportunity:

Allowing the bundling of multiple requests into one is useful for reducing network round trips. This

should include the capability for returning multiple results to the client in one round trip.

Solution:

One possibility is to introduce a new top-level Subclause <GQL-multi-request> next to <GQL-pro-

gram> .

GQL-246 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:W20-012.

Language Opportunity:

The ability to create and drop named stored procedures is a powerful capability when building

applications in a GQL database. This capability should be considered for a future GQL version and

should include both mandatory and optional parameters.

The last Informal Working Draft that contained a sketch of the functionality (deleted by W20-012)

was 39075_1IWD21-GQL_2022-02 which is available here: https://sd.iso.org/documents/-

ui/#!/browse/iso/iso-iec-jtc-1/iso-iec-jtc-1-sc-32/iso-iec-jtc-1-sc-

32-wg-3/library/6/16656391_LL/16656048_LL/39075_1IWD21-GQL_2022-02.pdf

Solution:

None provided with comment.

GQL-247 The following Language Opportunity has been noted:

Severity: Language Opportunity

Editor’s Notes (Language Opportunities) Notes–21

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Reference: No specific location.

Note At: None.

Source: WG3:W20-012.

Language Opportunity:

The ability to create, invoke, and drop named, stored queries is a powerful capability when building

applications in a GQL database. This capability should be considered for a future GQL version.

The last Informal Working Draft that contained a sketch of the functionality (deleted by W20-012)

was 39075_1IWD21-GQL_2022-02 which is available here: https://sd.iso.org/documents/-

ui/#!/browse/iso/iso-iec-jtc-1/iso-iec-jtc-1-sc-32/iso-iec-jtc-1-sc-

32-wg-3/library/6/16656391_LL/16656048_LL/39075_1IWD21-GQL_2022-02.pdf

Solution:

None provided with comment.

GQL-248 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:W20-013.

Language Opportunity:

The ability to create, call, and drop named, stored functions is a powerful capability when building

applications in a GQL database. This capability should be considered for a future GQL version and

should include both mandatory and optional parameters. As part of the consideration, there should

be a discussion of whether GQL should support the definition and/or calling of pure functions,

impure functions, or both.

The last Informal Working Draft that contained a sketch of the functionality (deleted by W20-013)

was 39075_1IWD21-GQL_2022-02 which is available here: https://sd.iso.org/documents/-

ui/#!/browse/iso/iso-iec-jtc-1/iso-iec-jtc-1-sc-32/iso-iec-jtc-1-sc-

32-wg-3/library/6/16656391_LL/16656048_LL/39075_1IWD21-GQL_2022-02.pdf

Solution:

None provided with comment.

GQL-250 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.3.4, “Graphs”.

Note At: None.

Source: WG3:RKE-040.

Language Opportunity:

GQL should be extended to support subgraphs for the most needed use cases.

Paper WG3:RKE-046 Subgraphs of property graphs provides some commentary on this topic.

Solution:

Notes–22 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

None provided with comment.

GQL-279 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.11.5, “References to graph pattern variables”.

Note At: Editor’s Note number 5.

Source: WG3:BER-031.

Language Opportunity:

It is a Language Opportunity to support references to subpath variables, for example, in <graphical

path length function> , or a TOTAL_COST function once CHEAPEST is defined.

Linked to Language Opportunity PGQ-085 .

Solution:

None provided with comment.

GQL-281 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.15.3.5.1, “Introduction to numbers” .

Note At: None.

Source: WG3:BER-026.

Language Opportunity:

There is the opportunity to to support the IEEE rounding modes.

Solution:

None provided with comment.

GQL-282 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:BER-026.

Language Opportunity:

SQL/PGQ has an IS BOUND predicate to test whether an element variable is bound (See WG3:W18-

028). This predicate should be considered for GQL as an advanced conformance feature.

Solution:

None provided with comment.

GQL-283 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Editor’s Notes (Language Opportunities) Notes–23

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Source: WG3:BER-038R1.

Language Opportunity:

An ordered set collection type that provides an ordered collection of distinguishable elements might

be useful for GQL users.

Solution:

None provided with comment.

GQL-285 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:BER-040R3.

Language Opportunity:

Support for additional syntactic forms currently ruled out for <edge reference value type> should

be considered.

Solution:

None provided with comment.

GQL-286 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:BER-049.

Language Opportunity:

The ability to construct a conditional data modification statement with multiple when-then branches

might be useful to GQL users.

Solution:

None provided with comment.

GQL-287 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:BER-049.

Language Opportunity:

The ability to construct a conditional query with multiple when-then branches might be useful to

GQL users.

Solution:

None provided with comment.

Notes–24 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

GQL-288 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:BER-050.

Language Opportunity:

The ability to MERGE an <insert graph pattern> into an existing graph would be useful to GQL users.

See BER-089, “Thoughts about MERGE”, for a discussion of this topic.

Solution:

None provided with comment.

GQL-301 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 12.5, “<drop graph statement>” , Subclause 12.7, “<drop graph type statement>”.

Note At: None.

Source: WG3:BER-037.

Language Opportunity:

GQL DROP statements should be extended to support <drop behavior> CASCADE and RESTRICT,

with RESTRICT specified as the default behavior and CASCADE specified as an optional advanced

conformance feature.

Solution:

None provided with comment.

GQL-303 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 16.19, “<aggregate function>” .

Note At: None.

Source: Email from Keith Hare, 2022-07-14 1359.

Language Opportunity:

The within-match aggregate specified in SQL/PGQ is potentially useful and should be considered

for GQL.

Solution:

None provided with comment.

GQL-304 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.3.5, “Binding tables” .

Note At: None.

Source: WG3:W22-031.

Editor’s Notes (Language Opportunities) Notes–25

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Language Opportunity:

It might be useful to allow the user to store a binding table as the result of a query, rather than

necessarily transmitting the final binding table to the client.

A stored binding table might subsequently be referenced as the original binding table of another

procedure (instead of starting from just the unit binding table). Storing objects or references to

objects might be prohibited, i.e., a stored binding table might only be supported with columns of

scalar data types.

Solution:

A)

GQL is a graph query language. If users would like to work with the persisted tables, they are

recommended to use a system that supports SQL. Implementations that support GQL and SQL

can use procedures to facilitate the use case of loading a persisted table at the beginning GQL

query as the working table as illustrated by the following example:

CALL readTable("foo") YIELD a,b,c

MATCH (n) WHERE n.x > c

...

Likewise they can facilitate the use case of persisting a GQL result by calling a GQL procedure

from SQL even inline as illustrated by the following example:

CREATE TABLE foo (a,b,c) AS (

USE myGraph

MATCH (n)-[k:KNOWNS]->(m)

RETURN n.name AS a, m.name AS b, k.since AS c

) WITH DATA

B)

If GQL would want to pick specifying persisted tables itself, loading a persisted table as

working table could be achieved, e.g., with a FROM clause similar to the GQL’s <use graph

clause>:

FROM foo

MATCH (n) WHERE n.x > c

...

For persisting, GQL would require something akin to SQL’s CREATE TABLE ... AS, for instance:

CREATE BINDING TABLE foo AS {

USE myGraph

MATCH (n)-[k:KNOWNS]->(m)

RETURN n.name AS a, m.name AS b, k.since AS c

}

GQL-306 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:W22-033.

Language Opportunity:

It could be very useful to have a mechanism for inserting a library of procedures, etc. in a GQL

schema, along with the ability to reference and execute objects in the library.

Solution:

None provided with comment.

Notes–26 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

GQL-307 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 13.5, “<delete statement>” .

Note At: Editor’s Note number 19.

Source: WG3:W22-042.

Language Opportunity:

More accurate keywords than DETACH and NODETACH should be specified, as they do not adequately

capture the intent of deleting a node and all its attached edges (or not, in the case of NODETACH).

Solution:

None provided with comment.

GQL-308 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 13.5, “<delete statement>” .

Note At: None.

Source: WG3:W22-042.

Language Opportunity:

The ability to delete a path should be considered.

W22-042 said that given the lack of consensus on the mental model of the ability to delete a path

removed this ability. It went on to say that:

We can illustrate how this would work with an example. Consider the following current working

graph:

(:A)-[:S]->(:A)

To delete all of the graph elements we could execute the following query:

MATCH (m)-[r]->(n)

DELETE r, m, n

According to the origianl definition, the same effect would be achievable with a path variable bound

to a path of those same three elements:

MATCH p = (:A)-[:S]->(:A)

DELETE p

As a path is a sequence of graph elements, the mental model this feature is assuming is that an

instruction to delete a path is equivalent to an instruction to delete its constituent elements. A

problem with this assumed mental model, however, is that unlike graph elements a path is not a

persisted object. Discussions have shown a lack of consensus on treating the deletion of a path in

this way. For the user attempting to delete the constituent elements of a path, an alternative would

be to acquire a reference to each element and then pass them directly to the <delete statement> .

This is not feasible, however, with variable-length paths. In the future, value functions that return

lists of nodes and edges for a given path may be introduced (see Language Opportunity GQL-175.

In that case, as an example, the following query:

MATCH p = (:A)-[:S]->+(:A)

DELETE p

Editor’s Notes (Language Opportunities) Notes–27

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

would be re-writable as:

MATCH p = (:A)-[:S]->+(:A)

FOR e IN edges(p)

DELETE e

FOR n IN nodes(p)

DELETE n

where edges and nodes are value functions returning from a path a list of edges and nodes

respectively.

Solution:

None provided with comment.

GQL-309 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 15.3, “<named procedure call>”.

Note At: None.

Source: WG3:W22-054.

Language Opportunity:

The ability to specify named parameters in addition to sequentially ordered parameters should be

considered in future GQL versions.

Solution:

None provided with comment.

GQL-310 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 15.3, “<named procedure call>”.

Note At: None.

Source: Discussion of WG3:W22-054.

Language Opportunity:

The ability to omit intermediate optional parameters should be considered in future GQL versions.

That is the optionality should not be restricted to trailing optional parameters.

Solution:

None provided with comment.

GQL-319 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:W22-034R1.

Language Opportunity:

It could be very useful to be able to specify and query metadata for graphs and graph types. One

way to accomplish this is to have graph labels and properties that are specified when the graph

Notes–28 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

and/or graph type is created. The graph properties could be accessed through a graph.graphProperty

syntax. Graph labels would require a “label exists” function. Graph properties could be used for

information such as graph creation time, a description of the graph, etc.

Solution:

None provided with comment.

GQL-325 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 12.4, “<create graph statement>” , Subclause 12.6, “<create graph type

statement>” .

Note At: None.

Source: WG3:OHD-020.

Language Opportunity:

It is potentially beneficial to be able to create a Graph Type with no nodes or edges and then incre-

mentally expand the Graph Type definition using an ALTER GRAPH TYPE statement. It would also

be useful to allow CREATE GRAPH with an inline <nested graph type specification> to be created

with an empty <nested graph type specification> and incrementally enhanced with ALTER GRAPH

statements. It might also be useful to have explicit syntax such as EMPTY GRAPH TYPE to allow the

creation of an empty graph type for when a graph is created.

Solution:

None provided with comment.

GQL-328 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:OHD-032R1.

Language Opportunity:

The distinction between schema and directory seems unnecessary, or at least somewhat confusing.

For instance, since path traversal starts at the current schema rather than some notion of current

directory, all relative paths must start with ../ to move from the current schema to its containing

directory. Could not all be schemas, where one schema can contain other schemas? This should

allow lifting existing syntax restrictions for the schema reference syntax and reduce the number of

concepts required for the GQL-catalog.

Some care would be needed to make it clear that a schema S contained in schema PARENT is an

independent schema, not an extension of PARENT. GQL does not currently implement directory or

schema access controls; if and when it does, and if this LO is implemented, the notion of a schema

TRAVERSAL access right (as opposed to a schema READ access right) might be useful.

Solution:

None provided with comment.

GQL-329 The following Language Opportunity has been noted:

Severity: Language Opportunity

Editor’s Notes (Language Opportunities) Notes–29

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Reference: Subclause 12.2, “<create schema statement>”, Subclause 12.3, “<drop schema statement>”,

Subclause 12.4, “<create graph statement>”, Subclause 12.5, “<drop graph statement>”, Subclause 12.6,

“<create graph type statement>”, Subclause 12.7, “<drop graph type statement>” .

Note At: None.

Source: WG3:OHD-032R1.

Language Opportunity:

The create and drop schema, graph, and graph type statements might benefit from allowing <refer-

ence parameter> to specify the schema, graph, or graph type to be created or dropped.

Solution:

None provided with comment.

GQL-330 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:OHD-033

Language Opportunity:

It is a language opportunity to provide either a normative specification of a graph serialization

format or to provide guidance on graph serialization in a guidance standard.

Solution:

None provided with comment.

GQL-331 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:OHD-042

Language Opportunity:

It is a language opportunity to provide an annex, probably informative, that specifies a language

binding, probably Java, to the abstract API defined in this document.

Doing so will validate that the specification of the abstract API is complete and sufficiently well-

defined to enable other language bindings to be defined.

Solution:

None provided with comment.

GQL-332 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:OHD-042

Notes–30 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Language Opportunity:

It is a language opportunity to provide the ability for GQL to call functions and procedure written

in languages other than GQL.

Solution:

None provided with comment.

GQL-336 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.6.3, “Transaction isolation”

Note At: None.

Source: WG3:W23-033

Language Opportunity:

It is a language opportunity to provide some standard specifications for <implementation-defined

access mode> modeled on the existing SQL specifications. However, it should also recognize that

since the time the SQL specifications were made there are more recently-defined levels such as

Snapshot Isolation or Serializable Snapshot Isolation, or other industrially-applied or theoretical

variants.

Solution:

None provided with comment.

GQL-340 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 14.4, “<match statement>” .

Note At: None.

Source: WG3:W23-015.

Language Opportunity:

Some applications (such as recommender systems) require queries involving nodes with unique

IDs and expect the match statement to always return something to be processed for other queries.

Consider additional syntax to handle non-matched patterns and provide the user with a powerful

facility to detect semantic errors and failing early in the case of errors, thus avoiding unnecessary

work and providing good diagnostics regarding which pattern failed to match.

Solution:

None provided with comment.

GQL-341 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 17.3, “<edge type definition>”.

Note At: None.

Source: WG3:W24-023.

Language Opportunity:

Editor’s Notes (Language Opportunities) Notes–31

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

It would be useful to support referential integrity constraints in some form. This could be specified

as stand-alone constraints or as minimum cardinalities on edges. For example, in the edge type

(Person)-[LivesIn :LIVES_IN {since DATE}]->(City), it might be possible to specify that a (Person)

must have at least one [LivesIn] edge with a (City).

See the paper “PG-Keys: Keys for Property Graphs” [https://dl.acm.org/doi/pdf/10.1145/-

3448016.3457561] for useful information on this topic.

Solution:

None provided with comment.

GQL-342 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 17.3, “<edge type definition>”.

Note At: None.

Source: WG3:W24-027.

Language Opportunity:

It could be useful to allow endpoint definitions in an edge type definition to be patterns that

potentially match multiple node type definitions within the graph type.

Solution:

None provided with comment.

GQL-343 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 17.3, “<edge type definition>”.

Note At: None.

Source: WG3:W24-027.

Language Opportunity:

It could be useful to allow <node reference value expression> s and <edge reference value expres-

sion> s to resolve to existing node types and edge types using node type names and edge type names.

Such a capability would need to identify a graph type where the node types and edge types might

be found, either through the graph type of the current working graph or through identifying a

schema and graph type.

Solution:

None provided with comment.

GQL-344 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 17.2, “<node type definition>” and Subclause 17.3, “<edge type definition>”.

Note At: None.

Source: WG3:W24-027.

Language Opportunity:

Notes–32 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

It could be useful to restrict node type names and edge type names to be in the same namespace.

That is, node type names are unique in the set of node type and edge type names in a graph type,

and edge type names unique in the set of node type and edge type names in a graph type.

Solution:

None provided with comment.

GQL-345 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.6, “<numeric value function>”.

Note At: None.

Source: WG3:W24-023.

Language Opportunity:

It could be useful to have functions that return the number of edges pointing into a node (INDEGREE)

and the number of edges pointing out from a node (OUTDEGREE). Such functions should take into

account undirected edges.

Solution:

None provided with comment.

GQL-346 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 19.3, “<comparison predicate>”.

Note At: None.

Source: WG3:W24-037.

Language Opportunity:

Comparison predicate rules could be extended in the future to support comparing more than two

value expressions at the same time. For instance, how would GQL handle the evaluation of 2<3<1.

Solution:

None provided with comment.

GQL-347 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Clause 6, “<GQL-program>”.

Note At: None.

Source: WG3:W24-024R1.

Language Opportunity:

W24-009 P00-WG3-077 suggests that it would be useful to allow the bundling of multiple requests

into one as a way of reducing network round trips. This should include the capability for returning

multiple results to the client in one round trip. One possibility is to introduce a new top-level Sub-

clause <GQL-multi-request> next to <GQL-program>.

Solution:

Editor’s Notes (Language Opportunities) Notes–33

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

None provided with comment.

GQL-348 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Clause 13, “Data-modifying statements” .

Note At: None.

Source: WG3:W24-024R1.

Language Opportunity:

W24-009 P00-WG3-102 suggests that according to the Working Draft’s philosophy of equally sup-

porting an SQL-flavored syntax for easier onboarding of SQL developers, it would be beneficial to

add data modification statements that are SQL-inspired.

Solution:

Adding syntax that supports, for example:

DELETE v

FROM personGraph

MATCH (p:Person)-[v:VOTED_FOR]->(:Person)

WHERE p.age < 18

and

UPDATE p

SET p.teen = TRUE

FROM personGraph

MATCH (p:Person) WHERE p.age < 18

Both examples reuse the FROM clause of the <select statement> .

GQL-349 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Source: WG3:W24-024R1.

Language Opportunity:

GQL could benefit from a predicate checking if a conditional variable is bound. One can check it with

what is already there, for example, if an element x has property a, one can check (x.a=x.a) IS NOT

NULL, but this is not a very natural way. This could be useful in patterns such as [ (A)? -> [ (B) ->

(C) WHERE A.X = B.X+C.X ] -> (D)]{2}. In such patterns that appear to be allowed (see also comment

W24-009 P00-WG3-144) one may want to test in the WHERE clause whether A is bound.

Solution:

None provided with comment.

GQL-350 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: No specific location.

Note At: None.

Notes–34 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

« WG3:UTC-084 »

Source: WG3:W24-024R1, WG3:UTC-084.

Language Opportunity:

Support for ALTER GRAPH TYPE and ALTER GRAPH statements should be considered.

Solution:

None provided with comment.

GQL-353 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 14.8, “<for statement>” .

Note At: None.

Source: WG3:UTC-088.

Language Opportunity:

Consider, in future versions of GQL, looking at the possibility of using multiple <for item>s in a <for

statement> while providing more advanced capabilities, such as handling list of lists or record types

within the <for item> .

Solution:

None provided with comment.

GQL-354 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference:

Note At: None.

Source: WG3:UTC-127R1.

Language Opportunity:

SQL/Foundation defines <array element reference> to return the i-th element of an array. A similar

way of referencing the i-th element of a list should be considered.

Solution:

None provided with comment.

GQL-355 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference:

Note At: None.

Source: WG3:UTC-127R1.

Language Opportunity:

SQL/Foundation defines GREATEST and LEAST operators. It needs to be decided if these additional

operators should be included.

Solution:

Editor’s Notes (Language Opportunities) Notes–35

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

None provided with comment.

GQL-356 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 4.16.4.2, “Nullability requirements” .

Note At: Editor’s Note number 11.

Source: WG3:UTC-051.

Language Opportunity:

Syntax rules determining the declared type of sites should be revisited to improve and specify

(where lacking) the inference of the nullability of those sites.

Solution:

None provided with comment.

GQL-357 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference:

Note At: None.

Source: WG3:UTC-117.

Language Opportunity:

In a future GQL version, it would be useful to have <duration group>s to allow a user to specify a

refined duration type and specify the duration units that result from a datetime subtraction.

Solution:

None provided with comment.

GQL-358 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference:

Note At: None.

Source: WG3:UTC-106.

Language Opportunity:

« WG3:UTC-106 »

The document relies on immediate containment to a great extent. Experience in SQL suggests that

immediate containment is very fragile and therefore to be avoided if possible. The document should

be swept for instances of immediate containment that could be replaced by some more robust form

of containment.

Solution:

None provided with comment.

GQL-359 The following Language Opportunity has been noted:

Severity: Language Opportunity

Notes–36 Editor’s Notes for GQL

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

Reference:

Note At: None.

Source: WG3:UTC-106.

Language Opportunity:

« WG3:UTC-106 »

The document could benefit from some additional diagrams to clarify aspects of the specification.

The following aspects have been suggested:

1)

There are a lot of things in GQL, which could be considered some form of executable (programs,

requests, commands, procedures, function, statements, query, and others). The document

needs a hierarchical diagram laying out the hierarchy of those to make the concepts accessible

to the reader.

2)

The current execution context, the current request context, and the current session context

seem to form some kind of hierarchy. It might be nice to have a diagram showing the nesting

of these contexts.

Solution:

None provided with comment.

GQL-360 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference:

Note At: None.

Source: WG3:UTC-106.

Language Opportunity:

« WG3:UTC-106 »

There are many rules of the form:

Something or another, 1 (one) ≤ n, some more things.

It would help readability of this document tremendously, if those rule were restructured to start

with the iteration.

For example:

For i, 1 (one) ≤ i ≤ n, let something be etc.

Solution:

None provided with comment.

GQL-361 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference:

Note At: None.

Source: WG3:UTC-106.

Language Opportunity:

Editor’s Notes (Language Opportunities) Notes–37

Editor’s Notes for IWD 39075:202y(E)

Language Opportunities

« WG3:UTC-106 »

It is a Language Opportunity to minimize the use of variable subscripts throughout the document

to simplify reading.

Solution:

None provided with comment.

GQL-362 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 20.21, “<value query expression>” .

Note At: None.

Source: WG3:UTC-064.

Language Opportunity:

« WG3:UTC-064 »

The Syntax Rules of Subclause 20.21, “<value query expression>” could be made more permissive

with regard to the contained <nested query specification> to allow for more subqueries that syn-

tactically guarantee to return a binding table with one column and at most one record. Paper

WG3:UTC-064 has a discussion of cases not covered in Syntax Rules introduced by this paper.

Solution:

None provided with comment.

GQL-364 The following Language Opportunity has been noted:

Severity: Language Opportunity

Reference: Subclause 22.10, “Determination of identical values” .

Note At: None.

Source: WG3:UTC-082R1.

Language Opportunity:

It would be appropriate to consider <distinct predicate> in future versions of GQL.

Solution:

None provided with comment.

Notes–38 Editor’s Notes for GQL





Document Outline


Contents

Tables

Figures

Foreword

Introduction

1 Scope

2 Normative references

3 Terms and definitions 3.1 Introduction to terms and definitions

3.2 General terms and definitions

3.3 Graph terms and definitions

3.4 GQL-environment terms and definitions

3.5 GQL-catalog terms and definitions

3.6 Procedure terms and definitions

3.7 Procedure syntax terms and definitions

3.8 Graph pattern terms and definitions

3.9 Value terms and definitions

3.10 Type terms and definitions

3.11 Temporal terms and definitions

3.12 Definitions taken from ISO/IEC 14651:2020





4 Concepts 4.1 Use of terms

4.2 GQL-environments and their components 4.2.1 General description of GQL-environments

4.2.2 GQL-agents

4.2.3 GQL-implementations 4.2.3.1 Introduction to GQL-implementations

4.2.3.2 GQL-clients

4.2.3.3 GQL-servers





4.2.4 Basic security model 4.2.4.1 Principals

4.2.4.2 Authorization identifiers





4.2.5 GQL-catalog 4.2.5.1 General description of the GQL-catalog

4.2.5.2 GQL-directories

4.2.5.3 GQL-schemas





4.2.6 GQL-data





4.3 GQL-objects 4.3.1 General introduction to GQL-objects

4.3.2 Properties and supported property value types

4.3.3 References to GQL-objects

4.3.4 Graphs 4.3.4.1 Introduction to graphs

4.3.4.2 Graph descriptors





4.3.5 Binding tables





4.4 Values 4.4.1 General information about values

4.4.2 Reference values





4.5 GQL-sessions 4.5.1 General description of GQL-sessions

4.5.2 Session contexts 4.5.2.1 Introduction to session contexts

4.5.2.2 Session context creation

4.5.2.3 Session context modification





4.6 GQL-transactions 4.6.1 General description of GQL-transactions

4.6.2 Transaction demarcation

4.6.3 Transaction isolation

4.6.4 Encompassing transaction belonging to an external agent





4.7 GQL-requests and GQL-programs 4.7.1 General description of GQL-requests and GQL-programs

4.7.2 GQL-request contexts 4.7.2.1 Introduction to GQL-request contexts

4.7.2.2 GQL-request context creation

4.7.2.3 GQL-request context modification





4.7.3 Working objects

4.7.4 Execution stack

4.7.5 Operations 4.7.5.1 Introduction to operations

4.7.5.2 Operations classified by kind of caused side effects





4.8 Execution contexts 4.8.1 General description of execution contexts

4.8.2 Execution context creation

4.8.3 Execution context modification

4.8.4 Execution outcomes





4.9 Diagnostic information 4.9.1 Introduction to diagnostic information

4.9.2 GQL-status objects

4.9.3 Conditions





4.10 Procedures and commands 4.10.1 General description of procedures and commands

4.10.2 Procedures 4.10.2.1 General description of procedures

4.10.2.2 Procedure descriptors

4.10.2.3 Procedure execution

4.10.2.4 Procedures classified by kind of side effects

4.10.2.5 Procedures classified by type of provisioning





4.10.3 Commands

4.10.4 GQL-procedures 4.10.4.1 Introduction to GQL-procedures

4.10.4.2 Variables and parameters

4.10.4.3 Statements

4.10.4.4 Statements classified by use of the current working graph

4.10.4.5 Statements classified by function





4.11 Graph pattern matching 4.11.1 Summary of graph pattern matching

4.11.2 Paths

4.11.3 Path patterns

4.11.4 Graph pattern variables

4.11.5 References to graph pattern variables

4.11.6 Path pattern matching

4.11.7 Path modes

4.11.8 Selective path search prefixes

4.11.9 Match modes





4.12 Data types 4.12.1 General introduction to data types and base types

4.12.2 Data type descriptors

4.12.3 Data type terminology

4.12.4 Properties of distinct

4.12.5 The null value





4.13 Graph types 4.13.1 Introduction to graph types

4.13.2 Graph type descriptors

4.13.3 Graph element types 4.13.3.1 Node types

4.13.3.2 Edge types

4.13.3.3 Property types





4.14 Binding table types

4.15 Value types 4.15.1 Dynamic union types 4.15.1.1 Introduction to dynamic union types

4.15.1.2 Dynamic union data type descriptors

4.15.1.3 Characteristics of dynamic union types

4.15.1.4 Dynamic generation of type tests and casts





4.15.2 Constructed value types 4.15.2.1 Introduction to constructed value types

4.15.2.2 List value types

4.15.2.3 Record type

4.15.2.4 Path value types





4.15.3 Predefined value types 4.15.3.1 Naming of predefined value types and associated base types

4.15.3.2 Boolean types

4.15.3.3 Character string types

4.15.3.4 Byte string types

4.15.3.5 Numeric types

4.15.3.6 Temporal types

4.15.3.7 Reference value types





4.16 Sites 4.16.1 General description of sites

4.16.2 Static and dynamic sites

4.16.3 Assignment

4.16.4 Nullability 4.16.4.1 Introduction to nullability

4.16.4.2 Nullability requirements

4.16.4.3 Nullability inference





5 Notation and conventions 5.1 Notation taken from The Unicode® Standard

5.2 Notation

5.3 Conventions 5.3.1 Specification of syntactic elements

5.3.2 Use of terms 5.3.2.1 Syntactic containment

5.3.2.2 Terms denoting rule requirements

5.3.2.3 Rule evaluation order

5.3.2.4 Conditional rules

5.3.2.5 Syntactic substitution





5.3.3 Descriptors

5.3.4 Subclauses used as subroutines

5.3.5 Document typography

5.3.6 Index typography

5.3.7 Feature ID and Feature Name





6 <GQL-program>

7 Session management 7.1 <session set command>

7.2 <session reset command>

7.3 <session close command>





8 Transaction management 8.1 <start transaction command>

8.2 <transaction characteristics>

8.3 <rollback command>

8.4 <commit command>





9 Procedures 9.1 <procedure specification>

9.2 <procedure body>





10 Variable definitions 10.1 <graph variable definition>

10.2 <binding table variable definition>

10.3 <value variable definition>





11 Object expressions 11.1 <graph expression>

11.2 <binding table expression>

11.3 <object expression primary>





12 Catalog-modifying statements 12.1 <linear catalog-modifying statement>

12.2 <create schema statement>

12.3 <drop schema statement>

12.4 <create graph statement>

12.5 <drop graph statement>

12.6 <create graph type statement>

12.7 <drop graph type statement>

12.8 <call catalog-modifying procedure statement>





13 Data-modifying statements 13.1 <linear data-modifying statement>

13.2 <insert statement>

13.3 <set statement>

13.4 <remove statement>

13.5 <delete statement>

13.6 <call data-modifying procedure statement>





14 Query statements 14.1 <composite query statement>

14.2 <composite query expression>

14.3 <linear query statement> and <simple query statement>

14.4 <match statement>

14.5 <call query statement>

14.6 <filter statement>

14.7 <let statement>

14.8 <for statement>

14.9 <order by and page statement>

14.10 <primitive result statement>

14.11 <return statement>

14.12 <select statement>





15 Common statements and related elements 15.1 <call procedure statement> and <procedure call>

15.2 <inline procedure call>

15.3 <named procedure call>





16 Common elements 16.1 <use graph clause>

16.2 <at schema clause>

16.3 <binding variable reference>

16.4 <element variable reference>

16.5 <path variable reference>

16.6 <parameter>

16.7 <graph pattern binding table>

16.8 <graph pattern>

16.9 <path pattern prefix>

16.10 <path pattern expression>

16.11 <insert graph pattern>

16.12 <label expression>

16.13 <graph pattern quantifier>

16.14 <simplified path pattern expression>

16.15 <where clause>

16.16 <yield clause>

16.17 <group by clause>

16.18 <order by clause>

16.19 <aggregate function>

16.20 <sort specification list>

16.21 <limit clause>

16.22 <offset clause>





17 Type elements 17.1 <graph type specification>

17.2 <node type definition>

17.3 <edge type definition>

17.4 <label set definition>

17.5 <property type set definition>

17.6 <property type definition>

17.7 <property value type>

17.8 <binding table type>

17.9 <value type>

17.10 <field type>





18 Object references 18.1 <schema reference> and <catalog schema parent and name>

18.2 <graph reference> and <catalog graph parent and name>

18.3 <graph type reference> and <catalog graph type parent and name>

18.4 <binding table reference> and <catalog binding table parent and name>

18.5 <procedure reference> and <catalog procedure parent and name>

18.6 <catalog object parent reference>

18.7 <reference parameter>

18.8 <external object reference>





19 Predicates 19.1 <search condition>

19.2 <predicate>

19.3 <comparison predicate>

19.4 <exists predicate>

19.5 <null predicate>

19.6 <value type predicate>

19.7 <normalized predicate>

19.8 <directed predicate>

19.9 <labeled predicate>

19.10 <source/destination predicate>

19.11 <all_different predicate>

19.12 <same predicate>

19.13 <property_exists predicate>





20 Value expressions 20.1 <value specification>

20.2 <value expression>

20.3 <boolean value expression>

20.4 <numeric value expression>

20.5 <value expression primary>

20.6 <numeric value function>

20.7 <string value expression>

20.8 <string value function>

20.9 <datetime value expression>

20.10 <datetime value function>

20.11 <duration value expression>

20.12 <duration value function>

20.13 <list value expression>

20.14 <list value function>

20.15 <list value constructor>

20.16 <record value constructor>

20.17 <field>

20.18 <path value expression>

20.19 <path value constructor>

20.20 <property reference>

20.21 <value query expression>

20.22 <case expression>

20.23 <cast specification>

20.24 <element_id function>

20.25 <let value expression>





21 Lexical elements 21.1 <literal>

21.2 Names and variables

21.3 <token>, <separator>, and <identifier>

21.4 <GQL terminal character>





22 Additional common rules 22.1 Store assignment

22.2 Machinery for graph pattern matching

22.3 Evaluation of a <path pattern expression>

22.4 Evaluation of a selective <path pattern>

22.5 Satisfaction of a <label expression> by a label set

22.6 Applying bindings to evaluate an expression

22.7 Evaluating an expression on a group variable

22.8 Applying bindings to generate a record

22.9 Resolving a <simple directory path> from a start directory

22.10 Determination of identical values

22.11 Determination of distinct values

22.12 Equality operations

22.13 Ordering operations

22.14 Grouping operations

22.15 Collation determination

22.16 Result of value type combinations

22.17 Result of static value type combinations

22.18 Static value type set precedence determination





23 GQLSTATUS and diagnostic records 23.1 GQLSTATUS

23.2 Diagnostic records





24 Conformance 24.1 Introduction to conformance

24.2 Minimum conformance

24.3 Conformance to features

24.4 Requirements for GQL-programs 24.4.1 Introduction to requirements for GQL-programs

24.4.2 Claims of conformance for GQL-programs





24.5 Requirements for GQL-implementations 24.5.1 Introduction to requirements for GQL-implementations

24.5.2 Claims of conformance for GQL-implementations

24.5.3 Extensions and options





24.6 GQL Flagger

24.7 Implied feature relationships





A GQL conformance summary

B Implementation-defined elements

C Implementation-dependent elements

D GQL feature taxonomy

E Maintenance and interpretation of GQL

Bibliography

Index
