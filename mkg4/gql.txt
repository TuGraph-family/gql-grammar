97





IWD 39075:202y(E)

6

<GQL-program>

Format

« WG3:UTC-045R1 »

<GQL-program> ::=

<program activity> [ <session close command> ]

| <session close command>

<program activity> ::=

<session activity>

| <transaction activity>

<session activity> ::=

<session activity command>...

<session activity command> ::=

<session set command>

| <session reset command>

<transaction activity> ::=

<start transaction command>

[ <procedure specification> [ <end transaction command> ] ]

| <procedure specification> [ <end transaction command> ]

| <end transaction command>

« WG3:UTC-076 »

<end transaction command> ::=

<rollback command>

| <commit command>

Syntax Rules

1)

Let REQUEST be the GQL-request and let RCX be the current request context.

2)

Let AUTH be the authorization identifier associated with the GQL-agent on whose behalf REQUEST

was submitted.

3)

Let PRINCIPAL be the principal identified by AUTH.

4)

Let PROG be the <GQL-program> that was specified as the request source of RCX.

5)

The scope clause of PROG is PROG.

6)

For every pair of instances I1 and I2 of a <non-delimited identifier> or a <delimited identifier>

contained in PROG: if I1 and I2 are visually confusable with each other, then an exception condition

is raised: syntax error or access rule violation — use of visually confusable identifiers (42004).

7)

Let WS be determined as follows.

Case:

« WG3:UTC-045R1 »

a)

If no GQL-session has been established for the GQL-client, then

98

IWD 39075:202y(E)

6 <GQL-program>

Case:

i)

If the current home schema is defined, then WS is the current home schema.

ii)

Otherwise, WS is no GQL-schema.

b)

Otherwise, the GQL-session has been established and

Case:

i)

If the current session schema is defined, then WS is the current session schema.

ii)

Otherwise, WS is no GQL-schema.

8)

If WS is a GQL-schema, then:

a)

The scope of WS comprises PROG.

b)

PROG declares WS as a working schema.

9)

Let the graph WG be determined as follows.

Case:

a)

If no GQL-session has been established for the GQL-client, then

« WG3:UTC-045R1 »

Case:

i)

If the current home graph is defined, then WG is the current home graph.

ii)

Otherwise, WG is no graph.

b)

Otherwise, WG is the current session graph.

10) The scope of WG comprises PROG.

11) PROG declares WG as the working graph.

12) The declared type of incoming working record of PROG is the material unit record type.

13) The declared type of incoming working table of PROG is the material unit binding table type.

General Rules

1)

Case:

a)

If no GQL-session has been established for the GQL-client, then let SESSION be a new GQL-

session with an associated session context SCX that is initialized as follows:

i)

Set the authorization identifier of SCX to AUTH.

ii)

Set the principal of SCX to PRINCIPAL.

iii)

Set the time zone displacement of SCX to the implementation-defined (ID048) default

time zone displacement.

iv)

If the current home schema is defined, then set the session schema of SCX to the current

home schema.

v)

Set the session graph of SCX to the current home graph.

99

IWD 39075:202y(E)

6 <GQL-program>

vi)

Set the session parameters of SCX to the implementation-defined (ID049) default session

parameters.

« WG3:UTC-056R1 Deleted 1 (one) note consequently »

vii)

Set the transaction of SCX to no GQL-transaction.

viii)

Set the request context of SCX to no GQL-request context.

ix)

Set the termination flag of SCX to False.

b)

Otherwise, SESSION is the GQL-session that has already been established for the GQL-client

and SCX is the session context associated with SESSION.

2)

Set the execution stack of RCX to a new empty execution stack.

3)

Set the request outcome of RCX to a successful outcome with an omitted result.

« WG3:UTC-132 »

4)

Set the request timestamp of RCX to “not set”.

5)

Set the current request context to RCX.

6)

Push a new execution context CTX onto the current execution stack, initialized as follows:

a)

Set the working table of CTX to a new unit binding table.

b)

Set the working record of CTX to a new empty record.

c)

Set the execution outcome of CTX to a successful outcome with an omitted result.

NOTE 104 — CTX becomes the current execution context.

« WG3:UTC-045R1 »

7)

If PROG simply contains the <program activity> PACT, then the General Rules of PACT are applied.

8)

If PROG simply contains the <session close command> SCC, then the General Rules of SCC are applied.

9)

Set the current request outcome to the execution outcome of CTX.

10) Pop the current execution context.

NOTE 105 — This leaves the execution stack empty.

11) If the current termination flag is set to True and the current transaction is active, then:

a)

The following statement is implicitly executed:

ROLLBACK

b)

Set a failed outcome as the current request outcome.

12) Return the current request outcome to the GQL-client for delivery to the GQL-agent.

13) Set no current request context.

14) If the current termination flag is set to True, then close SESSION by disassociating it from the GQL-

client and destroying SCX.

Conformance Rules

« WG3:UTC-116 »

100

IWD 39075:202y(E)

6 <GQL-program>

1)

Without Feature GS15, “Explicit transactions”, conforming GQL language shall not contain a

<transaction activity>.

101





IWD 39075:202y(E)

7

Session management

7.1

<session set command>

Function

Set values in the session context.

Format

<session set command> ::=

SESSION SET {

<session set schema clause>

| <session set graph clause>

| <session set time zone clause>

| <session set parameter clause>

}

<session set schema clause> ::=

SCHEMA <schema reference>

« WG3:UTC-039R1 »

<session set graph clause> ::=

[ PROPERTY ] GRAPH <graph expression>

<session set time zone clause> ::=

TIME ZONE <set time zone value>

<set time zone value> ::=

<string value expression>

« WG3:UTC-045R1 »

<session set parameter clause> ::=

<session set graph parameter clause>

| <session set binding table parameter clause>

| <session set value parameter clause>

<session set graph parameter clause> ::=

[ PROPERTY ] GRAPH <session set parameter name> <opt typed graph initializer>

<session set binding table parameter clause> ::=

[ BINDING ] TABLE <session set parameter name> <opt typed binding table initializer>

<session set value parameter clause> ::=

VALUE <session set parameter name> <opt typed value initializer>

<session set parameter name> ::=

<parameter name> [ IF NOT EXISTS ]

« WG3:UTC-045R1 deleted one production »

Syntax Rules

« WG3:UTC-045R1 »

102

IWD 39075:202y(E)

7.1 <session set command>

1)

Let SSC be the <session set command> .

2)

SSC has no declared type.

3)

If SCC simply contains the <session set schema clause> SSSC, then let S be the GQL-schema identified by the <schema reference> immediately contained in SSSC.

« WG3:UTC-117 »

4)

If the <set time zone value> STZV is specified, then:

a)

The <string value expression> immediately contained in STZV shall conform to the represent-

ation specified in clause 4.3.13, “Time shift” of ISO 8601-1:2019.

b)

Let TZD be the time zone displacement specified by STZV.

5)

If SSC simply contains the <session set parameter clause> , then:

a)

Let SSPN be the outermost <session set parameter name> simply contained in SSC and let PN

be the <parameter name> immediately contained in SSPN.

b)

If SSPN contains IF NOT EXISTS and the current session context contains a session parameter

with parameter name PN, then no further Syntax Rules of this Subclause are applied.

c)

Case:

i)

If SSC is the <session set graph parameter clause> SSGPC, then:

Case:

1)

Let OTGI be the <opt typed graph initializer> immediately contained in SSGPC

and let GI be the <graph initializer> immediately contained in OTGI.

2)

Let GIT be the declared type of GI.

3)

Let the declared type of the session parameter with parameter name PN be

determined as follows.

Case:

A)

If OTGI immediately contains a <graph reference value type> OGT, then:

I)

GIT shall be assignable to the type specified by OGT.

II)

The declared type of the session parameter with parameter name

PN is the type specified by OGT.

B)

Otherwise, the declared type of the session parameter with parameter name

PN is GIT.

ii)

If SSC is the <session set binding table parameter clause> SSBTPC, then:

Case:

1)

Let OTBTI be the <opt typed binding table initializer> immediately contained in

SSBTPC and let BTI be the <binding table initializer> immediately contained in

OTBTI.

2)

Let BTIT be the declared type of BTI.

3)

Let the declared type of the session parameter with parameter name PN be

determined as follows.

Case:

103

IWD 39075:202y(E)

7.1 <session set command>

A)

If OTBTI immediately contains a <binding table reference value type> OBTT,

then:

I)

BTIT shall be assignable to the type specified by OBTT.

II)

The declared type of the session parameter with parameter name

PN is the type specified by OBTT.

B)

Otherwise, the declared type of the session parameter with parameter name

PN is BTIT.

iii)

If SSC is the <session set value parameter clause> SSVPC, then:

Case:

1)

Let OTVI be the <opt typed value initializer> immediately contained in SSVPC and

let VI be the <value initializer> immediately contained in OTVI.

2)

Let VIT be the declared type of VI.

3)

Let the declared type of the session parameter with parameter name PN be

determined as follows.

Case:

A)

If OTVI immediately contains a <value type> OVT, then:

I)

VIT shall be assignable to the type specified by OVT.

II)

The declared type of the session parameter with parameter name

PN is the type specified by OVT.

B)

Otherwise, the declared type of the session parameter with parameter name

PN is VIT.

« WG3:UTC-039R1 Deleted 1 (one) SR »

General Rules

« WG3:UTC-045R1 »

1)

If SSC simply contains the <session set schema clause>, then set the current session schema to S.

« WG3:UTC-039R1 »

2)

If SSC simply contains the <session set graph clause> SSGC, then set the current session graph to the graph that is the result of the <graph expression> immediately contained in SSGC.

« WG3:UTC-117 »

3)

If SSC simply contains the <session set time zone clause> , then set the current session time zone displacement to TZD.

4)

If SSC simply contains the <session set parameter clause> , then

Case:

a)

If SSPN contains IF NOT EXISTS and the current session context contains a session parameter

with parameter name PN, then the current application of General Rules of this Subclause

resumes with 5) paragraph.

b)

If SSC is the <session set graph parameter clause> SSGPC, then set the session parameter with parameter name PN in the current session context to the result of GI.

104

IWD 39075:202y(E)

7.1 <session set command>

c)

If SSC is the <session set binding table parameter clause> SSBTPC, then set the session parameter with parameter name PN in the current session context to the result of TI.

d)

If SSC is the <session set value parameter clause> SSVPC, then set the session parameter with parameter name PN in the current session context to the result of VI.

5)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

« WG3:UTC-045R1 »

1)

Without Feature GS01, “Session-local graph parameters”, conforming GQL language shall not contain

a <session set graph parameter clause>.

2)

Without Feature GS02, “Session-local binding table parameters”, conforming GQL language shall

not contain a <session set binding table parameter clause>.

3)

Without Feature GS03, “Session-local value parameters”, conforming GQL language shall not contain

a <session set value parameter clause> .

« WG3:UTC-100 »

4)

Without Feature GS09, “Session-local graph parameters based on subqueries”, conforming GQL

language shall not contain a <session set graph parameter clause> that contains a <procedure

body> .

5)

Without Feature GS10, “Session-local binding table parameters based on subqueries”, conforming

GQL language shall not contain a <session set binding table parameter clause> that contains a

<procedure body> .

6)

Without Feature GS11, “Session-local value parameters based on subqueries”, conforming GQL

language shall not contain a <session set value parameter clause> that contains a <procedure body>.

7)

Without Feature GS12, “Session-local graph parameters based on simple expressions or references”,

conforming GQL language shall not contain a <session set graph parameter clause> that simply

contains a <graph expression> that does not conform to <value specification> or is a <graph refer-

ence>.

8)

Without Feature GS13, “Session-local binding table parameters based on simple expressions or

references”, conforming GQL language shall not contain a <session set binding table parameter

clause> that simply contains a <binding table expression> that does not conform to <value specific-

ation> or is a <binding table reference> .

9)

Without Feature GS14, “Session-local value parameters based on simple expressions”, conforming

GQL language shall not contain a <session set value parameter clause> that simply contains a <value

expression> that does not conform to <value specification> .

« WG3:UTC-045R1 deleted two Subclauses »

« WG3:UTC-045R1 »

105





IWD 39075:202y(E)

7.2 <session reset command>

7.2

<session reset command>

Function

Reset session parameters and characteristics.

Format

<session reset command> ::=

[ SESSION ] RESET [ <session reset arguments> ]

<session reset arguments> ::=

[ ALL ] { PARAMETERS | CHARACTERISTICS }

| SCHEMA

| [ PROPERTY ] GRAPH

| TIME ZONE

| [ PARAMETER ] <parameter name>

Syntax Rules

1)

Let SRC be the <session reset command>.

2)

Case:

a)

If SRC simply contains <session reset arguments> SRA, then

Case:

i)

If SRA is CHARACTERISTICS or PARAMETERS, then SRA is effectively replaced by:

ALL SRA

ii)

If SRA is GRAPH, then SRA is effectively replaced by:

PROPERTY GRAPH

b)

Otherwise, SRC is effectively replaced by:

SESSION RESET ALL CHARACTERISTICS

3)

SRC has no declared type.

General Rules

1)

If ALL CHARACTERISTICS or SCHEMA is specified and the current home schema is defined, then

set the session schema to the current home schema; otherwise, set the session schema to no GQL-

schema.

2)

If ALL CHARACTERISTICS or PROPERTY GRAPH is specified and the current home schema is defined,

then set the session graph to the current home graph; otherwise, set the graph schema to no graph.

3)

If ALL CHARACTERISTICS or TIME ZONE is specified, then set the current session time zone dis-

placement to the implementation-defined (ID048) default time zone displacement.

4)

If ALL CHARACTERISTICS or ALL PARAMETERS is specified, then:

a)

Remove each session parameter from the current session context.

106

IWD 39075:202y(E)

7.2 <session reset command>

b)

Add each implementation-defined (ID049) default session parameter to the current session

context.

5)

If the <parameter name> PN is specified, then:

a)

If the current session context has a session parameter SP whose name is the name specified

by PN, then remove SP from the current session context.

b)

If PN specifies the name of an implementation-defined (ID049) default session parameter DP, then add DP to the current session context.

6)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

1)

Without Feature GS04, “Session: reset all characteristics”, conforming GQL language shall not contain

SESSION RESET ALL CHARACTERISTICS.

2)

Without Feature GS05, “Session: reset schema”, conforming GQL language shall not contain SESSION

RESET SCHEMA.

3)

Without Feature GS06, “Session: reset property graph”, conforming GQL language shall not contain

SESSION RESET PROPERTY GRAPH or SESSION RESET GRAPH.

4)

Without Feature GS07, “Session: reset timezone”, conforming GQL language shall not contain SESSION

RESET TIME ZONE.

5)

Without Feature GS08, “Session: reset all parameters”, conforming GQL language shall not contain

SESSION RESET ALL PARAMETERS or SESSION RESET PARAMETERS.

107





IWD 39075:202y(E)

7.3 <session close command>

7.3

<session close command>

Function

Close the current session.

Format

<session close command> ::=

[ SESSION ] CLOSE

Syntax Rules

« WG3:UTC-096R1 »

1)

The <session close command> has no declared type.

General Rules

1)

Set the current termination flag to True.

« WG3:UTC-096R1 »

2)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

None.

108





IWD 39075:202y(E)

8

Transaction management

8.1

<start transaction command>

Function

Start a new GQL-transaction and set its characteristics.

Format

<start transaction command> ::=

START TRANSACTION [ <transaction characteristics> ]

Syntax Rules

« WG3:UTC-059 »

1)

Let TS be the <start transaction command>.

2)

If TS does not simply contain <transaction characteristics> , then an implementation-defined (ID006)

default transaction characteristics that simply contains a <transaction mode> READ WRITE is

implicit.

General Rules

1)

If a GQL-transaction is currently active, then an exception condition is raised: invalid transaction

state — active GQL-transaction (25G01).

« WG3:UTC-059 »

2)

Let TC be the explicit or implicit <transaction characteristics> simply contained in TS.

3)

A new GQL-transaction TX with the transaction characteristics specified by TC as its transaction

characteristics is initiated.

NOTE 106 — Every transaction records its transaction characteristics.

4)

The current transaction is set to TX.

NOTE 107 — This determines TX as the currently active GQL-transaction associated with the GQL-session of the

currently executing GQL-request.

Conformance Rules

« WG3:UTC-116 »

1)

Without Feature GS16, “Transaction characteristics”, conforming GQL language shall not contain a

<start transaction command> that contains <transaction characteristics>.

« WG3:UTC-076 Deleted 1 (one) Subclause »

109





IWD 39075:202y(E)

8.2 <transaction characteristics>

8.2

<transaction characteristics>

Function

Specify GQL-transaction characteristics.

Format

<transaction characteristics> ::=

<transaction mode> [ { <comma> <transaction mode> }... ]

<transaction mode> ::=

<transaction access mode>

| <implementation-defined access mode>

<transaction access mode> ::=

READ ONLY

| READ WRITE

<implementation-defined access mode> ::=

!! See the Syntax Rules.

Syntax Rules

1)

Let TC be the <transaction characteristics> .

« WG3:UTC-059 »

2)

TC shall contain exactly one <transaction access mode>.

« WG3:UTC-059 deleted one SR »

3)

The Format and Syntax Rules for <implementation-defined access mode> are implementation-

defined (IE002).

General Rules

None.

Conformance Rules

None.

110





IWD 39075:202y(E)

8.3 <rollback command>

8.3

<rollback command>

Function

Terminate the currently active GQL-transaction with rollback.

Format

<rollback command> ::=

ROLLBACK

Syntax Rules

None.

General Rules

1)

If the currently active GQL-transaction is part of an encompassing transaction that is controlled by

an agent other than the GQL-agent and the <rollback command> is not being implicitly executed,

then an exception condition is raised: invalid transaction termination (2D000).

2)

All changes to GQL-data or the GQL-catalog that were made by the currently active GQL-transaction

are canceled.

3)

The currently active GQL-transaction is terminated and the current transaction of the current session

context is set to no transaction.

Conformance Rules

None.

111





IWD 39075:202y(E)

8.4 <commit command>

8.4

<commit command>

Function

Terminate the currently active GQL-transaction with commit.

Format

<commit command> ::=

COMMIT

Syntax Rules

None.

General Rules

1)

If the currently active GQL-transaction is part of an encompassing transaction that is controlled by

an agent other than the GQL-agent, then an exception condition is raised: invalid transaction termin-

ation (2D000).

2)

Case:

a)

If any enforced constraint is not satisfied, then any changes to GQL-data or the GQL-catalog

that were made by the currently active GQL-transaction are canceled and an exception condition

is raised: transaction rollback — integrity constraint violation (40002).

** Editor’s Note (number 12) **

This only becomes necessary once constraints are introduced. See Language Opportunity GQL-011 .

b)

If any other error preventing commitment of the GQL-transaction has occurred, then any

changes to GQL-data or the GQL-catalog that were made by the currently active GQL-transaction

are canceled and an exception condition is raised: transaction rollback (40000) with an

implementation-defined (IE008) subclass value.

c)

Otherwise, any changes to GQL-data or the GQL-catalog that were made by the currently active

GQL-transaction are eligible to be perceived by all subsequent GQL-transactions.

3)

The currently active GQL-transaction is terminated and the current transaction of the current session

context is set to no transaction.

Conformance Rules

None.

112





IWD 39075:202y(E)

9

Procedures

« WG3:UTC-077 Deleted 1 (one) editor's note »

9.1

<procedure specification>

Function

Define the procedural logic of a procedure.

Format

<nested procedure specification> ::=

<left brace> <procedure specification> <right brace>

<procedure specification> ::=

<catalog-modifying procedure specification>

| <data-modifying procedure specification>

| <query specification>

<catalog-modifying procedure specification> ::=

<procedure body>

<nested data-modifying procedure specification> ::=

<left brace> <data-modifying procedure specification> <right brace>

<data-modifying procedure specification> ::=

<procedure body>

« WG3:UTC-077 »

<nested query specification> ::=

<left brace> <procedure specification> <right brace>

<query specification> ::=

<procedure body>

Syntax Rules

« WG3:UTC-077 »

1)

If the <nested procedure specification> NPS is specified, then the declared type of NPS is the declared type of the <procedure specification> that is immediately contained in NPS.

2)

If the <nested query specification> NQS is specified, then the declared type of NQS is the declared type of the <query specification> that is immediately contained in NQS.

3)

If the <nested data-modifying procedure specification> NDPS is specified, then the declared type of NDPS is the declared type of the <data-modifying procedure specification> that is immediately contained in NDPS.

4)

If the <procedure specification> PS is specified, then:

113

IWD 39075:202y(E)

9.1 <procedure specification>

a)

Let PB be the <procedure body> immediately contained in the <catalog-modifying procedure

specification> , <data-modifying procedure specification> , or <query specification> immediately contained in PS.

b)

Case:

i)

If PB simply contains a <linear catalog-modifying statement>, then PS is a <catalog-

modifying procedure specification>.

ii)

If PB simply contains a <linear data-modifying statement>, then PS is a <data-modifying

procedure specification>.

iii)

Otherwise, PS is a <query specification>.

5)

If the <catalog-modifying procedure specification> CPS is specified, then every <statement> simply contained in CPS shall be a <linear catalog-modifying statement> .

6)

If the <data-modifying procedure specification> DPS is specified, then every <statement> S simply contained in DPS shall be either a <linear data-modifying statement> or a <composite query state-

ment>. At least one such S shall be a <linear data-modifying statement> .

7)

If the <query specification> QS is specified, then every <statement> simply contained in QS shall be a <composite query statement>.

General Rules

« WG3:UTC-077 Deleted 1 (one) SR »

1)

If a <procedure specification> PS is specified that is immediately contained in a <transaction

activity> , then:

« WG3:UTC-077 »

a)

If no GQL-transaction is active, then a new GQL-transaction TX is initiated and the current

transaction is set to TX.

NOTE 108 — This determines TX as the currently active GQL-transaction associated with the GQL-session of

the currently executing GQL-request.

b)

If PS is a <catalog-modifying procedure specification> and a <data-modifying procedure spe-

cification> has already occurred in the current GQL-transaction and the GQL-implementation

does not support Feature GC01, “Catalog and data statement mixing”, then an exception is

raised: invalid transaction state — catalog and data statement mixing not supported (25G02).

« WG3:UTC-047 »

c)

If PS is a <data-modifying procedure specification> and a <catalog-modifying procedure spe-

cification> has already occurred in the current transaction and the GQL-implementation does

not support Feature GC01, “Catalog and data statement mixing”, then an exception is raised:

invalid transaction state — catalog and data statement mixing not supported (25G02).

« WG3:UTC-077 Deleted 2 SRs »

« WG3:UTC-047 »

d)

If PS contains a <use graph clause> with <graph expression> GE2 and a <use graph clause>

with <graph expression> GE1 has already occurred in the current transaction and the result

of GE2 is different than the result of GE1 and the GQL-implementation does not support Feature

GC00, “Multiple graphs in a GQL-transaction”, then an exception is raised: invalid transaction

state — accessing multiple graphs not supported (25G04).

« WG3:UTC-077 Deleted 3 GRs »

114

IWD 39075:202y(E)

9.1 <procedure specification>

Conformance Rules

None.

« WG3:UTC-077 Deleted 1 (one) Subclause »

115





IWD 39075:202y(E)

9.2 <procedure body>

9.2

<procedure body>

Function

Specify the body of a procedure.

Format

<procedure body> ::=

[ <at schema clause> ] [ <binding variable definition block> ] <statement block>

« WG3:UTC-045R1 »

<binding variable definition block> ::=

<binding variable definition> ...

<binding variable definition> ::=

<graph variable definition>

| <binding table variable definition>

| <value variable definition>

« WG3:UTC-101 »

<statement block> ::=

<statement> [ <next statement> ... ]

« WG3:UTC-122 »

<statement> ::=

<linear catalog-modifying statement>

| <linear data-modifying statement>

| <composite query statement>

<next statement> ::=

NEXT [ <yield clause> ] <statement>

Syntax Rules

1)

Let PB be the <procedure body> .

« WG3:UTC-039R1 »

« WG3:UTC-045R1 »

2)

If the <binding variable definition block> BVDBLK is specified, then:

a)

The declared type of the incoming working record of BVDBLK is the declared type of the

incoming working record of PB.

b)

The declared type of the incoming working table of BVDBLK is the material unit binding table

type.

c)

Let BVDSEQ be the sequence of <binding variable definition> immediately contained in BVDBLK, let m be the number of elements of BVDSEQ.

d)

The declared type of the incoming working record of the first <binding variable definition>

in BVDSEQ is the declared type of the incoming working record of BVDBLK.

e)

Let BVDj be the j-th element of BVDSEQ, for 1 (one) ≤ j ≤ m.

f)

The declared type of the incoming working record of BVDj is the declared type of the outgoing

working record of BVDj-1, for 2 (two) ≤ j ≤ m.

116

IWD 39075:202y(E)

9.2 <procedure body>

g)

The declared type of the outgoing working record of BVDBLK is the declared type of the out-

going working record of BVDj.

h)

The declared type of the outgoing working table of BVDBLK is the declared type of the

incoming working table of BVDBLK.

3)

Let SBLK be the <statement block>.

4)

If SBLK directly contains a <linear catalog-modifying statement>, then SBLK shall directly contain at most one <statement>.

5)

If SBLK directly contains a <focused linear query statement> or a <focused linear data-modifying

statement>, then SBLK shall not directly contain an <ambient linear query statement> or an

<ambient linear data-modifying statement>.

« WG3:UTC-096R1 »

NOTE 109 — As a consequence of this rule, focused statements and ambient statement are mutually exclusive within

a <statement block>, so that the following is true as well: If SBLK directly contains an <ambient linear query statement>

or an <ambient linear data-modifying statement>, then SBLK does not directly contain a <focused linear query

statement> or a <focused linear data-modifying statement> .

« WG3:UTC-096R1 Deleted 1 (one) rule »

6)

If SBLK directly contains a <linear query statement> that is a <select statement>, then every <linear

query statement> directly contained in SBLK shall be a <select statement>.

7)

If SBLK directly contains a <linear query statement> that contains a <primitive result statement> , then every <linear query statement> directly contained in SBLK shall contain a <primitive result

statement>.

« WG3:UTC-064 Deleted 1 (one) SR »

« WG3:UTC-045R1 move and merged one SR »

« WG3:UTC-101 »

8)

Let TSTMSEQ be the sequence of <next statement>s immediately contained in SBLK, let m be the number of elements of TSTMSEQ.

9)

Let the <statement> s STMj, 0 (zero) ≤ j ≤ m, directly contained in SBLK be determined as follows: a)

STM 0 is the <statement> immediately contained in SBLK.

b)

STMj, 1 (one) ≤ j ≤ m, is the <statement> contained the j-th element of TSTMSEQ.

10) The declared type of incoming working record of STM 0 is defined as follows.

Case:

a)

If the <binding variable definition block> BVDBLK was specified, then the declared type of the incoming working record of STM 0 is the declared type of the outgoing working record of

BVDBLK.

b)

Otherwise, the declared type of incoming working record of STM 0 is the declared type of the

incoming working record of PB.

11) The declared type of the incoming working table of STM 0 is the declared type of the incoming

working table of PB.

12) For 1 (one) ≤ j ≤ m:

a)

The declared type of the incoming working record of STMj is the declared type of the outgoing

working record of STMj-1.

117

IWD 39075:202y(E)

9.2 <procedure body>

b)

The declared type of the incoming working table of STMj is defined as follows.

Case:

i)

If the declared type of STMj-1 is a binding table type BTT, then

Case:

« WG3:UTC-101 »

1)

If the <next statement> that directly contains STMj also directly contains a <yield

clause> YC, then:

A)

The declared type of the incoming working table of YC is BTT.

B)

The declared type of the incoming working table of STMj is the declared

type of YC.

2)

Otherwise, the declared type of the incoming working table of STMj is BTT.

ii)

Otherwise, the declared type of the incoming working table of STMj is the material unit

binding table type.

« WG3:UTC-096R1 »

c)

The record type of the declared type of the incoming working table of STM and the declared

type of the incoming working record of STMj shall be field name-disjoint.

13) The declared type of PB is the declared type of STMm.

General Rules

« WG3:UTC-077 Deleted 1 (one) editor's note »

1)

If the <binding variable definition block> BVDBLK is specified, then:

a)

The General Rules of BVDBLK are applied in a new child execution context CONTEXT.

b)

Set the current working record to the working record of CONTEXT.

2)

The General Rules of STM 0 are applied.

« WG3:UTC-122 »

NOTE 110 — Not all statements set a result; instead they possibly modify the current execution context. A result is

set by <primitive result statement>s and by <simple data-modifying statement>s to determine the execution outcome of a procedure or a top-level <statement>.

3)

For 1 (one) ≤ j ≤ m:

a)

Case:

i)

If the current execution outcome has a result table RT, then set the current working

table to RT.

ii)

Otherwise, set the current working table to a new unit binding table.

« WG3:UTC-101 »

b)

If the <next statement> that directly contains STMj also directly contains a <yield clause> YC, then the General Rules of YC are applied; set the current working table to be the YIELD returned

from the application of these General Rules.

118

IWD 39075:202y(E)

9.2 <procedure body>

c)

The General Rules of STMj are applied.

« WG3:UTC-122 »

NOTE 111 — Not all statements set a result; instead they possibly modify the current execution context. A

result is set by <primitive result statement>s and by <simple data-modifying statement> s to determine the execution outcome of a procedure or a top-level <statement> .

4)

The outcome of the application of these General Rules is the current execution outcome.

Conformance Rules

« WG3:UTC-039R1 »

1)

Without Feature GB32, “AT schema clause”, in conforming GQL language, a <procedure body> shall

not contain an <at schema clause>.

2)

Without Feature GB33, “Binding variable definition block”, in conforming GQL language, a <procedure

body> shall not contain a <binding variable definition block> .

« WG3:UTC-045R1 »

« WG3:UTC-039R1 »

3)

Without Feature GB34, “Graph variables”, in conforming GQL language, a <binding variable defini-

tion> shall not contain a <graph variable definition>.

4)

Without Feature GB35, “Binding table variables”, in conforming GQL language, a <binding variable

definition> shall not contain a <binding table variable definition> .

5)

Without Feature GB42, “Procedure-local value variable definitions”, in conforming GQL language,

a <binding variable definition> shall not contain a <binding table variable definition>.

« WG3:UTC-101 »

6)

Without Feature GC05, “Advanced linear composition with NEXT”, in conforming GQL language, a

<procedure body> shall not contain a <next statement> .

119





IWD 39075:202y(E)

10 Variable definitions

« WG3:UTC-045R1 »

« WG3:UTC-045R1 deleted one Subclause »

« WG3:UTC-045R1 »

10.1 <graph variable definition>

Function

Define graph variables.

Format

<graph variable definition> ::=

[ PROPERTY ] GRAPH <graph variable> <opt typed graph initializer>

« WG3:UTC-045R1 »

<opt typed graph initializer> ::=

[ [ <typed> ] <graph reference value type> ] <graph initializer>

« WG3:UTC-045R1 deleted one production »

<graph initializer> ::=

<equals operator> <graph expression>

Syntax Rules

« WG3:UTC-045R1 »

1)

Let GVD be the <graph variable definition> .

2)

Let GN be the name of the <graph variable> simply contained in GVD.

3)

Let OTGI be the <opt typed graph initializer> immediately contained in GVD.

4)

Let GI be the <graph initializer> immediately contained in OTGI.

5)

The declared type of GI is the declared type of the <graph expression> immediately contained in GI.

6)

Let WRT be the declared type of the incoming working record of GVD.

7)

WRT shall not have a field type whose field name is GN.

« WG3:UTC-045R1 deleted one SR »

8)

Let the graph reference value type GT be defined as follows.

a)

Let GIT be the declared type of GI.

b)

Case:

120

IWD 39075:202y(E)

10.1 <graph variable definition>

i)

If GVD simply contains a <graph reference value type> OGT without an intervening

instance of <graph initializer>, then:

1)

GIT shall be assignable to the graph type specified by OGT.

2)

GT is the type specified by OGT.

ii)

Otherwise, GT is GIT.

9)

The declared type of the outgoing working record of GVD is a record type comprising all the field

types of WRT and one additional field type with field name GN and field value type GT.

« WG3:UTC-045R1 deleted one SR »

General Rules

« WG3:UTC-045R1 »

1)

The result of GI is the result of the <graph expression> immediately contained in GI.

2)

Let ROGI be the result of GI.

3)

Add a field with field name GN and field value ROGI to the current working record.

« WG3:UTC-045R1 deleted one GR »

Conformance Rules

None.

« WG3:UTC-045R1 »

121





IWD 39075:202y(E)

10.2 <binding table variable definition>

10.2 <binding table variable definition>

Function

Define binding table variables.

Format

<binding table variable definition> ::=

[ BINDING ] TABLE <binding table variable> <opt typed binding table initializer>

<opt typed binding table initializer> ::=

[ [ <typed> ] <binding table reference value type> ] <binding table initializer>

« WG3:UTC-045R1 deleted one production »

<binding table initializer> ::=

<equals operator> <binding table expression>

Syntax Rules

« WG3:UTC-045R1 »

1)

Let BTVD be the <binding table variable definition>.

2)

Let BTN be the name of the <binding table variable> simply contained in BTVD.

3)

Let OTBTI be the <opt typed binding table initializer> immediately contained in BTVD.

4)

Let BTI be the <binding table initializer> immediately contained in OTBTI.

5)

The declared type of BTI is the declared type of the <binding table expression> immediately contained in BTI.

6)

Let WRT be the declared type of the incoming working record of BTVD.

7)

WRT shall not have a field type whose field name is BTN.

« WG3:UTC-045R1 deleted one GR »

« WG3:UTC-045R1 »

8)

Let the binding table reference value type BTT be defined as follows.

a)

Let BTIT be the declared type of BTI.

b)

Case:

i)

If BTVD simply contains a <binding table reference value type> OBTT without an

intervening instance of <binding table initializer> , then:

1)

BTIT shall be assignable to the type specified by OBTT.

2)

BTT is the type specified by OBTT.

ii)

Otherwise, BTT is BTIT.

9)

The declared type of the outgoing working record of BTVD is a record type comprising all the field

types of WRT and one additional field type with field name BTN and field value type BTT.

« WG3:UTC-045R1 deleted one GR »

122

IWD 39075:202y(E)

10.2 <binding table variable definition>

General Rules

« WG3:UTC-045R1 »

1)

The result of BTI is the result of the <binding table expression> immediately contained in BTI.

2)

Let ROBTI be the result of BTI.

3)

Add a field with field name BTN and field value ROBTI to the current working record.

« WG3:UTC-045R1 deleted one GR »

Conformance Rules

None.

« WG3:UTC-045R1 »

123





IWD 39075:202y(E)

10.3 <value variable definition>

10.3 <value variable definition>

Function

Define value variables.

Format

<value variable definition> ::=

VALUE <value variable> <opt typed value initializer>

<opt typed value initializer> ::=

[ [ <typed> ] <value type> ] <value initializer>

« WG3:UTC-045R1 deleted one production »

<value initializer> ::=

<equals operator> <value expression>

Syntax Rules

« WG3:UTC-045R1 deleted one SR »

« WG3:UTC-045R1 »

1)

Let VVD be the <value variable definition> .

2)

Let VN be the name of the <value variable> immediately contained in VVD.

3)

Let OTVI be the <opt typed value initializer> immediately contained in VVD.

4)

Let VI be the <value initializer> immediately contained in OTVI.

5)

The declared type of VI is the declared type of the <value expression> immediately contained in VI.

6)

Let WRT be the declared type of the incoming working record of VVD.

« WG3:UTC-045R1 deleted one SR »

7)

WRT shall not have a field type whose field name is VN.

« WG3:UTC-045R1 deleted one SR »

« WG3:UTC-045R1 »

8)

Let the value type VT be defined as follows.

Case:

a)

Let VIT be the declared type of VI.

b)

Case:

i)

If OTVI immediately contains a <value type> OVT, then:

1)

The Syntax Rules of Subclause 22.1, “Store assignment” , are applied with a tran-

sient site of type OVT as TARGET and the <value expression> immediately contained in VI as VALUE.

2)

VT is the type specified by OVT.

ii)

Otherwise, VT is VIT.

124

IWD 39075:202y(E)

10.3 <value variable definition>

9)

The declared type of the outgoing working record of VVD is a record type comprising all the field

types of WRT and one additional field type with field name VN and field value type VT.

« WG3:UTC-045R1 deleted one SR »

General Rules

« WG3:UTC-045R1 »

1)

The result of VI is the result of the <value expression> immediately contained in VI.

2)

Let ROVI be the result of VI.

3)

Add a field with field name VN and field value ROVI to the current working record.

« WG3:UTC-045R1 deleted one GR »

Conformance Rules

None.

125





IWD 39075:202y(E)

11 Object expressions

« WG3:UTC-042 deleted an editor's note »

11.1 <graph expression>

Function

Specify a graph reference value.

Format

« WG3:UTC-039R1 »

<graph expression> ::=

<nested graph query specification>

| <object expression primary>

| <graph reference>

| <object name or binding variable>

| <current graph>

« WG3:UTC-039R1 Deleted 1 (one) editor's note »

« WG3:UTC-039R1 »

<current graph> ::=

CURRENT_PROPERTY_GRAPH | CURRENT_GRAPH

<nested graph query specification> ::=

<nested query specification>

Syntax Rules

1)

Let GE be the <graph expression>.

« WG3:UTC-039R1 Deleted 3 SRs »

2)

The declared type of a <nested graph query specification> shall be a graph reference value type.

« WG3:UTC-039R1 »

3)

If GE is an <object name or binding variable> that is a <regular identifier> RI, then Case:

a)

If RI is a valid <binding variable reference> whose incoming working record’s declared type

is the declared type of the incoming working record of GE, then GE is effectively replaced by

the <object expression primary>:

VARIABLE RI

NOTE 112 — RI is only a valid <binding variable reference> , if a binding variable referenced by RI is available to GE, i.e., if the declared type of the incoming working record of GE has a field type whose name is the name of the referenced binding variable of RI, cf. Subclause 16.3, “<binding variable reference>”

b)

Otherwise, GE is effectively replaced by the <graph reference>:

126

IWD 39075:202y(E)

11.1 <graph expression>

./ RI

NOTE 113 — This syntax transformation removes <object name or binding variable> as an alternative of

<graph expression>, so that this alternative has not to be considered subsequently.

« WG3:UTC-039R1 »

4)

The declared type of GE is defined as follows:

Case:

a)

If GE is a <nested graph query specification> NGQS, then the declared type of GE is the declared type of NGQS.

b)

If GE implicitly or explicitly specifies VARIABLE, then:

i)

Let VEP be the <value expression primary> simply contained in GE.

ii)

The declared type of VEP shall be a material graph reference value type.

iii)

The declared type of GE is the declared type of VEP.

c)

If GE is a <graph reference> GR which identifies a graph G, then:

Case:

i)

If G has a constraining graph type CGT, then the declared type of GE is the graph refer-

ence value type whose constraining object type is CGT.

ii)

Otherwise, the declared type of GE is the open graph reference value type.

d)

Otherwise, GE is a <current graph> and

i)

Let CWG be the current working graph available at GE.

NOTE 114 — If no current working graph is available at GE, then this rule cannot be satisfied. See

Subclause 4.7.3, “Working objects”.

ii)

The declared type of GE is the declared type of CWG.

General Rules

1)

The result of GE is the graph reference value GRV determined as follows.

Case:

a)

If GE simply contains the <nested graph query specification> NGQS, then GRV is the result of NGQS.

« WG3:UTC-039R1 »

b)

If GE implicitly or explicitly specifies VARIABLE, then GRV is the result of the <value expression

primary> simply contained in GE.

c)

If GE simply contains the <graph reference> GR, then GRV is a graph reference value whose referent is the graph identified by GR.

« WG3:UTC-039R1 »

d)

Otherwise, GE is a <current graph> and GRV is a graph reference value whose referent is the graph held by CWG.

127

IWD 39075:202y(E)

11.1 <graph expression>

Conformance Rules

« WG3:UTC-039R1 »

1)

Without Feature GD07, “Graph reference value types”, in conforming GQL language, a <graph

expression> GE shall not be a <nested graph query specification> and shall not be an <object name

or binding variable> that is a <regular identifier> that is a valid <binding variable reference> whose incoming working record’s declared type is the declared type of the incoming working record of

GE.

NOTE 115 — Without Feature GD08, “Binding table reference value types”, <graph expression> is limited to references to graphs in the catalog and the current working graph.

128





IWD 39075:202y(E)

11.2 <binding table expression>

11.2 <binding table expression>

Function

Specify a binding table reference value.

Format

« WG3:UTC-039R1 »

<binding table expression> ::=

<nested binding table query specification>

| <object expression primary>

| <binding table reference>

| <object name or binding variable>

« WG3:UTC-039R1 Deleted 1 (one) editor's note »

<nested binding table query specification> ::=

<nested query specification>

Syntax Rules

1)

Let BTE be the <binding table expression> .

« WG3:UTC-039R1 Deleted 3 SRs »

2)

The declared type of a <nested binding table query specification> shall be a binding table type or

a binding table reference value type.

« WG3:UTC-039R1 »

3)

If BTE is an <object name or binding variable> that is a <regular identifier> RI, then Case:

a)

If RI is a valid <binding variable reference> whose incoming working record’s declared type

is the declared type of the incoming working record of BTE, then BTE is effectively replaced

by the <object expression primary> :

VARIABLE RI

NOTE 116 — RI is only a valid <binding variable reference> , if a binding variable referenced by RI is available to BTE, i.e., if the declared type of the incoming working record of BTE has a field type whose name is the

name of the referenced binding variable of RI, cf. Subclause 16.3, “<binding variable reference>”.

b)

Otherwise, BTE is effectively replaced by the <binding table reference>:

./ RI

NOTE 117 — This syntax transformation removes <object name or binding variable> as an alternative of

<binding table expression> , so that this alternative has not to be considered subsequently.

4)

The declared type of BTE is defined as follows.

Case:

a)

If BTE is a <nested binding table query specification> NBTQS, then the declared type of BTE

is the declared type of NBTQS.

b)

If BTE implicitly or explicitly specifies VARIABLE, then:

i)

Let VEP be the <value expression primary> simply contained in BTE.

129

IWD 39075:202y(E)

11.2 <binding table expression>

ii)

The declared type of VEP shall be a material binding table reference value type.

iii)

The declared type of BTE is the declared type of VEP.

c)

If BTE is a <binding table reference> BTR which identifies a binding table BT, then the declared type of BTE is a material binding table reference value type whose constraining object type

is the binding table type of BT.

General Rules

1)

The result of BTE is the binding table reference value BTRV determined as follows.

Case:

a)

If BTE simply contains the <nested binding table query specification> NBTQS, then

Case:

i)

If the result of the <nested query specification> immediately contained in NBTQS is a

binding table reference value V, then BTRV is V.

ii)

Otherwise, BTRV is a binding table reference value whose referent is the binding table

that is the result of the <nested query specification> immediately contained in NBTQS.

« WG3:UTC-039R1 »

b)

If BTE implicitly or explicitly specifies VARIABLE, then BTRV is the result of the <value

expression primary> simply contained in BTE.

c)

If BTE simply contains the <binding table reference> BTR, then BTRV is a binding table reference value whose referent is the binding table identified by BTR.

Conformance Rules

« WG3:UTC-039R1 »

1)

Without Feature GD08, “Binding table reference value types”, in conforming GQL language, a

<binding table expression> BTE shall not be a <nested binding table query specification> and shall not be an <object name or binding variable> that is a <regular identifier> that is a valid <binding

variable reference> whose incoming working record’s declared type is the declared type of the

incoming working record of BTE.

« WG3:UTC-0421 (one) Subclause moved »

130





IWD 39075:202y(E)

11.3 <object expression primary>

11.3 <object expression primary>

Function

Specify an <object expression primary> .

« WG3:UTC-039R1 »

Format

<object expression primary> ::=

VARIABLE <value expression primary>

| <parenthesized value expression>

| <non-parenthesized value expression primary special case>

Syntax Rules

« WG3:UTC-039R1 »

1)

If an <object expression primary> OEP is specified that does not specify VARIABLE, then OEP is effectively replaced by:

VARIABLE OEP

NOTE 118 — This syntax transformation removes <parenthesized value expression> and <non-parenthesized value

expression primary special case> as alternatives of <object expression primary> , so that these alternatives do not have to be considered subsequently.

General Rules

None.

Conformance Rules

None.

« WG3:UTC-122 deleted one Clause »

131





IWD 39075:202y(E)

12 Catalog-modifying statements

** Editor’s Note (number 13) **

The GQL schema and metagraph need to be defined together with the statements to manipulate it. See Language Opportunity

GQL-004 .

12.1 <linear catalog-modifying statement>

Function

Specify a linear composition of <simple catalog-modifying statement>s.

Format

<linear catalog-modifying statement> ::=

<simple catalog-modifying statement>...

« WG3:UTC-122 »

<simple catalog-modifying statement> ::=

<primitive catalog-modifying statement>

| <call catalog-modifying procedure statement>

<primitive catalog-modifying statement> ::=

<create schema statement>

| <create graph statement>

| <create graph type statement>

| <drop schema statement>

| <drop graph statement>

| <drop graph type statement>

Syntax Rules

1)

Let LCMS be the <linear catalog-modifying statement>.

« WG3:UTC-096R1 Deleted 4 SRs »

« WG3:UC-096R1 »

2)

The declared type of the outgoing working record of LCMS is the declared type of the incoming

working record of LCMS.

3)

The declared type of the outgoing working table of LCMS is the declared type of the incoming

working table of LCMS.

4)

LCMS has no declared type.

General Rules

« WG3:UTC-059 »

132

IWD 39075:202y(E)

12.1 <linear catalog-modifying statement>

1)

If the current transaction access mode is READ ONLY, then an exception condition is raised: invalid

transaction state — read-only transaction (25G03).

« WG3:UTC-096R1 »

2)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

None.

133





IWD 39075:202y(E)

12.2 <create schema statement>

12.2 <create schema statement>

Function

Create a schema.

Format

« WG3:UTC-058R3 »

<create schema statement> ::=

CREATE SCHEMA [ IF NOT EXISTS ] <catalog schema parent and name>

Syntax Rules

1)

Let CSPN be the <catalog schema parent and name> .

2)

Let ADP be the <absolute directory path> immediately contained in CSPN. ADP shall identify a GQL-directory.

3)

Let PARENT be the GQL-directory identified by ADP.

4)

Let SN be the <schema name> immediately contained in CSPN.

5)

If IF NOT EXISTS is not specified, then SN shall not identify an existing GQL-schema descriptor in

PARENT.

General Rules

1)

If IF NOT EXISTS is specified and SN identifies an existing GQL-schema descriptor in PARENT, then

no further General Rules of this Subclause are applied.

2)

Let S be a new GQL-schema.

3)

The associated GQL-schema descriptor SD of S is created that comprises:

a)

The current authorization identifier as the owner of S.

b)

An empty set as the set of named subobjects of S.

4)

SD is inserted into PARENT with the name SN.

Conformance Rules

« WG3:UTC-052 »

1)

Without Feature GM01, “Graph schema management”, conforming GQL language shall not contain

a <create schema statement>.

« WG3:UTC-058R3 »

2)

Without Feature GM02, “Graph schema management exists”, conforming GQL language shall not

contain a <create schema statement> that includes IF NOT EXISTS.

134





IWD 39075:202y(E)

12.3 <drop schema statement>

12.3 <drop schema statement>

Function

Destroy a schema.

Format

« WG3:UTC-058R3 »

<drop schema statement> ::=

DROP SCHEMA [ IF EXISTS ] <catalog schema parent and name>

Syntax Rules

1)

Let CSPN be the <catalog schema parent and name> .

« WG3:UTC-009 P00-USA-169 »

2)

If CSPN is the current working schema, then an exception condition is raised: syntax error or access

rule violation — cannot drop the current working schema (42003).

3)

Let ADP be the <absolute directory path> immediately contained in CSPN. ADP shall identify a GQL-directory.

4)

Let PARENT be the GQL-directory identified by ADP.

5)

Let SN be the <schema name> immediately contained in CSPN.

6)

If IF EXISTS is not specified, then SN shall identify an existing GQL-schema descriptor in PARENT.

7)

If SN identifies an existing GQL-schema descriptor SD in PARENT, then SD shall not contain any catalog object descriptors.

General Rules

1)

If IF EXISTS is specified and SN does not identify an existing GQL-schema descriptor in PARENT,

then no further General Rules of this Subclause are applied.

2)

SD is removed from PARENT under the name SN and SD is destroyed.

Conformance Rules

« WG3:UTC-052 »

1)

Without Feature GM01, “Graph schema management”, conforming GQL language shall not contain

a <drop schema statement>.

« WG3:UTC-058R3 »

2)

Without Feature GM02, “Graph schema management exists”, conforming GQL language shall not

contain a <drop schema statement> that includes IF EXISTS.

135





IWD 39075:202y(E)

12.4 <create graph statement>

12.4 <create graph statement>

Function

Create a graph.

Format

« Editorial: Rationalise BNF »

« WG3:UTC-058R3 »

<create graph statement> ::=

CREATE { [ PROPERTY ] GRAPH [ IF NOT EXISTS ] | OR REPLACE [ PROPERTY ] GRAPH }

<catalog graph parent and name> { <open graph type> | <of graph type> }

[ <graph source> ]

<open graph type> ::=

OPEN [ [ PROPERTY ] GRAPH ] TYPE

<of graph type> ::=

<graph type like graph>

| [ <typed> ] <graph type reference>

| [ <typed> ] <nested graph type specification>

<graph type like graph> ::=

LIKE <graph expression>

<graph source> ::=

AS COPY OF <graph expression>

Syntax Rules

1)

Let CGS be the <create graph statement>.

2)

Let CGPN be the <catalog graph parent and name> immediately contained in CGS.

3)

Let COPR be the explicit or implicit <catalog object parent reference> immediately contained in CGPN. COPR shall identify a GQL-schema.

4)

Let SCHEMA be the GQL-schema identified by COPR.

5)

Let GN be the <graph name> immediately contained in CGPN.

6)

If CGS does not immediately contain IF NOT EXISTS or OR REPLACE, then CGPN shall not identify

an existing graph.

General Rules

1)

If IF NOT EXISTS is specified and CGPN identifies an existing graph, then no further General Rules

of this Subclause are applied.

2)

If CGS immediately contains OR REPLACE and CGPN identifies an existing graph, then the following

<drop graph statement> is effectively executed:

DROP GRAPH CGPN

136

IWD 39075:202y(E)

12.4 <create graph statement>

3)

Let NGTN be a new system-generated <graph type name> that does not identify an existing catalog object in SCHEMA.

4)

Let NCGTPN be the <catalog graph type parent and name> :

COPR NGTN

5)

If CGS immediately contains an <of graph type> that immediately contains the <graph type like

graph> GTLG, then the following <create graph type statement> is effectively executed: CREATE GRAPH TYPE NCGTPN GTLG

6)

If CGS immediately contains an <of graph type> that immediately contains the <nested graph type

specification> GTS, then the following <create graph type statement> is effectively executed: CREATE GRAPH TYPE NCGTPN GTS

7)

If CGS immediately contains a <graph source> that immediately contains the <graph expression>

GE and the referent of the graph reference value that is the result of GE has a graph type and CGS

does not immediately contain an <open graph type> , then the following <create graph type state-

ment> is effectively executed:

CREATE GRAPH TYPE NCGTPN LIKE GE

8)

Let G be a new empty graph.

9)

Let the graph type GT be determined as follows.

Case:

a)

If CGS immediately contains an <open graph type> , then GT is not defined.

b)

If CGS immediately contains an <of graph type> that immediately contains the <graph type

reference> GTR, then GT is the graph type identified by GTR.

c)

Otherwise, GT is the graph type identified by NCGTPN.

10) If CGS immediately contains a <graph source> that immediately contains the <graph expression>

GE, then G is populated as follows:

a)

Let SG be the referent of the graph reference value that is the result of GE.

b)

If GT is defined and SG is not of graph type GT, then an exception condition is raised: graph

type violation (G2000).

c)

Copies of all nodes and edges in SG are inserted into G. Each copy of a node and each copy of

an edge is associated with a new global object identifier.

11) The associated graph descriptor GD of G is created such that the graph type of GD is determined as follows.

Case:

a)

If GT is defined, then the constraining graph type of GD is GT.

b)

Otherwise, GD has no constraining graph type.

12) GD is inserted into SCHEMA with the name GN.

137

IWD 39075:202y(E)

12.4 <create graph statement>

Conformance Rules

« WG3:UTC-052 »

1)

Without Feature GM04, “Graph management”, conforming GQL language shall not contain a <create

graph statement>.

« WG3:UTC-058R3 »

2)

Without Feature GM05, “Graph management exists”, conforming GQL language shall not contain a

<create graph statement> that includes IF NOT EXISTS.

3)

Without Feature GA00, “Graph with an open graph type”, in conforming GQL language a <create

graph statement> shall not contain an <open graph type> .

4)

Without Feature GA01, “Graph with a closed graph type”, in conforming GQL language a <create

graph statement> shall not contain an <of graph type>.

5)

Without Feature GA02, “Graph Type inline specification”, in conforming GQL language a <create

graph statement> shall not contain an <of graph type> that contains a <nested graph type specific-

ation> .

6)

Without Feature GA03, “Graph Type like a graph”, in conforming GQL language a <create graph

statement> shall not contain an <of graph type> that contains a <graph type like graph> .

7)

Without Feature GA04, “Graph from a source”, in conforming GQL language a <create graph state-

ment> shall not contain a <graph source>.

138





IWD 39075:202y(E)

12.5 <drop graph statement>

12.5 <drop graph statement>

Function

Destroy a graph.

Format

« WG3:UTC-058R3 »

<drop graph statement> ::=

DROP [ PROPERTY ] GRAPH [ IF EXISTS ] <catalog graph parent and name>

Syntax Rules

1)

Let DGS be the <drop graph statement> and let CGPN be the <catalog graph parent and name>.

2)

Let COPR be the explicit or implicit <catalog object parent reference> immediately contained in CGPN. COPR shall identify a GQL-schema.

3)

Let SCHEMA be the GQL-schema identified by COPR.

4)

Let GN be the <graph name> immediately contained in CGPN.

5)

If DGS does not immediately contain IF EXISTS, then CGPN shall identify an existing graph.

General Rules

1)

If DGS immediately contains IF EXISTS and CGPN does not identify an existing graph, then a comple-

tion condition is raised: warning — graph does not exist (01G03) and no further General Rules of

this Subclause are applied.

2)

Let G be the graph identified by CGPN and let GD be the graph descriptor of G.

3)

Let GT be the graph type of G.

4)

GD is removed from SCHEMA under the name GN and GD is destroyed.

5)

If GT has a system-generated name and GT is not the graph type of any other graph in the GQL-

catalog, then the graph type descriptor of GT is destroyed.

Conformance Rules

« WG3:UTC-052 »

1)

Without Feature GM04, “Graph management”, conforming GQL language shall not contain a <drop

graph statement>.

« WG3:UTC-058R3 »

2)

Without Feature GM05, “Graph management exists”, conforming GQL language shall not contain a

<drop graph statement> that includes IF EXISTS.

139





IWD 39075:202y(E)

12.6 <create graph type statement>

12.6 <create graph type statement>

Function

Create a graph type.

Format

« Editorial: Rationalise BNF »

« WG3:UTC-058R3 »

<create graph type statement> ::=

CREATE

{ [ PROPERTY ] GRAPH TYPE [ IF NOT EXISTS ] | OR REPLACE [ PROPERTY ] GRAPH TYPE }

<catalog graph type parent and name> <graph type source>

<graph type source> ::=

[ AS ] <copy of graph type>

| <graph type like graph>

| [ AS ] <nested graph type specification>

<copy of graph type> ::=

COPY OF { <graph type reference> | <external object reference> }

Syntax Rules

1)

Let CGTS be the <create graph type statement> and let CGTPN be the <catalog graph type parent

and name> immediately contained in CGTS.

2)

Let COPR be the implicit or explicit <catalog object parent reference> immediately contained in CGTPN. COPR shall identify a GQL-schema.

3)

Let SCHEMA be the GQL-schema identified by COPR.

4)

Let GTN be the <graph type name> immediately contained in CGTPN.

5)

If CGTS does not immediately contain IF NOT EXISTS or OR REPLACE, then CGTPN shall not identify

an existing graph type.

6)

Let GTS be the <graph type source> immediately contained in GTS.

7)

Let the graph type OGT be defined as follows.

Case:

a)

If GTS immediately contains the <copy of graph type> COGT, then OGT is the graph type identified by the <graph type reference> or the <external object reference> immediately contained in COGT.

b)

If GTS immediately contains a <graph type like graph> GTLG, then let GE be the <graph

expression> immediately contained in GTLG, then:

« WG3:UTC-086R1 »

i)

The declared type of GE shall have a constraining object type.

ii)

OGT is the constraining object type of the declared type of GE.

c)

Otherwise, OGT is not defined.

140

IWD 39075:202y(E)

12.6 <create graph type statement>

General Rules

1)

If IF NOT EXISTS is specified and CGTPN identifies an existing graph type, then no further General

Rules of this Subclause are applied.

2)

If CGTS immediately contains OR REPLACE and CGTPN identifies an existing graph type, then the

following <drop graph type statement> is effectively executed:

DROP GRAPH TYPE CGTPN

« WG3:UTC-049 »

3)

Let the graph type GT and the graph type descriptor GTD be defined as follows.

Case:

a)

If OGT is defined, then GT is the graph type described by the graph type descriptor GTD com-

prising:

« WG3:UTC-015 »

i)

The name of the associated base type of all graph types (PROPERTY GRAPH DATA).

ii)

A copy of the node type set of OGT as the node type set.

iii)

A copy of the edge type set of OGT as the edge type set.

iv)

A copy of the node type name dictionary of OGT as the node type name dictionary.

v)

A copy of the edge type name dictionary of OGT as the edge type name dictionary.

b)

Otherwise, GT is the graph type described by the graph type descriptor GTD that is defined

by the <nested graph type specification> immediately contained in GTS.

4)

The associated graph type descriptor GTD of GT is created.

5)

GTD is inserted into SCHEMA with the name GTN.

Conformance Rules

1)

Without Feature GA01, “Graph with a closed graph type”, conforming GQL language shall not contain

a <create graph type statement> .

« WG3:UTC-058R3 »

2)

Without Feature GM03, “Graph type exists”, conforming GQL language shall not contain a <create

graph type statement> that includes IF NOT EXISTS.

« WG3:UTC-0426 Subclauses moved »

141





IWD 39075:202y(E)

12.7 <drop graph type statement>

12.7 <drop graph type statement>

Function

Destroy a graph type.

Format

« WG3:UTC-058R3 »

<drop graph type statement> ::=

DROP [ PROPERTY ] GRAPH TYPE [ IF EXISTS ] <catalog graph type parent and name>

Syntax Rules

1)

Let DGTS be the <drop graph type statement> and CGTPN be the <catalog graph type parent and

name> .

2)

Let COPR be the explicit or implicit <catalog object parent reference> immediately contained in CGTPN. COPR shall identify a GQL-schema.

3)

Let SCHEMA be the GQL-schema identified by COPR.

4)

Let GTN be the <graph type name> immediately contained in CGTPN.

5)

If DGTS does not immediately contain IF EXISTS, then CGTPN shall identify an existing graph type.

6)

If CGTPN identifies an existing graph type, then the graph type identified by CGTPN shall not be

referenced by any existing graph in the GQL-catalog.

General Rules

1)

If DGTS immediately contains IF EXISTS and CGTPN does not identify an existing graph type, then

a completion condition is raised: warning — graph type does not exist (01G04) and no further General

Rules of this Subclause are applied.

2)

Let GT be the graph type identified by CGTPN and let GTD be the graph descriptor of GT.

3)

GTD is removed from SCHEMA under the name GTN and GTD is destroyed.

Conformance Rules

1)

Without Feature GA01, “Graph with a closed graph type”, conforming GQL language shall not contain

a <drop graph type statement> .

« WG3:UTC-058R3 »

2)

Without Feature GM03, “Graph type exists”, conforming GQL language shall not contain a <drop

graph type statement> that includes IFEXISTS.

142





IWD 39075:202y(E)

12.8 <call catalog-modifying procedure statement>

12.8 <call catalog-modifying procedure statement>

Function

« WG3:UTC-096R1 »

Execute a catalog-modifying procedure.

Format

<call catalog-modifying procedure statement> ::=

<call procedure statement>

Syntax Rules

1)

Let CCPS be the <call catalog-modifying procedure statement> , let CPS be the <call procedure

statement> immediately contained in CCPS, and let PC be the <procedure call> immediately contained in CPS.

2)

If PC is an <inline procedure call> that immediately contains the <nested procedure specification>

PROC, then PROC shall shall immediately contain a <catalog-modifying procedure specification> .

3)

If PC is a <named procedure call> that immediately contains the <procedure reference> that identifies a procedure PROC, then PROC shall have the CATALOG PROCEDURE indication.

General Rules

None.

Conformance Rules

None.

143





IWD 39075:202y(E)

13 Data-modifying statements

« WG3:UTC-096R1 deleted an editor's note »

13.1 <linear data-modifying statement>

Function

Specify a linear composition of at least one <simple data-modifying statement> with <simple query

statement>s and <simple data-accessing statement>s.

Format

<linear data-modifying statement> ::=

<focused linear data-modifying statement>

| <ambient linear data-modifying statement>

<focused linear data-modifying statement> ::=

<focused linear data-modifying statement body>

| <focused nested data-modifying procedure specification>

« WG3:UTC-122 »

<focused linear data-modifying statement body> ::=

<use graph clause> <simple linear data-accessing statement>

[ <primitive result statement> ]

<focused nested data-modifying procedure specification> ::=

<use graph clause> <nested data-modifying procedure specification>

<ambient linear data-modifying statement> ::=

<ambient linear data-modifying statement body>

| <nested data-modifying procedure specification>

« WG3:UTC-122 »

<ambient linear data-modifying statement body> ::=

<simple linear data-accessing statement> [ <primitive result statement> ]

<simple linear data-accessing statement> ::=

<simple data-accessing statement>...

« WG3:UTC-122 »

<simple data-accessing statement> ::=

<simple query statement>

| <simple data-modifying statement>

<simple data-modifying statement> ::=

<primitive data-modifying statement>

| <call data-modifying procedure statement>

<primitive data-modifying statement> ::=

<insert statement>

| <set statement>

| <remove statement>

| <delete statement>

144

IWD 39075:202y(E)

13.1 <linear data-modifying statement>

Syntax Rules

1)

Let LDMS be the <linear data-modifying statement> .

« WG3:UTC-009 P00-USA-169 »

« WG3:UTC-101 »

2)

If the <focused linear data-modifying statement body> does not immediately contain a <primitive

result statement> , then FINISH is implicit.

3)

If the <ambient linear data-modifying statement body> does not immediately contain a <primitive

result statement> , then FINISH is implicit.

« WG3:UTC-096R1 »

4)

Let STMSEQ be the sequence of <simple data-accessing statement>s, the <primitive result statement>,

and the <nested data-modifying procedure specification> directly contained in LDMS, let m be the number of elements of STMSEQ and let STMj, 1 (one) ≤ j ≤ m, be the j-th element of STMSEQ.

5)

STMSEQ shall contain at least one <simple data-modifying statement>.

6)

The declared type of the incoming working record of STM 1 is the declared type of the incoming

working record of LDMS.

« WG3:UTC-096R1 »

7)

The declared type of the incoming working table of STM 1 is the declared type of the incoming

working table of LDMS.

8)

For 2 (two) ≤ j ≤ m:

a)

The declared type of the incoming working record of STMj is the declared type of the outgoing

working record of STMj-1.

b)

The declared type of the incoming working table of STMj is the declared type of the outgoing

working table of STMj-1.

9)

The declared type of LDMS is the declared type of STMm.

General Rules

« WG3:UTC-059 »

1)

If the current transaction access mode is READ ONLY, then an exception condition is raised: invalid

transaction state — read-only transaction (25G03).

Conformance Rules

« WG3:UTC-047 »

1)

Without Feature GE06, “Use Graph Support”, conforming GQL language shall not contain a <focused

linear data-modifying statement>.

« WG3:UTC-116 »

2)

Without Feature GC26, “Updatable graphs”, conforming GQL language shall not contain a <simple

data-modifying statement> .

145





IWD 39075:202y(E)

13.2 <insert statement>

13.2 <insert statement>

Function

Insert new nodes and edges into the current working graph.

** Editor’s Note (number 14) **

Discussion paper WG3:MMX-047 suggests the addition of a “Time To Live” option, which would require specified graph elements

be deleted after a certain time to save storage space. See Language Opportunity GQL-035 .

Format

<insert statement> ::=

INSERT <insert graph pattern>

« WG3:OHD-012 should have deleted one one redundant production »

** Editor’s Note (number 15) **

Consider allowing a single optional <where clause>. See Language Opportunity GQL-169 .

Syntax Rules

1)

Let IS be the <insert statement>.

2)

Let IGP be the <insert graph pattern> immediately contained in IS.

« WG3:UTC-094 »

3)

Let IDNSET be the implementation-assigned variable names of IGP.

« WG3:UTC-094 deleted one SR »

4)

Let NEWCOLS be a set of columns determined as follows. For every <insert path pattern> IPP

immediately contained in IGP, for every insert element pattern IEP immediately contained in IPP

that declares an element variable EV with name EVN that is not a bound insert element pattern:

NOTE 119 — Insert element patterns and bound insert element patterns are defined in GR 8) and GR 9) of

Subclause 16.11, “<insert graph pattern>” .

a)

Let COLTYPE be determined as follows.

Case:

i)

If IEP is an <insert node pattern>, then COLTYPE is a node reference value type that is determined using an implementation-defined (IW012) mechanism such that it includes

all reference values to nodes that may be bound to EV by IS.

ii)

Otherwise, IEP is an <insert edge pattern> and COLTYPE is an edge reference value

type that is determined using an implementation-defined (IW013) mechanism such

that it includes all reference values to edges that may be bound to EV by IS.

b)

Let COL be the column whose name is EVN and whose type is COLTYPE.

c)

Include COL in NEWCOLS.

d)

If COLTYPE is a closed graph element reference value type, then for every <property key value

pair> PKVP contained in IEP:

146

IWD 39075:202y(E)

13.2 <insert statement>

« WG3:UTC-086R1 »

i)

Let PT be the property type in the constraining object type of COLTYPE identified by

the <property name> immediately contained in PKVP.

ii)

The Syntax Rules of Subclause 22.1, “Store assignment” , are applied with a transient

site of type PT as TARGET and the <value expression> immediately contained in PKVP

as VALUE.

« WG3:UTC-094 deleted one SR »

« WG3:UTC-094 »

5)

Let CWG be the current working graph available at IS.

NOTE 120 — If no current working graph is available at IS, then this rule cannot be satisfied. See Subclause 4.7.3,

“Working objects” .

6)

The declared type of the outgoing working table of IS is the material binding table type whose set

of columns is the union of all columns of the declared type of incoming working table of IS and all

columns from NEWCOLS without the columns identified by the names in IDNSET.

7)

The declared type of the outgoing working record of IS is the declared type of the incoming working

record of IS.

8)

IS has no declared type.

General Rules

« WG3:UTC-062 deleted en editor's note »

1)

Let TABLE be the current working table.

2)

Let NEW_TABLE be a new empty binding table whose columns are the union of all columns of the

declared type of TABLE and all columns from NEWCOLS.

3)

For every record R of TABLE in a new child execution context amended with R:

a)

Let CR be a new record whose field types are the elements of NEWCOLS and whose fields are

determined by processing each <insert path pattern> IPP immediately contained in IGP as follows:

« WG3:UTC-094 »

i)

For every i-th <insert node pattern> INP immediately contained in IPP that declares an element variable EV with name EVN that is the defining insert element pattern of

EV, and is not a bound insert element pattern:

NOTE 121 — The defining insert element patterns of an <element variable> are defined in SR 11)b)

of Subclause 16.11, “<insert graph pattern>” .

1)

Let the set of label names LNS be determined as follows.

Case:

A)

If INP immediately contains a <label set specification> LSS, then LNS shall be the set of label names specified by LSS.

B)

Otherwise, LNS is the empty set.

2)

If the cardinality of LNS is less than the implementation-defined (IL001) node

label set minimum cardinality, then an exception condition is raised: data exception

— number of node labels below supported minimum (22G0N).

147

IWD 39075:202y(E)

13.2 <insert statement>

3)

If the cardinality of LNS is greater than the implementation-defined (IL003) node

label set maximum cardinality, then an exception condition is raised: data

exception — number of node labels exceeds supported maximum (22G0P).

4)

Let the set of properties PS be determined as follows.

Case:

A)

If INP simply contains a <property key value pair list> PKVPL, then PS is the list of all properties computed as follows. For each <property key value

pair> PKVP in PKVPL:

I)

Let PROP be a new property.

« Correct application of W24-035R2 »

II)

The name of PROP is the name specified by the <property name>

immediately contained in PKVP.

III)

The General Rules of Subclause 22.1, “Store assignment”, are applied

with PROP as TARGET and the <value expression> immediately con-

tained in PKVP as VALUE.

IV)

Include PROP in PS.

B)

Otherwise, PS is the empty set.

5)

If the cardinality of PS is greater than the implementation-defined (IL004) node

property set maximum cardinality, then an exception condition is raised: data

exception — number of node properties exceeds supported maximum (22G0S).

6)

Schedule the insertion of a new node NN into CWG.

NOTE 122 — Scheduled insertions of new nodes are performed by the application of GR 4) of

this Subclause.

A)

NN is associated with a new global object identifier.

B)

The node label set of NN is LNS.

C)

The node property set of NN is PS.

7)

Let NRi be the node reference value for NN.

8)

The field whose name is EVN and whose value is NRi is included in CR.

« WG3:UTC-094 »

ii)

For every i-th <insert edge pattern> IEP immediately contained in IPP that declares an element variable EV with name EVN:

1)

Let the set of label names LNS be determined as follows.

Case:

A)

If IEP immediately contains a <label set specification> LSS, then LNS shall be the set of label names specified by LSS.

B)

Otherwise, LNS is the empty set.

2)

If the cardinality of LNS is less than the implementation-defined (IL002) edge

label set minimum cardinality, then an exception condition is raised: data exception

— number of edge labels below supported minimum (22G0Q).

148

IWD 39075:202y(E)

13.2 <insert statement>

3)

If the cardinality of LNS is greater than the implementation-defined (IL005) edge

label set maximum cardinality, then an exception condition is raised: data

exception — number of edge labels exceeds supported maximum (22G0R).

4)

Let the set of properties PS be determined as follows.

Case:

A)

If IEP simply contains a <property key value pair list> PKVPL, then PS is the list of all properties computed as follows. For each <property key value

pair> PKVP in PKVPL:

I)

Let PROP be a new property.

II)

The name of PROP is the name specified by the <property name>

immediately contained in PKVP.

III)

The General Rules of Subclause 22.1, “Store assignment”, are applied

with PROP as TARGET and the <value expression> immediately con-

tained in PKVP as VALUE.

IV)

Include PROP in PS.

B)

Otherwise, PS is the empty set.

5)

If the cardinality of PS is greater than the implementation-defined (IL006) edge

property set maximum cardinality, then an exception condition is raised: data

exception — number of edge properties exceeds supported maximum (22G0T).

6)

Let the left endpoint N left be determined as follows:

A)

Let INP left be the rightmost <insert node pattern> that precedes IEP in IPP.

B)

Case:

I)

If INP left simply contains a <binding variable> BV whose name is the

field name of a column of the incoming working record, then N left is

the result of BV.

II)

Otherwise, N left is NRi.

NOTE 123 — NRi is the reference value for the node created to represent INP left.

This value is always defined here.

7)

Let the right endpoint N right be determined as follows:

A)

Let INP right be the leftmost <insert node pattern> that follows IEP in IPP.

B)

Case:

I)

If INP right simply contains a <binding variable> BV whose name is

the field name of a column of the incoming working record, then

N right is the result of BV.

II)

Otherwise, N right is NRi+1.

NOTE 124 — NRi+1 is the reference value for the node created to represent

INP right. This value is always defined here.

8)

If either N left or N right is deleted, then an exception condition is raised: data

exception — multiple assignments to a graph element property (22G0M).

149

IWD 39075:202y(E)

13.2 <insert statement>

9)

If either N left or N right is not in CWG, then an exception condition is raised: data

exception — multiple assignments to a graph element property (22G0M).

10) If N left and N right are both nodes, then:

A)

Let the <edge kind> EK be determined as follows. If IEP immediately contains

a <full edge undirected> , then EK is UNDIRECTED; otherwise, EK is DIREC-

TED

« Email from: Jim Melton 2022-12-08 0219 »

B)

Let N left2 and N right2 be determined as follows. If EK is DIRECTED and IEP

contains a <full edge pointing left>, then N left2 is N right and N right2 is N left; otherwise, N left2 is N left and N right2 is N right.

11) Schedule the insertion of a new edge NE into CWG.

NOTE 125 — Scheduled insertions of new edges are performed by the application of GR 5) of

this Subclause.

A)

NE is associated with a new global object identifier.

B)

The edge label set of NE is LNS.

C)

The edge property set of NE is PS.

« Email from: Jim Melton 2022-12-08 0219 »

D)

If EK is DIRECTED, then NE is a directed edge that connects the source node

N left2 to the destination node N right2; otherwise, EK is UNDIRECTED and

NE is an undirected edge that connects the endpoints N left2 and N right2.

12) Let ER be the edge reference value for NE.

13) The field whose name is EVN and whose value is ER is included in CR.

b)

Let NR be a new record constructed by amending R with CR.

c)

Append NR to NEW_TABLE.

4)

Perform all scheduled insertions of new nodes.

5)

Perform all scheduled insertions of new edges.

6)

If CWG has a graph type GT and CWG is not of graph type GT, then an exception condition is raised: graph type violation (G2000).

« WG3:UTC-094 »

7)

Set the current working table to NEW_TABLE without the columns identified by the names in IDNSET.

8)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

None.

150





IWD 39075:202y(E)

13.3 <set statement>

13.3 <set statement>

Function

Set graph element properties and labels.

Format

<set statement> ::=

SET <set item list>

<set item list> ::=

<set item> [ { <comma> <set item> }... ]

<set item> ::=

<set property item>

| <set all properties item>

| <set label item>

<set property item> ::=

<binding variable reference> <period> <property name> <equals operator> <value expression>

<set all properties item> ::=

<binding variable reference> <equals operator>

<left brace> [ <property key value pair list> ] <right brace>

<set label item> ::=

<binding variable reference> <is or colon> <label set specification>

<label set specification> ::=

<label name> [ { <ampersand> <label name> }... ]

** Editor’s Note (number 16) **

Consider allowing a single optional <where clause>. See Language Opportunity GQL-169 .

Syntax Rules

« WG3:UTC-094 deleted an editor's note »

1)

Let SS be the <set statement>.

2)

Let SIL be the <set item list> immediately contained in SS.

3)

For every <set item> SI immediately contained in SIL:

Case:

a)

If SI immediately contains a <set property item> SPI, then:

i)

The declared type of <binding variable reference> BVR immediately contained in SPI

shall be a graph element type.

ii)

The declared type of the <value expression> VE immediately contained in SPI shall be a supported property value type.

« WG3:UTC-015 deleted an editor's note »

iii)

If BVR refers to a closed graph element reference value type ERVT, then:

151

IWD 39075:202y(E)

13.3 <set statement>

« WG3:UTC-086R1 »

1)

Let PT be the property type in the constraining object type of ERVT identified by

the <property name> immediately contained in SPI.

2)

The Syntax Rules of Subclause 22.1, “Store assignment” , are applied with a tran-

sient site of type PT as TARGET and VE as VALUE.

b)

If SI immediately contains a <set all properties item> SAPI, then:

i)

The declared type of the <binding variable reference> BVR immediately contained in

SAPI shall be a graph element type.

ii)

For every <property key value pair> PKVP immediately contained in SAPI:

1)

The declared type of the <value expression> VE immediately contained in PKVP

shall be a supported property value type.

2)

If BVR refers to a closed graph element reference value type ERVT, then:

« WG3:UTC-086R1 »

A)

Let PT be the property type in the constraining object type of ERVT identified

by the <property name> immediately contained in PKVP.

B)

The Syntax Rules of Subclause 22.1, “Store assignment”, are applied with a

transient site of type PT as TARGET and VE as VALUE.

c)

If SI immediately contains a <set label item> SLI, then the declared type of <binding variable

reference> immediately contained in SLI shall be a graph element type.

« WG3:UTC-094 »

4)

No <set property item> immediately contained in SIL shall immediately contain a <binding variable

reference> and <property name> that are are both equivalent to the <binding variable reference>

and <property name> immediately contained in a different <set property item>.

5)

No <set all properties item> immediately contained in SIL shall immediately contain a <binding

variable reference> that is equivalent to the <binding variable reference> of any other <set all

properties item> or <set property item> in SIL.

6)

The declared type of the outgoing working table of SS is the declared type of the incoming working

table of SS.

7)

The declared type of the outgoing working record of SS is the declared type of the incoming working

record of SS.

8)

SS has no declared type.

General Rules

« WG3:UTC-062 deleted en editor's note »

1)

Let TABLE be the current working table.

2)

Let n be the number of records of TABLE and let m be the number of <set item> s immediately contained in SIL.

3)

For each i-th record Ri, 1 (one) ≤ i ≤ n, of TABLE, in a new child execution context amended with Ri: 152

IWD 39075:202y(E)

13.3 <set statement>

a)

For each j-th <set item> SIj, 1 (one) ≤ j ≤ m, immediately contained in SIL determine the graph element GEi, j as follows.

Case:

i)

If SIj immediately contains a <set property item> SPIj, then let GEi, j be the value of the

<binding variable reference> immediately contained in SPIj.

ii)

If SIj immediately contains a <set all properties item> SAPIj, then let GEi, j be the value of the <binding variable reference> immediately contained in SAPIj.

iii)

If SIj immediately contains a <set label item> SLIj, then let GEi, j be the value of the

<binding variable reference> immediately contained in SLIj.

b)

For each j-th <set item> SIj, 1 (one) ≤ j ≤ m, immediately contained in SIL determine the property value PVi, j as follows.

Case:

i)

If SIj immediately contains a <set property item> SPIj, then let PVi, j be the result of the

<value expression> immediately contained in SPIj.

ii)

If SIj immediately contains a <set all properties item> SAPIj, then:

1)

Let p be the number of <property key value pair> immediately contained in SAPIj.

2)

For each k-th <property key value pair> PKVPk immediately contained in SAPIj, 1 (one) ≤ k ≤ p, let PVi, j, k be the result of evaluating the <value expression>

immediately contained in PKVPk.

iii)

Otherwise, let PVi, j be undefined.

c)

For each j-th <set item> SIj, 1 (one) ≤ j ≤ m, immediately contained in SIL if SIj immediately contains a <set label item> SLIj, then let the label names LNi, j be the collection of all <label

name> s simply contained in SLIj; otherwise, let LNi, j be undefined.

« WG3:UTC-094 »

4)

If an equivalent pair PNGEi, j of property name PNi, j and graph element GEi, j appears more than once in the current working table, or if GEi, j is the result of <binding variable reference>s immediately contained in more than one <set all properties item> or one <set all properties item> and at least one <set property item> , then it is implementation-defined (IA017) which one of the following occurs:

a)

An exception condition is raised: data exception — multiple assignments to a graph element

property (22G0M).

b)

An implementation-dependent (UV009) choice of one of the equivalent pairs PNGEi, j is made and the corresponding PVi, j is used to perform the assignment to GEi, j.

5)

For each i-th record Ri, 1 (one) ≤ i ≤ n, of TABLE (using the same order as GR 3)), perform the following data-modifying operations in a new child execution context amended with Ri for each j-th

<set item> SIj, 1 (one) ≤ j ≤ m, immediately contained in SIL. If GEi, j is not the null value, then Case:

a)

If SIj immediately contains a <set property item> SPIj, then:

153

IWD 39075:202y(E)

13.3 <set statement>

i)

Let PNj be the <property name> immediately contained in SPIj.

ii)

The General Rules of Subclause 22.1, “Store assignment” , are applied with the property

PNj of GEi, j as TARGET and PVi, j as VALUE.

b)

If SIj immediately contains a <set all properties item> , then:

i)

Remove all properties of GEi, j.

ii)

Let p be the number of <property key value pair> immediately contained in SAPIj.

iii)

For each <property key value pair> PKVPk 1 (one) ≤ k ≤ p, immediately contained in SAPIj:

1)

Let PN be the <property name> immediately contained in PKVPk.

2)

The General Rules of Subclause 22.1, “Store assignment”, are applied with the

property PNj of GEi, j as TARGET and PVi, j, k as VALUE.

c)

If SIj immediately contains a <set label item>, then, for each <label name> LN in LNi, j, if LN is not contained in the label set of GEi, j, then:

i)

Add LN to the label set of GEi, j.

ii)

If GEi, j is a node and the cardinality of the label set of GEi, j is greater than the implemen-

tation-defined (IL003) node label set maximum cardinality, then an exception condition

is raised: data exception — number of node labels exceeds supported maximum (22G0P).

iii)

If GEi, j is a node and the cardinality of the node property set of GEi, j is greater than the

implementation-defined (IL004) node property set maximum cardinality, then an

exception condition is raised: data exception — number of node properties exceeds

supported maximum (22G0S).

iv)

If GEi, j is an edge and the cardinality of the label set of GEi, j is greater than the imple-

mentation-defined (IL005) edge label set maximum cardinality, then an exception

condition is raised: data exception — number of edge labels exceeds supported maximum

(22G0R).

v)

If GEi, j is an edge and the cardinality of the edge property set of GEi, j is greater than the

implementation-defined (IL006) edge property set maximum cardinality, then an

exception condition is raised: data exception — number of edge properties exceeds

supported maximum (22G0T).

d)

Let CG be the graph that contains GEi, j. If CG has a graph type GT and CG is not of graph type GT, then an exception condition is raised: graph type violation (G2000).

6)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

1)

Without Feature GA05, “Graph label set changes”, conforming GQL language shall not contain a <set

item> that is a <set label item> .

154





IWD 39075:202y(E)

13.4 <remove statement>

13.4 <remove statement>

Function

Remove graph element properties and labels.

Format

<remove statement> ::=

REMOVE <remove item list>

<remove item list> ::=

<remove item> [ { <comma> <remove item> }... ]

<remove item> ::=

<remove property item> | <remove label item>

<remove property item> ::=

<binding variable reference> <period> <property name>

<remove label item> ::=

<binding variable reference> <is or colon> <label set specification>

** Editor’s Note (number 17) **

Consider allowing a single optional <where clause>. See Language Opportunity GQL-169 .

Syntax Rules

« WG3:UTC-094 deleted an editor's note »

1)

Let RS be the <remove statement>.

2)

Let RIL be the <remove item list> immediately contained in RS.

3)

For every <remove item> RI immediately contained in RIL, the declared type of <binding variable

reference> immediately contained in RI shall be a graph element type.

« WG3:UTC-015 deleted an editor's note »

« WG3:UTC-094 »

4)

The declared type of the outgoing working table of RS is the declared type of the incoming working

table of RS.

5)

The declared type of the outgoing working record of RS is the declared type of the incoming working

record of RS.

6)

RS has no declared type.

General Rules

« WG3:UTC-062 deleted en editor's note »

1)

Let TABLE be the current working table.

2)

Let n be the number of records of TABLE and let m be the number of <remove item> s immediately contained in RIL.

155

IWD 39075:202y(E)

13.4 <remove statement>

3)

For each i-th record Ri, 1 (one) ≤ i ≤ n, of TABLE in a new child execution context amended with Ri: a)

For each j-th <remove item> RIj, 1 (one) ≤ j ≤ m, immediately contained in RIL determine the graph element GEi, j as follows.

Case:

i)

If RIj immediately contains a <remove property item> RPIj, then let GEi, j be the value of the <binding variable reference> immediately contained in RPIj.

ii)

If RIj immediately contains a <remove label item> RLIj, then let GEi, j be the value of the

<binding variable reference> immediately contained in RLIj.

b)

For each j-th <remove item> RIj, 1 (one) ≤ j ≤ m, immediately contained in RS, if RIj immediately contains a <remove label item> RLIj, then let the label names LNi, j be the collection of all <label

name> s simply contained in RLIj; otherwise, let LNi, j be undefined.

4)

For each i-th record Ri, 1 (one) ≤ i ≤ n, of TABLE (using the same order as GR 3)), perform the following data-modifying operations in a new child execution context amended with Ri for each j-th

<remove item> RIj, 1 (one) ≤ j ≤ m, immediately contained in RIL.

Case:

a)

If RIj immediately contains a <remove property item> RPIj, then let PNj be the <property

name> immediately contained in RPIj. If GEi, j is not the null value, then remove the property PNj of GEi, j.

b)

If RIj immediately contains a <remove label item> and GEi, j is not the null value, then: i)

For each <label name> LN in LNi, j, if LN is contained in the label set of GEi, j, then remove LN from the label set of GEi, j.

ii)

If GEi, j is a node and the cardinality of the label set of GEi, j is less than the implemen-

tation-defined (IL001) node label set maximum cardinality, then an exception condition

is raised: data exception — number of node labels below supported minimum (22G0N).

iii)

If GEi, j is an edge and the cardinality of the label set of GEi, j is less than the implemen-

tation-defined (IL002) edge label set maximum cardinality, then an exception condition

is raised: data exception — number of edge labels below supported minimum (22G0Q).

c)

Let CG be the graph that contains GEi, j. If CG has a graph type GT and CG is not of graph type GT, then an exception condition is raised: graph type violation (G2000).

5)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

1)

Without Feature GA05, “Graph label set changes”, conforming GQL language shall not contain a

<remove item> that is a <remove label item> .

156





IWD 39075:202y(E)

13.5 <delete statement>

13.5 <delete statement>

Function

Delete graph elements.

Format

« Correct application of WG3:W22-042 »

<delete statement> ::=

{ DETACH | NODETACH } DELETE <delete item list>

<delete item list> ::=

<delete item> [ { <comma> <delete item> }... ]

<delete item> ::=

<value expression>

** Editor’s Note (number 18) **

Consider allowing a single optional <where clause>. See Language Opportunity GQL-169 .

** Editor’s Note (number 19) **

Consider specifying different <key word> s than DETACH and NODETACH. See Language Opportunity GQL-307 .

Syntax Rules

« WG3:UTC-094 deleted an editor's note »

1)

Let DS be the <delete statement> .

2)

Let DIL be the <delete item list> immediately contained in DS.

« Editorial: Resolve GQL-305 »

3)

Let CG be the current working graph available at DS.

« WG3:UTC-094 »

4)

The declared type for every <value expression> simply contained in DIL shall be a node reference value type or an edge reference value type.

5)

If DS does not specify DETACH or NODETACH, then NODETACH is implicit.

6)

The declared type of the outgoing working table of DS is the declared type of the incoming working

table of DS.

7)

The declared type of the outgoing working record of DS is the declared type of the incoming working

record of DS.

8)

DS has no declared type.

General Rules

« WG3:UTC-062 deleted en editor's note »

157

IWD 39075:202y(E)

13.5 <delete statement>

1)

Let TABLE be the current working table.

« WG3:UTC-094 »

2)

Let NODES be an empty set. Let EDGES be an empty set.

3)

For each record R of TABLE in a new child execution context amended with R:

« WG3:UTC-094 »

a)

For each <delete item> DI immediately contained in DIL.

Case:

i)

Let the value V be the result of the <value expression> immediately contained in DI.

ii)

If V is a reference value to an edge E, then add E to EDGES.

iii)

If V is a reference value to a node N, then:

1)

Add N to NODES.

2)

If DETACH is specified, then add all edges connected to N to EDGES.

iv)

If V is not null, then an exception condition is raised: data exception — invalid value

type (22G03).

v)

Otherwise, V is the null value.

b)

For every node N in NODES, if any edge connected to N is not in EDGES, then an exception

condition is raised: dependent object error — edges still exist (G1001).

« Editorial: Resolve GQL-305 »

4)

Let CG1 be a copy of CG with all members of EDGES and all members of NODES deleted. If CG has a graph type GT and CG1 is not of graph type GT, then an exception condition is raised: graph type

violation (G2000).

« Editorial: Align with Directives Part 2 »

NOTE 126 — This document does not currently specify a situation in which the above exception would be triggered.

However, it is included as it is expected that implementation-defined extensions and/or future editions of this doc-

ument will define such situations.

5)

Delete all members of EDGES and all members of NODES from CG.

NOTE 127 — The effect of this is that all graph elements referenced by the results of evaluating the <delete statement> , for all records in the current working table, are deleted atomically. If any such graph element cannot be deleted, then

no other graph element will be deleted.

6)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

None.

158





IWD 39075:202y(E)

13.6 <call data-modifying procedure statement>

13.6 <call data-modifying procedure statement>

Function

« WG3:UTC-096R1 »

Execute a data-modifying procedure.

Format

<call data-modifying procedure statement> ::=

<call procedure statement>

Syntax Rules

1)

Let CDPS be the <call data-modifying procedure statement> , let CPS be the <call procedure statement>

immediately contained in CDPS, and let PC be the <procedure call> immediately contained in CPS.

2)

If PC is an <inline procedure call> that immediately contains the <nested procedure specification>

PROC, then PROC shall immediately contain a <data-modifying procedure specification> .

3)

If PC is a <named procedure call> that immediately contains the <procedure reference> that identifies a procedure PROC, then PROC shall have the DATA PROCEDURE indication.

General Rules

None.

Conformance Rules

None.

159





IWD 39075:202y(E)

14 Query statements

14.1 <composite query statement>

Function

Set the current working table to the result of a <composite query expression>.

Format

<composite query statement> ::=

<composite query expression>

Syntax Rules

1)

Let CQS be the <composite query statement> and let CQE be the <composite query expression>

immediately contained in CQS.

« WG3:UTC-096R1 Deleted 2 SRs »

2)

The declared type of the outgoing working record of CQS is the declared type of the incoming

working record of CQS.

3)

The declared type of the outgoing working table of CQS is the declared type of CQE.

4)

The declared type of CQS is the declared type of CQE.

General Rules

« WG3:UTC-013 P00-USA-338 »

1)

Let NEW_TABLE be the result of CQS.

2)

Set the current working table to NEW_TABLE.

3)

Set the current execution outcome to a successful outcome with NEW_TABLE as its result.

Conformance Rules

None.

160





IWD 39075:202y(E)

14.2 <composite query expression>

14.2 <composite query expression>

Function

« WG3:UTC-096R1 »

Specify binding table compositions.

Format

« WG3:UTC-096R1 »

<composite query expression> ::=

<composite query expression> <query conjunction> <composite query primary>

| <composite query primary>

<query conjunction> ::=

<set operator>

| OTHERWISE

<set operator> ::=

UNION [ <set quantifier> ]

| EXCEPT [ <set quantifier> ]

| INTERSECT [ <set quantifier> ]

« WG3:UTC-096R1 »

<composite query primary> ::=

<linear query statement>

Syntax Rules

1)

If <set operator> is specified and <set quantifier> is not specified, then DISTINCT is implicit.

2)

Let CQE be the <composite query expression>.

3)

If a <query conjunction> QC is immediately contained in CQE, then every <query conjunction> directly contained in CQE shall be QC.

4)

If CQE directly contains a <focused linear query statement>, then CQE shall not directly contain an

<ambient linear query statement>.

« WG3:UTC-096R1 »

NOTE 128 — As a consequence of this rule, focused statements and ambient statement are mutually exclusive within

a <composite query expression> , so that the following is true as well: If CQE directly contains an <ambient linear

query statement> , then CQE does not directly contain a <focused linear query statement> .

« WG3:UTC-096R1 Deleted 1 (one) SR »

« WG3:UTC-101 »

« WG3:UTC-064 »

5)

If CQE directly contains a <primitive result statement> that is FINISH, then CQE shall directly contain at most one <composite query primary>.

« WG3:UTC-096R1 »

6)

Let CQP be the <composite query primary> immediately contained in CQE.

7)

Let LQS be the <linear query statement> immediately contained in CQP.

161

IWD 39075:202y(E)

14.2 <composite query expression>

8)

The declared type of the incoming working record of LQE is the declared type of the incoming

working record of CQE.

9)

The declared type of the incoming working table of LQE is the declared type of the incoming working

table of CQE.

« WG3:UTC-096R1 »

10) The declared type of CQP is the declared type of LQS.

11) Case:

a)

If <query conjunction> is specified, then:

i)

Let ICQE be the <composite query expression> immediately contained in CQE.

ii)

The declared type of the incoming working record of ICQE is the declared type of the

incoming working record of CQE.

iii)

The declared type of the incoming working table of ICQE is the declared type of the

incoming working table of CQE.

iv)

Let FCQE be the set of the columns of the declared type of the outgoing working table

of ICQE and let FLQE be the set of the columns of the declared type of the outgoing

working table of LQE.

« WG3:UTC-086R1 »

v)

FCQE and FLQE shall be column name-equal and column-combinable.

vi)

Let COLS be the combined columns of FCQE and FLQE.

vii)

If the GQL-implementation does not support Feature GC02, “Universal comparison”,

then there shall be no column COL in COLS such that:

1)

The value type of COL is a dynamic union type DUT.

2)

There exists a pair of different component types CT1 and CT2 of DUT such that

CT1 and CT2 are not comparable.

viii)

If <set operator> is UNION DISTINCT, EXCEPT ALL, EXCEPT DISTINCT, INTERSECT

ALL, or INTERSECT DISTINCT, then each column in COLS is an operand of a grouping

operation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping

operations”, apply.

« WG3:UTC-050 »

« WG3:UTC-096R1 »

ix)

The declared type of CQE is the material binding table whose set of columns is COLS.

« WG3:UTC-096R1 »

b)

Otherwise, the declared type of CQE is the declared type of the outgoing working table of CQP.

« WG3:UTC-096R1 Deleted 2 SRs »

General Rules

« WG3:UTC-096R1 »

1)

The result of CQP is the result of LQS.

2)

Case:

162

IWD 39075:202y(E)

14.2 <composite query expression>

a)

If <query conjunction> is specified, then:

i)

Let ICQER be the binding table that is the result of ICQE.

« WG3:UTC-096R1 »

ii)

Let CQPR be the binding table that is the result of CQP.

iii)

Let FCQER be a new binding table whose columns are COLS.

iv)

If <set operator> is specified, then FCQER contains the following records:

« WG3:UTC-096R1 »

1)

Let R be a record that is a duplicate of some record in ICQER or of some record

in CQPR or both. Let m be the number of duplicates of R in ICQER and let n be the

number of duplicates of R in CQPR, where m ≥ 0 (zero) and n ≥ 0 (zero).

2)

If DISTINCT is specified or implicit, then

Case:

A)

If UNION is specified, then FCQER contains exactly one duplicate of R.

NOTE 129 — R exists as a result of GR 2)a)iv)1), guaranteeing that FCQER always con-

tains a duplicate of R.

B)

If EXCEPT is specified, then

Case:

I)

If m > 0 (zero) and n = 0 (zero), then FCQER contains exactly one

duplicate of R.

II)

Otherwise, FCQER contains no duplicate of R.

C)

If INTERSECT is specified, then

Case:

I)

If m > 0 (zero) and n > 0 (zero), then FCQER contains exactly one

duplicate of R.

II)

Otherwise, FCQER contains no duplicates of R.

3)

If ALL is specified, then

Case:

A)

If UNION is specified, then the number of duplicates of R that FCQER contains

is ( m + n).

B)

If EXCEPT is specified, then the number of duplicates of R that FCQER con-

tains is the maximum of ( m − n) and 0 (zero).

C)

If INTERSECT is specified, then the number of duplicates of R that FCQER

contains is the minimum of m and n.

v)

If OTHERWISE is specified, then

Case:

1)

If ICQER contains at least one record, then let FCQER be ICQER.

« WG3:UTC-096R1 »

163

IWD 39075:202y(E)

14.2 <composite query expression>

2)

Otherwise, let FCQER be CQPR.

« WG3:UTC-096R1 »

vi)

The result of CQE is FCQER.

« WG3:UTC-096R1 »

b)

Otherwise, the result of CQE is the result of the <linear query statement> .

Conformance Rules

« WG3:UTC-060 »

1)

Without Feature GC12, “Composite query: OTHERWISE”, conforming GQL language shall not contain

a <composite query expression> that immediately contains a <query conjunction> OTHERWISE.

2)

Without Feature GC13, “Composite query: UNION”, conforming GQL language shall not contain a

<composite query expression> that immediately contains a <query conjunction> UNION.

3)

Without Feature GC14, “Composite query: EXCEPT DISTINCT”, conforming GQL language shall not

contain a <composite query expression> that immediately contains a <query conjunction> EXCEPT.

4)

Without Feature GC15, “Composite query: EXCEPT ALL”, conforming GQL language shall not contain

a <composite query expression> that immediately contains a <query conjunction> EXCEPT ALL.

5)

Without Feature GC16, “Composite query: INTERSECT DISTINCT”, conforming GQL language shall

not contain a <composite query expression> that immediately contains a <query conjunction>

INTERSECT.

6)

Without Feature GC17, “Composite query: INTERSECT ALL”, conforming GQL language shall not

contain a <composite query expression> that immediately contains a <query conjunction> INTERSECT ALL.

« WG3:UTC-096R1 Deleted 1 (one) Subclause »

« WG3:UTC-122 »

164





IWD 39075:202y(E)

14.3 <linear query statement> and <simple query statement>

14.3 <linear query statement> and <simple query statement>

Function

Specify a linear composition of <simple query statement>s that returns a result.

Format

<linear query statement> ::=

<focused linear query statement>

| <ambient linear query statement>

<focused linear query statement> ::=

[ <focused linear query statement part> ... ]

<focused linear query and primitive result statement part>

| <focused primitive result statement>

| <focused nested query specification>

| <select statement>

<focused linear query statement part> ::=

<use graph clause> <simple linear query statement>

<focused linear query and primitive result statement part> ::=

<use graph clause> <simple linear query statement> <primitive result statement>

<focused primitive result statement> ::=

<use graph clause> <primitive result statement>

<focused nested query specification> ::=

<use graph clause> <nested query specification>

<ambient linear query statement> ::=

[ <simple linear query statement> ] <primitive result statement>

| <nested query specification>

<simple linear query statement> ::=

<simple query statement>...

« WG3:UTC-122 »

<simple query statement> ::=

<primitive query statement>

| <call query statement>

<primitive query statement> ::=

<match statement>

| <let statement>

| <for statement>

| <filter statement>

| <order by and page statement>

Syntax Rules

1)

Let LQS be the <linear query statement>.

2)

Let STMSEQ be the sequence of <simple query statement>s, the <primitive result statement>, the

<nested query specification>, and the <select statement> directly contained in LQS, let n be the number of elements of STMSEQ and let STMi, 1 (one) ≤ i ≤ n, be the i-th element of STMSEQ.

165

IWD 39075:202y(E)

14.3 <linear query statement> and <simple query statement>

3)

The declared type of the incoming working record of STM 1 is the declared type of the incoming

working record of LQS.

4)

The declared type of the incoming working table of STM 1 is the declared type of the incoming

working table of LQS.

5)

For 2 (two) ≤ i ≤ n:

a)

The declared type of the incoming working record of STMi is the declared type of the outgoing

working record of STMi-1.

b)

The declared type of the incoming working table of STMi is the declared type of the outgoing

working table of STMi-1.

6)

The declared type of LQS is the declared type of STMn.

General Rules

None.

Conformance Rules

« WG3:UTC-047 »

1)

Without Feature GE06, “Use Graph Support”, conforming GQL language shall not contain a <focused

linear query statement>.

166





IWD 39075:202y(E)

14.4 <match statement>

14.4 <match statement>

Function

Expand the current working table with matches from a graph pattern.

Format

« WG3:UTC-046 »

<match statement> ::=

<simple match statement>

| <optional match statement>

<simple match statement> ::=

MATCH <graph pattern binding table>

<optional match statement> ::=

OPTIONAL <optional operand>

<optional operand> ::=

<simple match statement>

| <left brace> <match statement block> <right brace>

| <left paren> <match statement block> <right paren>

<match statement block> ::=

<match statement>...

Syntax Rules

« WG3:UTC-087R2 Deleted 1 (one) editor's note »

1)

Let MS be the <match statement>.

« WG3:UTC-0872R2 »

2)

Let GPBT be the <graph pattern binding table> that is simply contained in MS.

3)

Let IREDT be the declared type of the incoming working record of MS and let IREDTFNS be the set

of field names of IREDT.

4)

Let GPBTRT be the record type of the declared type of GPBT.

« WG3:UTC-046 »

5)

If MS immediately contains <optional match statement>, then:

« WG3:UTC-0872R2 »

a)

Let IFNS the union of IREDTFNS and ITARTFNS.

b)

Let IBVRL be an implementation-dependent (US010) comma-separated list of all incoming

<binding variable reference> s corresponding to <binding variable> s whose names are in IFNS.

c)

A <graph pattern binding table> T supplies output bindings to a <match statement> S if at least one of the following is true:

i)

S is a <simple match statement> that immediately contains T.

ii)

S is an optional match statement whose optional operand is a <simple match statement>

that immediately contains T.

167

IWD 39075:202y(E)

14.4 <match statement>

iii)

S is an optional match statement whose <optional operand> immediately contains a

<match statement block> B and T supplies output bindings to a <match statement>

immediately contained in B.

NOTE 130 — This is a recursive definition. An <exists predicate> contained in S provides an example of a

<graph pattern binding table> that does not supply output bindings to S.

« WG3:UTC-087R2 »

d)

Let OBVRL be an implementation-dependent (US010) comma-separated list of <binding

variable reference> s corresponding to <binding variable>s whose names are column names of the declared type of any <graph pattern binding table> that supplies output bindings to MS

that are not included in IFNS.

e)

Let RETURN be defined as follows.

Case:

i)

If OBVRL is the empty list, then RETURN is:

RETURN NO BINDINGS

ii)

Otherwise, RETURN is:

RETURN OBVRL

« WG3:UTC-046 Deleted 1 (one) SR »

f)

Let OO be the <optional operand> simply contained in MS.

Case:

i)

If OO immediately contains a <simple match statement> SMS, then MS is effectively replaced by:

OPTIONAL CALL ( IBVRL) {

SMS

RETURN

}

ii)

If OO immediately contains a <match statement block> MSB, then MS is effectively replaced by:

OPTIONAL CALL ( IBVRL) {

MSB

RETURN

}

NOTE 131 — This transformation is applied recursively if MSB contains one or more nested <optional

match statement>s. IBVRL and OBVRL must be computed separately for each transformation.

« WG3:UTC-046 »

6)

If MS is a <simple match statement> , then:

« WG3:UTC-087R2 »

a)

The declared type of the outgoing working record of MS is IREDT amended with the record

type that is GPBTRT restricted to the fields identified by IREDTFNS.

« Editorial: Align with Directives Part 2 »

NOTE 132 — It is possible that the declared type of a graph pattern variable changes by changing the corres-

ponding declared type of the incoming working record or the corresponding declared type of the incoming

working table at certain sites.

168

IWD 39075:202y(E)

14.4 <match statement>

b)

The declared type of the outgoing working table of MS is the binding table type whose record

type is ITART amended with the record type that is GPBTRT without the fields identified by

IREDTFS.

« Editorial: Align with Directives Part 2 »

NOTE 133 — It is possible that the declared type of a graph pattern variable changes by changing the corres-

ponding declared type of the incoming working record or the corresponding declared type of the incoming

working table at certain sites.

General Rules

« WG3:UTC-087R2 »

1)

Let NEW_TABLE be the binding table obtained as a copy of the result of GPBT without the columns

identified by IREDTFNS.

2)

Set the current working table to NEW_TABLE.

3)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

« WG3:UTC-046 »

1)

Without Feature G121, “Grouping in OPTIONAL”, conforming GQL language shall not contain <match

statement block>.

169





IWD 39075:202y(E)

14.5 <call query statement>

14.5 <call query statement>

Function

« WG3:UTC-096R1 »

Execute a query.

Format

<call query statement> ::=

<call procedure statement>

Syntax Rules

1)

Let CQS be the <call query statement> , let CPS be the <call procedure statement> immediately contained in CQS, and let PC be the <procedure call> immediately contained in CPS.

« WG3:UTC-096R1 »

2)

If PC is an <inline procedure call> that immediately contains the <nested procedure specification>

PROC, then PROC shall immediately contain a <query specification> .

3)

If PC is a <named procedure call> that immediately contains the <procedure reference> that identifies a procedure PROC, then PROC shall have the QUERY PROCEDURE indication.

General Rules

None.

Conformance Rules

None.

170





IWD 39075:202y(E)

14.6 <filter statement>

14.6 <filter statement>

Function

Select a subset of the records of the current working table.

Format

<filter statement> ::=

FILTER { <where clause> | <search condition> }

Syntax Rules

1)

Let FS be the <filter statement> .

2)

If FS immediately contains the <search condition> SC, then it effectively is replaced by the <filter

statement>:

FILTER WHERE SC

3)

Let WC be the <where clause> that is immediately contained in FS.

4)

Let DTIWR be the declared type of the incoming working record of FS.

5)

Let DTIWT be the declared type of the incoming working table of FS.

6)

The declared type of the incoming working record of WC is DTIWR.

7)

The declared type of the incoming working table of WC is DTIWT.

8)

The declared type of the outgoing working record of FS is DTIWR.

9)

The declared type of the outgoing working table of FS is DTIWT.

« WG3:UTC-096R1 »

10) FS has no declared type.

General Rules

1)

Set the current working table to the result of WC.

« WG3:UTC-096R1 »

2)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

« WG3:UTC-060 »

1)

Without Feature GC18, “FILTER statement”, conforming GQL language shall not contain a <filter

statement>.

171





IWD 39075:202y(E)

14.7 <let statement>

14.7 <let statement>

Function

Add columns to the current working table.

Format

<let statement> ::=

LET <let variable definition list>

<let variable definition list> ::=

<let variable definition> [ { <comma> <let variable definition> }... ]

<let variable definition> ::=

<value variable definition>

| <value variable> <equals operator> <value expression>

Syntax Rules

« WG3:UTC-087R2 »

1)

Let LS be the <let statement>.

2)

Let LVDL be the <let variable definition list> immediately contained in LS.

3)

For every <let variable definition> LVD that is immediately contained in LVDL and immediately contains a <value variable>, LVD is effectively replaced by:

VALUE LVD

« WG3:UTC-087R2 deleted 3 SRs »

« WG3:UTC-087R2 »

4)

Let IREDT be the declared type of the incoming working record of LS and let IREDTFNS be the set

of field names of IREDT.

5)

Let ITART be the record type of the declared type of the incoming working table of LS and let

ITARTFNS be the set of field names of ITART.

6)

Let IFNS be the union of IREDTFNS and ITARTFNS.

7)

Let IBVRL be a comma-separated list of all <binding variable reference>s corresponding to <binding

variable> s whose names are in IFNS.

8)

Let the <binding variable definition block> BVDBLK be the space-separated list of all <let variable

definition>s immediately contained in LVDL.

9)

Let the <return item list> RIL be the comma-separated list of all <value variable> s simply contained in LVDL.

10) LS is effectively replaced by:

CALL ( IBVRL){

BVDBLK

RETURN RIL

}

172

IWD 39075:202y(E)

14.7 <let statement>

General Rules

None.

Conformance Rules

« WG3:UTC-060 »

1)

Without Feature GC19, “LET statement”, conforming GQL language shall not contain a <let statement>.

173





IWD 39075:202y(E)

14.8 <for statement>

14.8 <for statement>

Function

« WG3:UTC-088 »

Provide unnesting of a list by expanding the current working table.

Format

« WG3:UTC-088 »

<for statement> ::=

FOR <for item> [ <for ordinality or offset> ]

« WG3:UTC-088 Deleted 1 (one) production »

<for item> ::=

<for item alias> <list value expression>

<for item alias> ::=

<identifier> IN

« WG3:UTC-088 »

<for ordinality or offset> ::=

WITH { ORDINALITY | OFFSET } <identifier>

« WG3:UTC-088 Deleted 1 (one) editor's note »

Syntax Rules

« WG3:UTC-088 Deleted 1 (one) editor's note »

1)

Let FS be the <for statement> .

« WG3:UTC-088 Deleted 1 (one) SR »

« WG3:UTC-088 »

2)

Let FI be the <for item> immediately contained in FS.

3)

Let FIA be the <for item alias> immediately contained in FI.

4)

Let ANAME be the canonical name form of the <identifier> immediately contained in FIA.

5)

Let LVE be the <list value expression> immediately contained in FI.

6)

If <for ordinality or offset> is specified, then let FOO be the <for ordinality or offset>; otherwise, let FOO be the zero-length character string.

« WG3:UTC-088 Deleted 2 SRs »

« WG3:UTC-088 »

7)

The declared type of the incoming working record of LVE is the declared type of the incoming

working record of FS amended with the record type of the declared type of the incoming working

table of FS.

8)

The declared type of the incoming working table of LVE is the material unit binding table type.

9)

The declared type of the outgoing working record of FS is the declared type of the incoming working

record of FS.

174

IWD 39075:202y(E)

14.8 <for statement>

10) Let the character string PNAME and the closed record type NEW_FIELDS_RT be defined as follows.

a)

Let EFT be the field type whose name is ANAME and whose value type is the list element type

of the declared type of LVE.

b)

Case:

i)

If FOO is not the zero-length character string, then:

1)

PNAME is the canonical name form of the <identifier> immediately contained in

FOO.

2)

PNAME shall not be equal to the field name of EFT.

3)

Let the value type PVT be defined as follows.

Case:

A)

If FOO immediately contains WITH ORDINALITY, then PVT is the implemen-

tation-defined (ID057) exact numeric type with scale 0 (zero) of list element

ordinals.

B)

If FOO immediately contains WITH OFFSET, then PVT is the implementation-

defined (ID058) exact numeric type with scale 0 (zero) of list element offsets.

4)

Let PFT be the field type whose name is PNAME and whose value type is PVT.

5)

The field types of NEW_FIELDS_RT comprise EFT and PFT.

ii)

Otherwise, PNAME is the zero-length character string and the field types of

NEW_FIELDS_RT comprise EFT.

11) The declared type of the incoming working record of LVE and NEW_FIELDS_RT shall be field name-

disjoint.

12) The declared type of the outgoing working table of FS is the binding table type whose record type

is record type of the declared type of the incoming working table of FS amended with

NEW_FIELDS_RT.

13) FS has no declared type.

General Rules

1)

Let NEW_TABLE be a new binding table.

« WG3:UTC-088 Deleted 1 (one) GR »

« WG3:UTC-088 »

2)

For each record R of the current working table in a new child execution context amended with R:

a)

Let LVER be the result of LVE.

b)

Let the list value LV be determined as follows.

Case:

i)

If LVER is a list value, then LV is LVER.

ii)

If LVER is the null value, then LV is the empty list value.

iii)

Otherwise, an exception condition is raised: data exception — invalid value type (22G03).

c)

Let LVLEN be the length of LV.

175

IWD 39075:202y(E)

14.8 <for statement>

d)

For every j, 1 (one) ≤ j ≤ LVLEN:

i)

Let LRj be the record comprising a single field whose name is ANAME and whose value

is the j-th element of LV.

ii)

Case:

1)

If the <for ordinality or offset> is specified, then:

A)

If FOO immediately contains WITH ORDINALITY, then let LROj be the record

obtained by adding a field to LRj whose name is PNAME and whose value

is the exact number j.

B)

If FOO immediately contains WITH OFFSET, then let LROj be the record

obtained by adding a field to LRj whose name is PNAME and whose value

is the exact number j−1.

2)

Otherwise, let LROj be LRj.

iii)

Append LROj to the current working table.

e)

Append the Cartesian product of R and the current working table to NEW_TABLE.

3)

Set the current working table to NEW_TABLE.

« WG3:UTC-088 »

4)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

« WG3:UTC-088 »

1)

Without Feature GC03, “FOR statement”, conforming GQL-language shall not contain a <for state-

ment>.

2)

Without Feature GC04, “FOR statement: WITH ORDINALITY and WITH OFFSET”, conforming GQL-

language shall not contain a <for statement> that simply contains <for ordinality or offset>.

176





IWD 39075:202y(E)

14.9 <order by and page statement>

14.9 <order by and page statement>

Function

Specify, for the current working table, either: the ordering of the records, the number of records to be

discarded from the beginning of the table, or the maximum number of records to be retained; or any

combination of these.

Format

<order by and page statement> ::=

<order by clause> [ <offset clause> ] [ <limit clause> ]

| <offset clause> [ <limit clause> ]

| <limit clause>

** Editor’s Note (number 20) **

Additional support for PARTITION BY, WITH TIES, WITH OFFSET, and WITH ORDINALITY should be considered. See Language

Opportunity GQL-163 .

Syntax Rules

1)

Let OPS be the <order by and page statement>.

« WG3:UTC-022 Deleted 1 (one) SR »

2)

Let DTIWR be the declared type of the incoming working record of OPS.

3)

Let DTIWT be the declared type of the incoming working table of OPS.

« WG3:UTC-022 Deleted 3 SRs »

« WG3:UTC-022 »

4)

The declared type of the incoming working record of any <offset clause> or <limit clause> immediately contained in OPS is DTIWR.

5)

The declared type of the incoming working table of any <offset clause> or <limit clause> immediately contained in OPS is DTIWT.

6)

The declared type of the outgoing working record of OPS is DTIWR.

7)

The declared type of the outgoing working table of OPS is DTIWT.

8)

OPS has no declared type.

General Rules

1)

Let TABLE be the current working table.

2)

Let ORDERED be the binding table determined as follows.

Case:

« WG3:UTC-009 P00-USA-169 »

a)

If OPS immediately contains the <order by clause> OBC, then let ORDERED be the result of OBC.

177

IWD 39075:202y(E)

14.9 <order by and page statement>

b)

Otherwise, let ORDERED be TABLE.

3)

Let OFFSETED be the binding table determined as follows.

Case:

« WG3:UTC-009 P00-USA-169 »

a)

If OPS immediately contains the <offset clause> OC, then let OFFSETED be the result of OC.

b)

Otherwise, let OFFSETED be ORDERED.

4)

Let LIMITED be the binding table determined as follows.

Case:

a)

If OPS immediately contains the <limit clause> LC, then let LIMITED be the result of LC.

b)

Otherwise, let LIMITED be OFFSETED.

5)

Set the current working table to LIMITED.

6)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

« WG3:UTC-022 »

1)

Without Feature GC06, “ORDER BY and page statement: OFFSET clause”, an <order by and page

statement> in conforming GQL language shall not contain an <offset clause> .

2)

Without Feature GC07, “ORDER BY and page statement: LIMIT clause”, an <order by and page

statement> in conforming GQL language shall not contain a <limit clause>.

178





IWD 39075:202y(E)

14.10 <primitive result statement>

14.10 <primitive result statement>

Function

Define what to include in a query result.

Format

« WG3:UTC-101 »

« WG3:UTC-064 »

<primitive result statement> ::=

<return statement> [ <order by and page statement> ]

| FINISH

Syntax Rules

1)

Let PRS be the <primitive result statement> .

2)

Let DTIWR be the declared type of the incoming working record of PRS.

3)

Let DTIWT be the declared type of the incoming working table of PRS.

« WG3:UTC-009 P00-USA-169 »

4)

If the <return statement> RS is specified, then:

a)

The declared type of the incoming working record of RS is DTIWR.

b)

The declared type of the incoming working table of RS is DTIWT.

c)

Case:

i)

If the <order by and page statement> OPS is specified, then:

1)

The declared type of the incoming working record of OPS is DTIWR.

« WG3:UTC-022 Deleted 2 SRs »

« WG3:UTC-022 »

2)

Case:

A)

If OPS immediately contains an <order by clause> OBC, then:

I)

No <sort key> shall contain a <nested query specification> .

II)

Let RETURN_IDENTIFIERS be the set of all <identifier> s immediately

contained in an implicit or explicit <return item alias> contained in

RS.

III)

Let ORDER_REFS be the set of <binding variable reference>s

determined as follows:

1)

If RS does not contain a <group by clause> , a <set quantifier>

DISTINCT, or any <return item> containing an <aggregate

function>, then ORDER_REFS is the union of RETURN_IDENTI-

FIERS and the set of <identifier> s representing all column

names of DTIWT and field names of DTIWR.

179

IWD 39075:202y(E)

14.10 <primitive result statement>

2)

If RS contains a <group by clause> GBC, then ORDER_REFS is

the union of RETURN_IDENTIFIERS and the set of all <binding

variable reference> s contained in GBC.

3)

If RS does not contain a <group by clause>, but contains a <set

quantifier> DISTINCT or a <return item> containing an

<aggregate function>, then ORDER_REFS is RETURN_IDENTIFI-

ERS.

IV)

For every <sort key> SK contained in OBC: For every <binding variable

reference> contained in SK without an intervening instance of

<aggregate function> there shall be an equivalent identifier in

ORDER_REFS.

V)

If RS does not simply contain a <group by clause> or does not simply

contain a <return item> containing an <aggregate function> without

an intervening instance of <procedure body> , then no <sort key>

contained in OBC shall contain an <aggregate function> .

VI)

Let RIL be the <return item list> immediately contained in RS, let

CRIL be a copy of RIL, and let OB_COLS be the empty set.

VII)

For every <sort key> SK contained in OBC that contains an <aggregate

function>:

1)

Let AGG be the <value expression> immediately contained in

SK.

2)

Let CN be an implementation-dependent (UV014) <identifier>

that is not equivalent to any other <identifier> contained in a

<return item alias> simply contained in RIL.

3)

Append to CRIL:

, AGG AS CN

4)

SK is replaced in OBC by:

CN

5)

Let OB_COL be a new column whose name is the canonical name

form of CN and whose type is the declared type of AGG.

6)

OB_COL is added to OB_COLS.

VIII) For every <binding variable reference> REF in ORDER_REFS for which

it holds that RETURN_IDENTIFIERS contains no element that is

equivalent to REF:

1)

Append to CRIL:

, REF AS REF

2)

Let OB_COL be a new column whose name is the canonical name

form of REF and whose type is the declared type of REF.

3)

OB_COL is added to OB_COLS.

IX)

RIL is replaced by CRIL.

180

IWD 39075:202y(E)

14.10 <primitive result statement>

X)

Let BTT be the binding table type obtained as a copy of the declared

type of the outgoing working table of OPS without any columns

identified by OB_COLS.

XI)

The declared type of PRS and the declared type of the outgoing

working table of PRS is BTT.

B)

Otherwise,

I)

The declared type of the incoming working table of OPS is the

declared type of RS.

II)

The declared type of the result of PRS and the outgoing working table

of PRS is the declared type of the outgoing working table of OPS.

ii)

Otherwise, the declared type of PRS is the declared type of RS.

« WG3:UTC-064 Deleted 1 (one) SR »

« WG3:UTC-009 P00-USA-169 »

« WG3:UTC-101 »

5)

If FINISH is specified, then PRS has no declared type.

General Rules

« WG3:UTC-101 »

1)

If FINISH is specified, then the current execution outcome is set to a successful outcome with an

omitted result.

« WG3:UTC-022 »

2)

If th <return statement> RS is specified that specifies the <order by and page statement> OPS that immediately contains the <order by clause> OBC, then:

a)

Let RETURN_TABLE be the result of applying the General Rules of RS.

b)

Let ORDER_TABLE be the result of applying the General Rules of OPS.

c)

Let RESULT_TABLE be the binding table obtained as a copy of ORDER_TABLE without any

columns identified by OB_COLS.

d)

Set the current execution outcome to a successful outcome with RESULT_TABLE as its result.

Conformance Rules

« WG3:UTC-022 »

1)

Without Feature GC08, “Complex expressions in sort keys”, the <value expression> immediately

contained in a <sort key> shall be a <binding variable reference>.

2)

Without Feature GC09, “Pre-projection aliases in sort keys”, he <value expression> immediately

contained in a <sort key> shall not simply contain any <binding variable reference> that is not a

<return item alias> in the preceding <return statement>.

3)

Without Feature GC10, “Aggregate functions in sort keys”, he <value expression> immediately

contained in a <sort key> shall not simply contain an <aggregate function>.

181





IWD 39075:202y(E)

14.11 <return statement>

14.11 <return statement>

Function

« WG3:UTC-081 »

Compute the binding table result of a linear statement.

« WG3:UTC-081 Deleted 1 (one) editor's note in consequence »

Format

<return statement> ::=

RETURN <return statement body>

« WG3:UTC-046 »

<return statement body> ::=

[ <set quantifier> ] { <asterisk> | <return item list> } [ <group by clause> ]

| NO BINDINGS

<return item list> ::=

<return item> [ { <comma> <return item> }... ]

« WG3:UTC-081 »

<return item> ::=

<aggregating value expression> [ <return item alias> ]

<return item alias> ::=

AS <identifier>

** Editor’s Note (number 21) **

Consider allowing a single optional <where clause>. See Language Opportunity GQL-169 .

Syntax Rules

** Editor’s Note (number 22) **

Aggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 .

« WG3:UTC-022 »

1)

Let RS be the <return statement> .

2)

Let RSB be the <return statement body> immediately contained in RS.

« WG3:UTC-046 »

3)

Prior to the application of syntactic transformations to conforming GQL language, RSB shall not be

NO BINDINGS.

NOTE 134 — RETURN NO BINDINGS is not syntax available to the user, it is a specification device for use by a syntactic

transformation in Subclause 14.4, “<match statement>” to specify the semantics of <optional match statement> if the latter does not supply any new output bindings.

4)

If a <set quantifier> is not immediately contained in RSB, then ALL is the implicit <set quantifier>

of RSB.

182

IWD 39075:202y(E)

14.11 <return statement>

5)

If a <set quantifier> DISTINCT is specified, then each <return item> RI is an operand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping operations” ,

apply.

6)

Let SQ be the explicit or implicit <set quantifier> of RSB.

« WG3:UTC-081 Deleted 1 (one) SR »

7)

If RSB immediately contains an <asterisk>, then:

a)

RSB shall not immediately contain a <group by clause>.

« WG3:UTC-081 »

b)

Let BVSEQ be the sequence of all column names of the declared type of the incoming working

table of RS in ascending order, let NBVSEQ be the number of such binding variables, and let

BVi, 1 (one) ≤ i ≤ NBVSEQ, be the i-th such binding variable in BVSEQ.

« WG3:UTC-046 »

c)

For i, 1 (one) ≤ i ≤ NBVSEQ, let the new <return item list> NEWRIL be a comma-separated list of <return item> s:

BVi AS BVi

« WG3:UTC-046 »

d)

RS is effectively replaced by the <return statement>:

« WG3:UTC-081 »

RETURN SQ NEWRIL

« WG3:UTC-081 »

8)

Let RIL be defined as follows.

Case:

a)

If RSB is NO BINDINGS, then SQ is ALL and RIL is the empty sequence.

NOTE 135 — That is, RETURN NO BINDINGS is equivalent to RETURN ALL with an empty <return item list>

and no <group by clause>. The Format does not permit an empty <return item list>, hence the need to define these values artificially.

b)

Otherwise, RIL is the <return item list> immediately contained in RSB.

« WG3:UTC-081 Deleted 1 (one) SR »

« WG3:UTC-081 »

9)

For each <return item> RI in RIL:

Case:

a)

If the <aggregating value expression> immediately contained in RI is a <binding variable ref-

erence> RIBV and RI does not immediately contain a <return item alias>, then RI is effectively replaced by:

RIBV AS RIBV

b)

Otherwise, RI shall immediately contain a <return item alias> .

« WG3:UTC-081 Deleted 1 (one) SR »

« WG3:UTC-081 »

183

IWD 39075:202y(E)

14.11 <return statement>

10) For a given <return item> RI, let the expression of RI be the <aggregating value expression> immediately contained in RI and let the alias name of RI be the canonical name form of the <identifier>

that is immediately contained in the implicit or explicit <return item alias> of RI.

11) Case:

« WG3:UTC-081 Deleted 1 (one) SR »

a)

If RSB immediately contains a <group by clause> GBC:

i)

Let GRISET be the set of grouping <return item>s contained in RIL whose alias name

is simply contained in GBC and let NGRI be the number of such <return item>s in GRISET.

ii)

Let ARISET be the set of aggregating <return item>s contained in RIL whose alias name is not simply contained in GBC and let NARI be the number of such <return item>s in ARISET.

iii)

All <return item>s shall be contained in GRISET or ARISET.

iv)

Let INSET be the set of all <grouping element> s simply contained in GBC that are not equal to an alias name in GRISET. Let NINSET be the number of items in INSET.

v)

Let GROUP_COLS be the set of columns constructed as follows:

1)

For every GRI in GRISET:

A)

Let COL be a new column whose name is the <return item alias> of GRI and

whose type is the declared type of the <aggregating value expression>

immediately contained in GRI.

B)

COL is included in GROUP_COLS.

2)

For every IN in INSET:

A)

Let COL be a new column whose name is the <identifier> contained in IN

and whose type is the declared type of the <binding variable reference>

contained in IN.

B)

COL is included in GROUP_COLS.

3)

Let GR_TABLE_TYPE be the declared type of a binding table containing all columns

of GROUP_COLS.

4)

Let ARI_TABLE_TYPE be the declared type of the incoming working table of RS

without the fields identified by GROUP_COLS.

5)

The declared type of the incoming working table of all <return item>s in ARISET

is ARI_TABLE_TYPE.

6)

The declared type of the incoming working record of all <return item>s in ARISET

is the declared type of the incoming working record of RS amended with the

record type of GR_TABLE_TYPE.

vi)

Otherwise:

1)

The declared type of the incoming working table of every <return item> is the

declared type of the incoming working table of RS.

2)

The declared type of the incoming working record of every <return item> is the

declared type of the incoming working record of RS.

12) Let RETURN_TABLE_TYPE be the declared type of a binding table determined as follows.

184

IWD 39075:202y(E)

14.11 <return statement>

Case:

a)

If RSB immediately contains an <asterisk>, then RETURN_TABLE_TYPE is the declared type of the incoming working table of RS.

b)

Otherwise:

i)

Let RETURN_COLS be the sequence of columns constructed by, for every element RI of

RIL, creating a column whose name is the alias name of RI and whose declared type is

the declared type of the expression of RI.

ii)

RETURN_TABLE_TYPE is the declared type of a material binding table whose set of

columns is RETURN_COLS.

13) The declared type of the outgoing working table of RS is the material unit binding table type.

14) The declared type of the outgoing working record of RS is the declared type of the incoming working

record of RS.

15) The declared type of RS is RETURN_TABLE_TYPE.

« WG3:UTC-081 Implicitly moved 1 (one) SR »

« WG3:UTC-081 Deleted 1 (one) SR »

General Rules

1)

Let TABLE be the current working table, let n be the number of records of TABLE, and let Ri, 1 (one)

≤ i ≤ n, be the i-th record of TABLE in an order determined by iteration over TABLE.

2)

Let RETURN_TABLE be a new empty binding table of type RETURN_TABLE_TYPE.

« WG3:UTC-046 »

« WG3:UTC-081 Deleted 1 (one) GR »

« WG3:UTC-081 »

3)

Case:

« WG3:UTC-081 Deleted 1 (one) GR »

a)

If RS immediately contains a <group by clause> GBC:

i)

Let the grouping record GRi, 1 (one) ≤ i ≤ n, of a record Ri of TABLE be a new record constructed as follows:

1)

GRi includes fields Fk, 1 (one) ≤ k ≤ NGRI, such that the field name of Fk is the alias name of GRISETk and the field value of Fk is the result of the expression of GRISETk

in a new child execution context amended with Ri.

2)

GRi includes fields Gj, 1 (one) ≤ j ≤ NINSET, such that the field name of Gj is the

<identifier> contained in INSETj and the field value of Gj is the value in Ri of the

<binding variable reference> contained in INSET.

ii)

Let GR_TABLE be a new binding table of type GR_TABLE_TYPE of all grouping records

GRi, 1 (one) ≤ i ≤ n, of all records Ri of TABLE.

iii)

Let GROUP_BY be the result of GBC in a new child execution context with GR_TABLE as

its working table.

NOTE 136 — The result of GBC is obtained from the implicit invocation of the General Rules of

Subclause 16.17, “<group by clause>” .

185

IWD 39075:202y(E)

14.11 <return statement>

« WG3:UTC-081 Deleted 1 (one) GR »

iv)

For each record K in GROUP_BY:

1)

Let PART be a new binding table of type ARI_TABLE_TYPE comprising only the

records Rj, 1 (one) ≤ j ≤ n, from TABLE, for which the grouping record GRj for Rj

is not distinct from K, without the columns identified by GROUP_COLS.

« WG3:UTC-081 Deleted 2 GRs »

2)

Let IWR be a new record obtained as a copy of the current working record

amended with GRj .

3)

Let NR be a new record obtained as a copy of K without the fields identified by

INSET.

4)

For every <return item> ARIj in ARISET, 1 (one) ≤ j ≤ NARI, append a field to NR

whose name is the alias name of ARIj and whose value is the result of evaluating

the <aggregating value expression> of ARIj in a new child execution context with

IWR as its working record and with PART as its working table.

NOTE 137 — This is used to determine the result of <aggregate function> s.

5)

Append NR to RETURN_TABLE.

b)

Otherwise, for each record R of TABLE in a new child execution context amended with R:

i)

Let S be a record defined as follows.

Case:

1)

If RIL is an empty sequence, then S is the unit record.

2)

Otherwise, S is the record comprising a field F for every <return item> RI in RIL

such that the name of F is the alias name of RI and the value of F is the result of

the expression of RI.

3)

Add S to RETURN_TABLE.

« WG3:UTC-081 »

4)

If SQ is DISTINCT, then set the current working table to duplicate-free copy of RETURN_TABLE in

which every record is distinct from every other record of RETURN_TABLE; otherwise, set the current

working table to RETURN_TABLE.

« WG3:UTC-081 Deleted 1 (one) GR »

« WG3:UTC-086R1 »

« WG3:UTC-081 »

5)

Let FINAL_TABLE be a new binding table of type RETURN_TABLE_TYPE obtained from the current

working table by determining the preferred column name sequence to be the sequence of alias

names of all <return item> s RIi, 1 (one) ≤ i ≤ NRIL, from RIL in the order of their occurrence in RIL.

6)

Set the current working table to a new unit binding table.

7)

Set the current execution outcome to a successful outcome with FINAL_TABLE as its result.

Conformance Rules

None.

186





IWD 39075:202y(E)

14.12 <select statement>

14.12 <select statement>

Function

Provide an SQL-style query over graph data, which produces a binding table result.

Format

<select statement> ::=

SELECT [ <set quantifier> ] <select item list>

[ <select statement body>

[ <where clause> ]

[ <group by clause> ]

[ <having clause> ]

[ <order by clause> ]

[ <offset clause> ] [ <limit clause> ] ]

<select item list> ::=

<select item> [ { <comma> <select item> }... ]

« WG3:UTC-081 »

<select item> ::=

<aggregating value expression> [ <select item alias> ]

<select item alias> ::=

AS <identifier>

<having clause> ::=

HAVING <search condition>

<select statement body> ::=

FROM <select graph match list>

| <select query specification>

<select graph match list> ::=

<select graph match> [ { <comma> <select graph match> }... ]

<select graph match> ::=

<graph expression> <match statement>

<select query specification> ::=

FROM <nested query specification>

| FROM <graph expression> <nested query specification>

** Editor’s Note (number 23) **

Aggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 .

Syntax Rules

1)

Let SELSTM be the <select statement>.

2)

Let SETQ be determined as follows. If <set quantifier> is specified, then SETQ is the <set quantifier>;

otherwise, SETQ is the zero-length character string.

3)

If a <set quantifier> DISTINCT is specified, then each <select item> SI is an operand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14, “Grouping operations” ,

apply.

187

IWD 39075:202y(E)

14.12 <select statement>

4)

Let ITEMLIST be the <select item list> .

5)

Let SSB be determined as follows. If <select statement body> is specified, then SSB is the <select

statement body> ; otherwise, SSB is the zero-length character string.

6)

Let FILTERSTM be determined as follows.

Case:

a)

If a <where clause> WHERECL is specified, then FILTERSTM is:

FILTER WHERECL

b)

Otherwise,

Case:

i)

If SSB contains the <select graph match list> SGMLIST and if the last <select graph

match> in SGMLIST immediately contains a <match statement> that contains a <graph

pattern> GP that contains a <graph pattern where clause> GPWC that is not followed by a <yield clause>, then FILTERSTM is:

FILTER GPWC

and GPWC is removed from GP.

ii)

Otherwise, FILTERSTM is the zero-length character string.

7)

Let GRPCL be determined as follows. If <group by clause> is specified, then GRPCL is the <group by

clause> ; otherwise, GRPCL is the zero-length character string.

8)

Let HAVFILTERSTM and HAVITEMLIST be determined as follows.

Case:

a)

If <having clause> is specified, then:

i)

Let HAVCL be the <having clause> .

ii)

Let HAVCOND be the <search condition> immediately contained in HAVCL.

iii)

Let n be the number of <aggregate function>s directly contained in HAVCOND, let

AGG_FREE_COND 0 be HAVCOND, and for 1 (one) ≤ i ≤ n:

1)

Let AFi be the i-th <aggregate function> directly contained in HAVCOND.

2)

Let HAVITEMCOLi be an implementation-dependent (UV010) identifier that is

distinct from all identifiers contained in the request source of the currently

executing GQL-request and from all other identifiers created by this rule.

3)

Let AGG_FREE_CONDi be the result of substituting HAVITEMCOLi for AFi in

AGG_FREE_CONDi-1.

iv)

HAVFILTERSTM is:

FILTER AGG_FREE_CONDn.

v)

Case:

1)

If n > 0 (zero), then HAVITEMLIST is:

, AF 1 AS HAVITEMCOL 1, AF 2 AS HAVITEMCOL 2, ..., AFn AS HAVITEMCOLn

188

IWD 39075:202y(E)

14.12 <select statement>

2)

Otherwise, HAVITEMLIST is the zero-length character string.

b)

Otherwise, both HAVFILTERSTM and HAVITEMLIST are the zero-length character string.

9)

Let ORDCL be determined as follows. If <order by clause> is specified, then ORDCL is the <order by

clause> ; otherwise, ORDCL is the zero-length character string.

10) Let OFFCL be determined as follows. If <offset clause> is specified, then OFFCL is the <offset clause>;

otherwise, OFFCL is the zero-length character string.

11) Let LIMCL be determined as follows. If <limit clause> is specified, then LIMCL is the <limit clause>;

otherwise, LIMCL is the zero-length character string.

12) Case:

a)

If SSB immediately contains the <select graph match list> SGMLIST, then:

i)

Let n be the number of <select graph match>es immediately contained in SGMLIST and

for 1 (one) ≤ i ≤ n:

1)

Let SGMi be the i-th <select graph match> in SGMLIST.

2)

Let GREXPi be the <graph expression> immediately contained in SGMi.

3)

Let MATCHSTMi be the <match statement> immediately contained in SGMi.

ii)

Let BODY be:

USE GREXP 1 MATCHSTM 1

USE GREXP 2 MATCHSTM 2

...

USE GREXPn MATCHSTMn

« WG3:UTC-101 »

iii)

SELSTM is equivalent to:

BODY

FILTERSTM

RETURN SETQ ITEMLIST HAVITEMLIST

GRPCL

NEXT

HAVFILTERSTM

RETURN SETQ ITEMLIST

ORDCL OFFCL LIMCL

b)

If SSB immediately contains the <select query specification> SQS, then:

i)

Let NQS be the <nested query specification> immediately contained in SQS.

ii)

Let USECL be determined as follows.

Case:

1)

If SQS immediately contains a <graph expression> GREXP, then USECL is:

USE GREXP

2)

Otherwise USECL is the zero-length character string.

« WG3:UTC-101 »

iii)

SELSTM is equivalent to:

189

IWD 39075:202y(E)

14.12 <select statement>

USECL

CALL NQS

FILTERSTM

RETURN SETQ ITEMLIST HAVITEMLIST

GRPCL

NEXT

HAVFILTERSTM

RETURN SETQ ITEMLIST

ORDCL OFFCL LIMCL

c)

Otherwise, SELSTM is equivalent to:

RETURN SETQ ITEMLIST

General Rules

None.

Conformance Rules

None.

« WG3:UTC-064 Deleted 1 (one) Subclause »

190





IWD 39075:202y(E)

15 Common statements and related elements

« WG3:UTC-122 »

15.1 <call procedure statement> and <procedure call>

Function

Execute a procedure.

Format

<call procedure statement> ::=

[ OPTIONAL ] CALL <procedure call>

« WG3:UTC-086R1 »

<procedure call> ::=

<inline procedure call>

| <named procedure call>

** Editor’s Note (number 24) **

Consider allowing <where clause> . See Language Opportunity GQL-169 .

** Editor’s Note (number 25) **

Consider adding standalone calls. A standalone call is a syntax shorthand for a <call procedure statement> that implies YIELD * RETURN *

and that may only occur as valid singular (or perhaps last) top-level statement executed by a procedure.

« WG3:UTC-064 Consequence »

Standalone calls could be added by following existing syntactic precedence from Cypher or by introducing completely new

syntax. See Language Opportunity GQL-168 .

Syntax Rules

1)

Let CPS be the <call procedure statement>.

2)

Let PC be the <procedure call> immediately contained in CPS.

« WG3:UTC-086R1 »

3)

Let the record type IREDT be the declared type of the incoming working record of CPS.

4)

Let ITART be the record type of the declared type of the incoming working table of CPS.

5)

Let IREDTPC be IREDT amended by ITART.

6)

The declared type of the incoming working record of PC is IREDTPC.

7)

The declared type of the incoming working table of PC is the material unit binding table type.

8)

Let OTARTPC be defined as follows.

Case:

191

IWD 39075:202y(E)

15.1 <call procedure statement> and <procedure call>

a)

If PC is the <named procedure call> NPC and NPC has a declared type, then OTARTPC is the record type of the declared type of NPC.

b)

If PC is the <inline procedure call> IPC and IPC has a declared type, then OTARTPC is the record type of the declared type of IPC.

c)

Otherwise, OTARTPC is the material unit record type.

9)

ITART and OTARTPC shall be field name-disjoint.

10) Let OTART be ITART amended with OTARTPC.

« WG3:UTC-086R1 deleted one SR »

11) The declared type of the outgoing working record of CPS is IREDDT.

12) The declared type of the outgoing working table of CPS is the binding table type whose record type

is OTART.

13) CPS has no declared type.

General Rules

1)

Let TABLE be the current working table.

2)

Let NEW_TABLE be a new empty binding table.

3)

For each record R of TABLE in a new child execution context amended with R:

a)

The General Rules of PC are applied.

b)

Let RESULT be a new binding table determined as follows.

Case:

i)

If the current execution result is a binding table, then RESULT is the current execution

result.

ii)

Otherwise, the current execution result is omitted and RESULT is a unit binding table.

c)

If CPS immediately contains OPTIONAL, then

Case:

i)

If RESULT is an empty result table, then:

1)

Let NULLS be a new record of type RTPC such that every field value is null.

2)

Let NR be R amended with NULLS.

3)

NR is appended to NEW_TABLE.

ii)

Otherwise, the Cartesian product of R and RESULT is appended to NEW_TABLE.

4)

Set the current working table to NEW_TABLE.

5)

Set the current execution outcome to a successful outcome with an omitted result.

Conformance Rules

None.

192





IWD 39075:202y(E)

15.2 <inline procedure call>

15.2 <inline procedure call>

Function

Execute a procedure that is specified inline.

Format

<inline procedure call> ::=

[ <variable scope clause> ] <nested procedure specification>

<variable scope clause> ::=

<left paren> [ <binding variable reference list> ] <right paren>

<binding variable reference list> ::=

<binding variable reference> [ { <comma> <binding variable reference> }... ]

Syntax Rules

1)

Let IPC be the <inline procedure call>.

2)

Let PROC be the <nested procedure specification> that is immediately contained in IPC.

3)

If <variable scope clause> is not specified, then:

a)

Let FNL be a comma separated list of all the field names of the declared type of the incoming

working record of IPC.

b)

IPC is effectively replaced by:

( FNL) PROC

4)

Let VSC be the <variable scope clause> immediately contained in IPC.

5)

Let BVRLN be defined as follows:

a)

If VSC immediately contains a <binding variable reference list> BVRL, then:

i)

BVRLN is the sequence of names of the binding variables referenced by the <binding

variable reference> s immediately contained in BVRL.

« Editorial: Correct to use equal »

ii)

BVRLN shall not contain two equal names at different positions.

b)

Otherwise, BVRLN is the zero-length sequence.

6)

The declared type of the incoming working record of PROC is the declared type of the incoming

working record of IPC without the field types not identified by BVRLN.

7)

The declared type of the incoming working table of PROC is the declared type of the incoming

working table of IPC.

8)

The declared type of the outgoing working record of IPC is the declared type of the outgoing

working record of PROC.

9)

The declared type of the outgoing working table of IPC is the declared type of the outgoing working

table of PROC.

10) The declared type of IPC is the declared type of PROC.

193

IWD 39075:202y(E)

15.2 <inline procedure call>

General Rules

1)

Let R be the current working record without the fields not identified by BVRLN.

2)

Set R as the current working record.

3)

The General Rules of PROC are applied.

4)

The outcome of IPC is the outcome of PROC.

Conformance Rules

1)

Without Feature GE01, “Inline procedure”, conforming GQL language shall not contain an <inline

procedure call>.

2)

Without Feature GE02, “Inline procedure with implicit nested variable scope”, in conforming GQL

language, <inline procedure call> shall contain a <variable scope clause>.

3)

Without Feature GE03, “Inline procedure with explicit nested variable scope”, in conforming GQL

language, <inline procedure call> shall not contain a <variable scope clause> .

194





IWD 39075:202y(E)

15.3 <named procedure call>

15.3 <named procedure call>

Function

« WG3:UTC-096R1 »

Execute a named procedure.

** Editor’s Note (number 26) **

Bindings for host languages should eventually be defined. See Language Opportunity GQL-003 .

Format

<named procedure call> ::=

<procedure reference> <left paren> [ <procedure argument list> ] <right paren>

[ <yield clause> ]

<procedure argument list> ::=

<procedure argument> [ { <comma> <procedure argument> }... ]

<procedure argument> ::=

<value expression>

Syntax Rules

1)

Let NPC be the <named procedure call> and let PROC be the procedure identified by the <procedure

reference> that is immediately contained in NPC.

« WG3:UTC-077 »

2)

Let PROCDESC be the named procedure descriptor of PROC.

3)

Let PARAMS be the list of procedure parameters of PROCDESC, let PARAMSMIN be the number of

procedure parameters required by PROCDESC and let PARAMSMAX be the maximum number of

procedure parameters allowed by PROCDESC.

4)

Let ARGEXPS be the sequence of all <value expression> s that are simply contained in NPC in the order of their occurrence in NPC from left to right and let NUMARGS be the number of such elements

in ARGEXPS.

5)

NUMARGS shall be greater than or equal to PARAMSMIN.

6)

NUMARGS shall be less than or equal to PARAMSMAX.

7)

Let ARGEXPi, 1 (one) ≤ i ≤ NUMARGS, be the i-th element of ARGEXPS.

8)

The declared type of ARGEXPi, 1 (one) ≤ i ≤ NUMARGS shall be known and shall be a subtype of the

declared type of the i-th element in PARAMS.

« WG3:UTC-077 »

9)

If NPC immediately contains a <yield clause> , then the procedure result type of PROCDESC shall be a binding table type.

10) The declared type of NPC is the procedure result type of PROCDESC.

195

IWD 39075:202y(E)

15.3 <named procedure call>

General Rules

1)

Let ARGVALi, 1 (one) ≤ i ≤ PARAMSMAX, be defined as follows.

Case:

a)

If i ≤ NUMARGS, then ARGVALi is the result of ARGEXPi.

b)

Otherwise, ARGVALi is the default value of the i-th element of PARAMS.

« WG3:UTC-077 »

2)

Let R be a new record comprising fields Fi, 1 (one) ≤ i ≤ PARAMSMAX, such that the field name of Fi is the procedure parameter name of the i-th procedure parameter of PROCDESC and the field value

of Fi is ARGVALi.

3)

The following steps are performed in a new child execution context with R as its working record:

a)

Execute PROC.

b)

Let RESULT be the result returned from the successful execution of PROC.

c)

The current execution outcome is set as follows.

Case:

i)

If a <yield clause> YC is specified, then:

1)

The General Rules of YC are applied; let YIELD be the result returned from the

application of these General Rules.

2)

Set the current execution outcome to a successful outcome with YIELD as its

result.

ii)

Otherwise, set the current execution outcome to a successful outcome with RESULT

as its result.

Conformance Rules

1)

Without Feature GB30, “Named procedure calls”, Conforming GQL Language shall not contain a

<named procedure call>.

« WG3:UTC-039R1 »

2)

Without Feature GB38, “Graphs as procedure arguments”, in conforming GQL language, the declared

type of a <value expression> immediately contained in a <procedure argument> shall not be a graph reference value type.

« WG3:UTC-039R1 »

3)

Without Feature GB39, “Binding tables as procedure arguments”, in conforming GQL language, the

declared type of a <value expression> immediately contained in a <procedure argument> shall not be a binding table reference value type.

196





IWD 39075:202y(E)

16 Common elements

16.1 <use graph clause>

Function

Declare a working graph and its scope.

Format

<use graph clause> ::=

USE <graph expression>

Syntax Rules

« WG3:UTC-039R1 deleted an editor's note »

1)

Let UGC be the <use graph clause> .

« WG3:UTC-039R1 »

2)

Let GE be the <graph expression> simply contained in UGC.

3)

Let PART be the instance of the BNF non-terminal that immediately contains UGC.

4)

The scope clause of UGC is

Case:

a)

If PART is simply contained in a <focused linear query statement> FLQS, then FLQS.

b)

If PART is simply contained in a <focused linear data-modifying statement> FLDMS, then FLDMS.

5)

The scope of G comprises

Case:

a)

If PART is a <focused linear query statement part> , then the <simple linear query statement>

immediately contained in PART.

b)

If PART is a <focused linear query and primitive result statement part> , then the <simple linear

query statement> and the <primitive result statement> immediately contained in PART.

c)

If PART is a <focused primitive result statement>, then the <primitive result statement>

immediately contained in PART.

d)

If PART is a <focused nested query specification>, then the <nested query specification>

immediately contained in PART.

e)

If PART is a <focused linear data-modifying statement body>, then the <simple linear query

statement>, the <simple data-modifying statement>, the <simple linear data-accessing state-

ment>, and the <primitive result statement> immediately contained in PART.

197

IWD 39075:202y(E)

16.1 <use graph clause>

f)

If PART is a <focused nested data-modifying procedure specification>, then the <nested data-

modifying procedure specification> immediately contained in PART.

6)

UGC declares GE as a working graph.

General Rules

None.

Conformance Rules

« WG3:UTC-047 »

1)

Without Feature GE06, “Use Graph Support”, conforming GQL language shall not contain a <use

graph clause>.

198





IWD 39075:202y(E)

16.2 <at schema clause>

16.2 <at schema clause>

Function

Declare a working schema and its scope.

Format

<at schema clause> ::=

AT <schema reference>

Syntax Rules

1)

Let ASC be the <at schema clause>.

2)

Let S be the GQL-schema identified by the <schema reference> that is immediately contained in ASC.

3)

Let PB be the <procedure body> immediately containing ASC.

4)

The scope clause of ASC is PB.

5)

The scope of S comprises PB.

6)

ASC declares S as a working schema.

General Rules

None.

Conformance Rules

None.

« WG3:UTC-087R2 »

199





IWD 39075:202y(E)

16.3 <binding variable reference>

16.3 <binding variable reference>

Function

Specify binding variable references.

Format

« WG3:UTC-087R2 deleted 2 productions »

<binding variable reference> ::=

<binding variable>

Syntax Rules

« WG3:UTC-087R2 »

1)

Let BVR be the <binding variable reference> .

2)

BVR specifies a binding variable reference.

3)

Let BV be the <binding variable> immediately contained in BVR.

« Email from: Jim Melton 2022-12-08 0219 »

4)

The referenced binding variable of BVR is the variable identified by BVR.

NOTE 138 — See Subclause 21.2, “Names and variables” .

5)

Let BVN be the name of the referenced variable of BVR.

6)

Let IREDT be the declared type of the incoming working record of BVR.

7)

Let IREDT be the declared type of the incoming working record of BVR.

« Editorial: Clarified wording and added reference »

NOTE 139 — The field value type of the incoming working record corresponding to a referenced binding variable

ABV of a <binding variable reference> that is declared by a <graph pattern> AGP is defined by SR 25) of Subclause 16.7,

“<graph pattern binding table>” to be the same as the projected field type of the <binding variable reference> to ABV

in the <graph pattern yield clause> of AGP. See SR 12), for the definition of projected field type.

8)

The declared type of BVR is the value type of BVFT.

9)

The binding graph pattern of BVR is defined, if existing, as the innermost <graph pattern> GP for which it holds that:

a)

GP declares an <element variable> or a <path variable> equivalent to BV.

b)

At least one of the following holds:

i)

BVR is simply contained in the <graph pattern where clause> of GP.

ii)

BVR is contained in a <parenthesized path pattern where clause> simply contained in

GP.

10) The degree of reference of BVR is defined as follows.

Case:

a)

If the binding graph pattern GP of BVR is defined and declares an <element variable> EV

equivalent to BV, then

200

IWD 39075:202y(E)

16.3 <binding variable reference>

Case:

i)

If BVR is simply contained in the <graph pattern where clause> of GP, then the degree of reference of BVR is the degree of exposure of EV by GP.

NOTE 140 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>” and Subclause 16.10,

“<path pattern expression>” .

ii)

If BVR is contained in a <parenthesized path pattern where clause> PPPWC simply

contained in GP, then let PPPE be the <parenthesized path pattern expression> that

simply contains PPPWC.

NOTE 141 — This rule is applied after the syntactic transform that converts any <element pattern

where clause> to a <parenthesized path pattern where clause>.

Case:

1)

If EV is declared by PPPE, then the degree of reference of BVR is the degree of

exposure of EV by PPPE.

NOTE 142 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>” and

Subclause 16.10, “<path pattern expression>” .

2)

Otherwise, let PP be the innermost <graph pattern> or <parenthesized path pat-

tern expression> that contains PPPWC and that declares EV. The degree of refer-

ence of BVR is the degree of exposure of EV by PP. The degree of reference of BVR

shall be singleton.

NOTE 143 — “Degree of exposure” is defined in Subclause 16.8, “<graph pattern>” and

Subclause 16.10, “<path pattern expression>” .

b)

If the binding graph pattern GP of BVR is defined and declares a <path variable> PV equivalent to BV, then the degree of reference of BVR is unconditional singleton.

« WG3:UTC-123R2 »

c)

Otherwise, the degree of reference of BVR is defined as follows.

Case:

i)

If the declared type of BVR is a group list value type or a dynamic union type whose

component types are group list value types, then BVR has group degree of reference.

ii)

Otherwise, the declared type of BVR is not a group list value type and

Case:

1)

If the declared type of BVR is material, then the degree of reference of BVR is

unconditional singleton.

2)

Otherwise, the declared type of BVR is nullable and the degree of reference of

BVR is conditional singleton.

« WG3:UTC-123R2 Deleted 1 (one) note »

« WG3:UTC-123R2 »

11) Let DEG be the degree of reference of BVR. If DEG is not singleton, then DEG shall be effectively bounded group and the declared type of BVR shall be a group list value type.

12) If the binding graph pattern GP of BVR is defined, then the projected field type PFT of BVR is the field type whose name is BVN and whose value type is determined as follows:

Case:

a)

If GP declares an <element variable> equivalent to BVN, then

201

IWD 39075:202y(E)

16.3 <binding variable reference>

Case:

i)

If DEG is unconditional singleton, then the value type of PFT is a value type that is

determined using an implementation-defined (IW011) mechanism such that it contains

every reference value of a graph element to which BV may be bound by the evaluation

of GP.

ii)

If DEG is conditional singleton, then the value type of PFT is a value type that is

determined using an implementation-defined (IW011) mechanism such that it contains

every reference value of a graph element to which BV may be bound by the evaluation

of GP and the null value.

« WG3:UTC-123R2 »

iii)

Otherwise, DEG is group and the value type of PFT is determined using an implemen-

tation-defined (IW011) mechanism such that:

1)

The value type of PFT is either a group list value type or a dynamic union type

whose component types are group list value types.

2)

The value type of PFT contains every list of reference values to a graph element

to which BV may be bound by the evaluation of GP.

b)

Otherwise, GP declares a <path variable> equivalent to BVN and the value type of PFT is the path value type.

General Rules

« WG3:UTC-087R2 »

1)

Let F be the field of the current working record whose field name is BVN.

2)

Let FV be the field value of F.

3)

If the degree of reference of BVR is group and FV is not either a list value or the null value, then an

exception condition is raised: data exception — invalid group variable value (22G13).

4)

The result of BVR is FV.

NOTE 144 — Every <binding variable reference> is evaluated by looking it up in the current working record. The referenced variable of a <binding variable reference> declared by a <graph pattern> is bound in the Subclause 22.6,

“Applying bindings to evaluate an expression”.

Conformance Rules

« WG3:UTC-039R1 »

1)

Without Feature GB34, “Graph variables”, in conforming GQL language, the declared type of a

<binding variable reference> shall not be a graph reference value type.

« WG3:UTC-039R1 »

2)

Without Feature GB35, “Binding table variables”, in conforming GQL language, the declared type

of a <binding variable reference> shall not be a binding table reference value type.

202





IWD 39075:202y(E)

16.4 <element variable reference>

16.4 <element variable reference>

Function

Specify element variable references.

Format

« WG3:UTC-087R2 »

<element variable reference> ::=

<binding variable reference>

Syntax Rules

1)

Let EVR be the <element variable reference> .

« WG3:UTC-087R2 »

2)

Let EVRDT be the declared type of EVR.

3)

Case:

a)

If the degree of reference of EVR is singleton, then EVRDT shall be a node reference value type

or an edge reference value type.

b)

Otherwise, the degree of reference of EVR is group and EVRDT shall be a list value type whose

list element type only includes node reference values, edge reference values, or the null value.

« WG3:UTC-087R2 deleted 3 SRs »

General Rules

None.

NOTE 145 — Every <element variable reference> is evaluated in the General Rules of Subclause 16.3, “<binding variable

reference>” by looking it up in the current working record or the current working schema. However the actual element variable reference value is originally constructed and bound in the General Rules of Subclause 22.6, “Applying bindings to

evaluate an expression” .

Conformance Rules

None.

203





IWD 39075:202y(E)

16.5 <path variable reference>

16.5 <path variable reference>

Function

Specify path variable references.

Format

« WG3:UTC-087R2 »

<path variable reference> ::=

<binding variable reference>

Syntax Rules

1)

Let PVR be the <path variable reference> .

« WG3:UTC-087R2 »

2)

The degree of reference of PVR shall be unconditional singleton.

3)

The declared type of PVR shall be a path value type.

« WG3:UTC-087R2 deleted 3 SRs »

General Rules

None.

NOTE 146 — Every <path variable reference> is evaluated in the General Rules of Subclause 16.3, “<binding variable refer-

ence>” by looking it up in the current working table. However the actual path value is originally constructed and bound in the General Rules of Subclause 22.6, “Applying bindings to evaluate an expression”.

Conformance Rules

None.

204





IWD 39075:202y(E)

16.6 <parameter>

16.6 <parameter>

Function

Specify parameters.

Format

<parameter> ::=

<parameter name>

Syntax Rules

« WG3:UTC-045R1 »

1)

Let PN be the name specified by the <parameter name> immediately contained in P.

2)

Case:

a)

If there is a request parameter RP with parameter name PN in the current request context,

then P identifies RP and the declared type of P is the value type of the parameter value of RP.

b)

If there is a session parameter SP with parameter name PN in the current session context,

then P identifies SP and the declared type of P is the value type of the parameter value of SP.

c)

Otherwise, an exception condition is raised: syntax error or access rule violation — invalid

reference (42002).

3)

The result of P is the parameter value of the parameter identified by P.

NOTE 147 — The result of P is determined from the GQL-request before regular execution and is available during

the evaluation of Syntax Rules.

General Rules

None.

Conformance Rules

« WG3:UTC-039R1 »

1)

Without Feature GB36, “Graph parameters”, in conforming GQL language, the declared type of a

<parameter> shall not be a graph reference value type.

« WG3:UTC-039R1 »

2)

Without Feature GB37, “Binding table parameters”, in conforming GQL language, the declared type

of a <parameter> shall not be a binding table reference value type.

205





IWD 39075:202y(E)

16.7 <graph pattern binding table>

16.7 <graph pattern binding table>

Function

Evaluate a <graph pattern> to a binding table.

Format

<graph pattern binding table> ::=

<graph pattern> [ <graph pattern yield clause> ]

<graph pattern yield clause> ::=

YIELD <graph pattern yield item list>

<graph pattern yield item list> ::=

<graph pattern yield item> [ { <comma> <graph pattern yield item> }... ]

« WG3:UTC-087R2 »

<graph pattern yield item> ::=

<element variable reference> <path variable reference>

Syntax Rules

1)

Let GPBT be the <graph pattern binding table> and let GP be the <graph pattern> simply contained in GPBT.

2)

Every variable in the scope of GP is also in the scope of the <graph pattern yield clause> simply contained in GPBT.

« WG3:UTC-087R2 »

3)

Let EVSET be the set of names of element variable declared by GP, let PVSET be the set of names of

path variables declared by GP, and let GPVARS be a permutation of EVSET ∪ PVSET in the order of their first occurrence as an <element variable declaration> or a <path variable declaration>,

respectively, that is simply contained in GP. Let SPVSET be the set of names of subpath variables

declared by GP.

** Editor’s Note (number 27) **

Handling of subpath variables to be decided. See Language Opportunity GQL-194 .

4)

Each graph pattern variable name in GPVARS shall identify exactly one graph pattern variable in

GP at the same depth of graph pattern matching.

« WG3:UTC-087R2 »

5)

Let GLOBALS be GPVARS restricted to the names of graph pattern variables in the scope of GP.

6)

Let IREDT be the declared type of the incoming working record of GPBT.

7)

IREDT shall not contain a field whose name is in SPVSET.

8)

Let ITART be the record type of the declared type of the incoming working table of GPBT.

9)

ITART shall not contain a field whose name is in SPVSET.

10) Let RECORD_OVERLAP be GLOBALS restricted to the names of fields of IREDT, let TABLE_OVERLAP

be GLOBALS restricted to the names of fields of ITART, and let OVERLAP be the concatenation of

RECORD_OVERLAP with TABLE_OVERLAP.

206

IWD 39075:202y(E)

16.7 <graph pattern binding table>

11) The sequence of variable names XGPYCVARS is determined as follows.

Case:

« WG3:UTC-087R2 »

a)

If an explicit <graph pattern yield clause> XGPYC is specified, then XGPYCVARS is the sequence of names of variables identified by instances of <binding variable reference> s simply contained

in XGPYC.

b)

Otherwise, XGPYCVARS is the zero-length sequence.

12) Case:

« WG3:UTC-087R2 »

a)

If the length of XGPYCVARS is at least 1 (one), then:

« Editorial: Correct to use equal »

i)

XGPYCVARS shall not contain two equal names at different positions.

ii)

Every name in XGPYCVARS shall be contained in GLOBALS.

iii)

Let OGPYCVARS be OVERLAP without the names contained in XGPYCVARS.

iv)

Let GPYIL be the comma-separated list of the elements of the concatenation of

OGPYCVARS with XGPYCVARS.

« WG3:UTC-087R2 »

v)

XGPYC is equivalent to:

YIELD GPYIL

« WG3:UTC-087R2 »

b)

Otherwise, XGPYCVARS is the zero-length sequence and:

i)

Let GPYIL be the comma-separated list of the elements of GLOBALS.

ii)

The implicit <graph pattern yield clause> of GPBT is:

YIELD GPYIL

« WG3:UTC-087R2 »

13) Let GPYC be the explicit or implicit <graph pattern yield clause> after the application of SR 12).

14) Let GPYCREFS be the sequence of <binding variable reference> s simply contained in GPYC.

« Editorial: Resolve GQL-352 »

NOTE 148 — This is restricted to variable names from GLOBALS, i.e., in particular contains no names of subpath

variables declared by GP.

15) The binding graph pattern of each <binding variable reference> in GPYCREFS shall be GP.

16) For every <binding variable reference> BVR2 with name NAME in GPYCREFS for which it holds that NAME is the name of a field in IREDT or ITART:

a)

Let STM be the innermost <linear query statement> or <linear data-modifying statement>

that simply contains GPBT.

b)

Let TEMPVAR be an implementation-dependent (UV012) variable name not equal to the name

of any field of IREDT or ITART.

207

IWD 39075:202y(E)

16.7 <graph pattern binding table>

c)

Let LS be the <let statement> simply contained in a simulated transformation of the current

<GQL-program> obtained as the result of substituting STM with:

« WG3:UTC-101 »

CALL {

LET TEMPVAR = NAME

FINISH

}

STM

d)

Let BVR1 be the instance of <binding variable reference> simply contained in LS.

e)

Let DEG1 and DEG2 be the degrees of reference of BVR1 and BVR2, respectively.

f)

It shall hold that either both DEG1 and DEG2 are singleton or both DEG1 and DEG2 are group.

17) Let GPYCVARS be the sequence of the names of the variables identified by the elements of GPYCREFS

in the same order as in GPYCREFS.

18) Let GPYCFTSET be the set of the projected field types of all elements of GPYCREFS.

NOTE 149 — See Subclause 16.3, “<binding variable reference>”.

« WG3:UTC-086R1 »

19) Let GPYCRT be the closed record type whose field type set is GPYCFTSET.

20) The declared type of the incoming working record of GPBT and GPYCRT shall be field type-compar-

able.

21) The record type of the declared type of the incoming working table of GPBT and GPYCRT shall be

field type-comparable.

22) For each <element property specification> EPS simply contained in GP:

a)

Let EPP be the <element pattern predicate> that simply contains EPS.

b)

Let EPF be the <element pattern filler> that simply contains EPP.

c)

Let EVARDECL and EVAR be determined as follows.

Case:

i)

If EPF simply contains an <element variable declaration> EVARDECL, then EVAR is the

<identifier> contained in the <element variable declaration> simply contained in EPF.

ii)

Otherwise, EVAR is an implementation-dependent (UV008) <element variable> distinct from every element variable, subpath variable, and path variable contained in GP and

EVARDECL is TEMP EVAR.

NOTE 150 — In this case, EVAR specifies a temporary element variable which is never contained in

GPYC.

d)

Let EPILE be the <is label expression> simply contained in EPF.

e)

Let PECL be the <property key value pair list> simply contained in EPS.

f)

Let NOPEC be the number of <property key value pair>s simply contained in PECL.

g)

Let PEC 1, ..., PECNOPEC be the <property key value pair>s simply contained in PECL.

h)

For every i, 1 (one) ≤ i ≤ NOPEC:

i)

Let PROPi be the <property name> simply contained in PECi.

208

IWD 39075:202y(E)

16.7 <graph pattern binding table>

ii)

Let VALi be the <value expression> simply contained in PECi.

iii)

Let RPECi be a <comparison predicate> formed as:

EVAR. PROPi = VALi

i)

Let EPSC be a <boolean value expression> formed through the concatenation of <boolean

factor> s: RPEC 1 AND ... AND ... RPECNOPEC.

j)

EPF is effectively replaced by:

EVARDECL EPILE WHERE EPSC

23) Let GPT be the <graph pattern> simply contained in GPBT after the preceding transformations and let PPLT be the <path pattern list> simply contained in GPT.

24) Let PG be the current working graph available at GPBT.

NOTE 151 — If no current working graph is available at GPBT, then this rule cannot be satisfied. See Subclause 4.7.3,

“Working objects” .

« WG3:UTC-087R2 »

25) For every <value expression> or <search condition> EXP simply contained in GP, if EXP is evaluated in a new child execution context CONTEXT during the application of the Subclause 22.6, “Applying

bindings to evaluate an expression”, then:

a)

The declared type of the incoming working record of EXP is the record type whose field types

are given by the union between:

i)

IREDT without the fields identified by RECORD_OVERLAP.

ii)

ITART without the fields identified by TABLE_OVERLAP.

iii)

The projected field types of all graph pattern variable references simply contained in

EXP whose variables are declared by GP and that are exposed in EXP.

NOTE 152 — See Subclause 16.3, “<binding variable reference>” , for the definition of projected field type.

b)

The declared type of the incoming working table of EXP is the unit binding table type.

26) Let GPBTRT be the closed record type whose field types are given by the union between:

a)

IREDT without the fields identified by RECORD_OVERLAP.

« WG3:UTC-086R1 »

b)

ITART without the fields identified by TABLE_OVERLAP.

c)

GPYCFTSET.

27) The declared type of GPBT is the binding table type whose record type is GPBTRT.

General Rules

1)

The General Rules of Subclause 22.2, “Machinery for graph pattern matching” , are applied with PG

as PROPERTY GRAPH and PPLT as PATH PATTERN LIST; let MACH be the MACHINERY returned from the application of those General Rules.

2)

Let MATCH_TABLE be a new empty binding table whose columns are the columns of the declared

type of GPBT.

« WG3:UTC-087R2 »

209

IWD 39075:202y(E)

16.7 <graph pattern binding table>

3)

Case:

« WG3:UTC-086R1 »

a)

If the current working table has a preferred column name sequence PCS, then the preferred

column name sequence of MATCH_TABLE is the concatenation of the following sequence of

names in the order given.

i)

The field names of IREDT not included in XGPYCVARS, in ascending order.

ii)

PCS without the names included in XGPYCVARS.

iii)

XGPYCVARS.

b)

Otherwise:

i)

The field names of IREDT and ITART not included in XGPYCVARS, in ascending order.

ii)

XGPYCVARS.

4)

Let CWR be the current working record.

5)

For each record OUTER in the current working table:

a)

Let INNER_TABLE be a new empty binding table whose columns are the field types in

GPYCFTSET.

b)

Let COMBINED be CWR amended with OUTER.

c)

Let SANITIZED be COMBINED without the fields identified by OVERLAP.

d)

In a new child execution context whose working record is SANITIZED, the General Rules of

Subclause 16.8, “<graph pattern>” , are applied with PG as PROPERTY GRAPH, GPT as GRAPH

PATTERN, PPLT as PATH PATTERN LIST, and MACH as MACHINERY; let MATCHES be the SET

OF REDUCED MATCHES returned from the application of those General Rules.

e)

For each reduced match RM in MATCHES:

i)

The General Rules of Subclause 22.8, “Applying bindings to generate a record” , are

applied with GPT as GRAPH PATTERN, GPYC as YIELD CLAUSE, RM as MULTI-PATH

BINDING, and MACH as MACHINERY; let INNER be the RECORD returned from the application of those General Rules.

ii)

INNER is appended to INNER_TABLE.

f)

The binding table constructed as the natural join between COMBINED and INNER_TABLE is

appended to MATCH_TABLE.

6)

The result of GPBT is MATCH_TABLE.

Conformance Rules

« WG3:UTC-060 »

1)

Without Feature GC20, “Graph pattern yield”, conforming GQL language shall not contain a <graph

pattern binding table> that immediately contains a <graph pattern yield clause>.

210





IWD 39075:202y(E)

16.8 <graph pattern>

16.8 <graph pattern>

Function

Specify a pattern to be matched in a graph.

Subclause Signature

“<graph pattern> ” [General Rules] (

Parameter: “PROPERTY GRAPH”,

Parameter: “GRAPH PATTERN”,

Parameter: “PATH PATTERN LIST”,

Parameter: “MACHINERY”

) Returns: “SET OF REDUCED MATCHES”

« Editorial: Add documentation »

PROPERTY GRAPH — a property graph

GRAPH PATTERN — a <graph pattern>.

PATH PATTERN LIST — a <path pattern list>.

MACHINERY — the machinery for graph pattern matching.

SET OF REDUCED MATCHES — the resulting set of reduced matches.

— This signature is invoked from Subclause 16.7, “<graph pattern binding table>”, GR 5)d)

Format

<graph pattern> ::=

[ <match mode> ] <path pattern list>

[ <keep clause> ]

[ <graph pattern where clause> ]

<match mode> ::=

<repeatable elements match mode>

| <different edges match mode>

<repeatable elements match mode> ::=

REPEATABLE <element bindings or elements>

<different edges match mode> ::=

DIFFERENT <edge bindings or edges>

<element bindings or elements> ::=

ELEMENT [ BINDINGS ]

| ELEMENTS

<edge bindings or edges> ::=

<edge synonym> [ BINDINGS ]

| <edges synonym>

<path pattern list> ::=

<path pattern> [ { <comma> <path pattern> }... ]

<path pattern> ::=

[ <path variable declaration> ] [ <path pattern prefix> ] <path pattern expression>

211

IWD 39075:202y(E)

16.8 <graph pattern>

<path variable declaration> ::=

<path variable> <equals operator>

<keep clause> ::=

KEEP <path pattern prefix>

<graph pattern where clause> ::=

WHERE <search condition>

Syntax Rules

1)

Let GP be the <graph pattern>.

2)

If BNF1 and BNF2 are instances of two BNF non-terminals, both contained in GP without an inter-

vening <graph pattern>, then BNF1 and BNF2 are said to be at the same depth of graph pattern matching.

« Editorial: Align with Directives Part 2 »

NOTE 153 — BNF1 can contain BNF2 while being at the same depth of graph pattern matching.

3)

In a <path pattern list> , if two <path pattern>s expose an element variable EV, then both shall expose EV as an unconditional singleton variable.

NOTE 154 — This case expresses an implicit join on EV. Implicit joins between conditional singleton variables or

group variables are forbidden.

4)

Two <path pattern> s shall not expose the same subpath variable.

NOTE 155 — Implicit equijoins on subpath variables are not supported.

5)

The name of a node variable shall not be equivalent to the name of an edge variable declared at the

same depth of graph pattern matching.

6)

If <keep clause> KP is specified, then:

a)

Let PSP be the <path pattern prefix> simply contained in KP.

b)

For each <path pattern> PP simply contained in GP:

i)

PP shall not contain a <path search prefix>.

ii)

Case:

1)

If PP specifies a <path variable declaration>, then let PVDECL be that <path variable

declaration>.

2)

Otherwise, let PVDECL be the zero-length character string.

iii)

Case:

« WG3:UTC-009 P00-USA-169 »

1)

If PP specifies a <path mode prefix> , then let PMP be that <path mode prefix>.

2)

Otherwise, let PMP be the zero-length character string.

iv)

Let PPE be the <path pattern expression> simply contained in PP.

v)

PP is replaced by

PVDECL PSP ( PMP PPE )

c)

The <keep clause> is removed from the <graph pattern>.

212

IWD 39075:202y(E)

16.8 <graph pattern>

** Editor’s Note (number 28) **

It has been suggested that it might be possible to treat the <path pattern prefix> specified in <keep clause> as merely providing a default <path pattern prefix> rather than a mandatory one for each <path pattern>. Whereas nested <path pattern prefix> is prohibited, this may be a feasible avenue of growth. On the other hand, perhaps a less definitive verb than KEEP may be appropriate when specifying a default <path pattern prefix>. See Language

Opportunity GQL-057 .

7)

After the preceding transformations, for every <path pattern> PP, if PP contains a <path pattern

prefix> PPP that specifies a <path mode> PM, then:

a)

Case:

i)

If PP specifies a <path variable declaration> , then let PVDECL be that <path variable

declaration>.

ii)

Otherwise, let PVDECL be the zero-length character string.

b)

Let PPE be the <path pattern expression> simply contained in PP.

c)

PP is replaced by

PVDECL PPP ( PM PPE )

NOTE 156 — One effect of the preceding transforms is that every <path mode> expressed outside a <paren-

thesized path pattern expression> is also expressed within a <parenthesized path pattern expression>. For example,

ALL SHORTEST TRAIL GROUP <path pattern expression>

is rewritten as

ALL SHORTEST TRAIL GROUP ( TRAIL <path pattern expression> )

The TRAIL specified outside the parentheses is now redundant. The benefit is that the definition of a consistent

path binding in Subclause 22.2, “Machinery for graph pattern matching”, only has to consider <path mode>s

declared in <parenthesized path pattern expression>s.

8)

Let GPT be the <graph pattern> after the preceding syntactic transformations.

9)

Let PPL be the <path pattern list> simply contained in GPT.

10) If GPT does not specify a <match mode> , then an implementation-defined (ID086) <match mode>

is implicit.

11) Let MM be the <match mode> implicitly or explicitly specified by GPT.

« WG3:UTC-024 »

12) If MM is <different edges match mode> and PPL simply contains a <path pattern> that is selective, then PPL shall not simply contain any other <path pattern>.

NOTE 157 — If MM is <different edges match mode> and there is a selective <path pattern> SPP, then PPL must only contain SPP. If there is no selective <path pattern> in GPT, then there are no restrictions on how many non-selective

<path pattern>s are contained in PPL. If MM is <repeatable elements match mode> , then there is no restriction on how many (selective and non-selective) <path pattern> s are contained in PPL.

13) Let E be an element variable declared by GPT.

Case:

a)

If E is exposed by GPT as an unconditional singleton, then E is a global unconditional singleton of GPT.

b)

Otherwise, let PPPE be the outermost <parenthesized path pattern expression> that exposes

E as an unconditional singleton; the unconditional singleton scope index of E in GPT is the bracket index of PPPE.

213

IWD 39075:202y(E)

16.8 <graph pattern>

NOTE 158 — Bracket index is defined in Subclause 22.2, “Machinery for graph pattern matching” . The

unconditional singleton scope index is well-defined because implicit equijoins between conditional singleton

variables or group variables are forbidden. Hence there cannot be two <parenthesized path pattern expres-

sion>s that expose E as a conditional singleton or group variable unless one is contained in the other. For example,

( ( ( -[E]-> ) -[E]-> )* -[F]-> )*

The unconditional singleton scope of E is the middle <parenthesized path pattern expression> in the nest of three.

14) After the preceding transformations, for every <quantified path primary> QPP contained in GPT, at least one of the following shall be true:

a)

The <graph pattern quantifier> of QPP is bounded.

b)

QPP is contained in a restrictive <parenthesized path pattern expression> .

c)

QPP is contained in a selective <path pattern> .

d)

MM is <different edges match mode>.

NOTE 159 — Unless an explicit <path mode> other than WALK is specified, an implicit or explicit specification of a <different edges match mode> effectively imparts the <path mode> TRAIL without the presence of the

<key word> TRAIL.

« WG3:UTC-075 »

15) Each <path variable> PV contained in GPT is the name of a path variable. The degree of exposure of the path variable that PV identifies is unconditional singleton.

« WG3:UTC-075 deleted an editor's note »

General Rules

1)

Let PG be the PROPERTY GRAPH, let GPT be the GRAPH PATTERN, let PPL be the PATH PATTERN

LIST, and let MACH be the MACHINERY in an application of the General Rules of this Subclause. The

result of the application of this Subclause is returned as SET OF REDUCED MATCHES.

NOTE 160 — In this document, PG is always the current working graph.

2)

The following components of MACH are identified:

a)

ABC, the alphabet, formed as the disjoint union of the following:

i)

SVV, the set of names of node variables.

ii)

SEV, the set of names of edge variables.

iii)

SPS, the set of subpath symbols.

iv)

SAS, the set of anonymous symbols.

v)

SBS, the set of bracket symbols.

b)

REDUCE, the function mapping path bindings to path bindings, and multi-path bindings to

multi-path bindings.

3)

Let NP be the number of <path pattern>s simply contained in PPL. Let PP 1, ..., PPNP be the <path

pattern> s simply contained in PPL after the transformations in the Syntax Rules.

« WG3:UTC-024 »

4)

A multi-path binding MPBINDING is different-edges-matched if, for every edge binding EB1 = ( EV1, E) contained in MPBINDING, there is no edge binding EB2 = ( EV2, E) contained in MPBINDING at a different position than EB1 that binds the edge E.

214

IWD 39075:202y(E)

16.8 <graph pattern>

5)

For every i, 1 (one) ≤ i ≤ NP:

a)

Let PPE be the <parenthesized path pattern expression> simply contained in PPi.

b)

The General Rules of Subclause 22.3, “Evaluation of a <path pattern expression>” , are applied

with PG as PROPERTY GRAPH, PPL as PATH PATTERN LIST, MACH as MACHINERY, and PPE as

SPECIFIC BNF INSTANCE; let SMPPEi be the SET OF MATCHES returned from the application of those General Rules.

NOTE 161 — If an elementary variable has been multiply declared within a restrictive <parenthesized path

pattern expression> PP, then no matches are returned for PP. For example:

MATCH ACYCLIC (X) -> (X)

does not find any results, even if there are nodes with self-edges.

c)

Case:

i)

If PPi is a selective <path pattern> , then:

1)

Case:

« WG3:UTC-024 »

A)

If MM is <different edges match mode> , then let SMUPi be the set of different-

edges-matched multi-path bindings in SMPPEi.

NOTE 162 — If an edge variable has been multiply declared within a <path pattern>

PP, then no matches are returned for PP. For example, the following produces no results:

MATCH DIFFERENT EDGES

ANY SHORTEST () -[E]-> () -[E]-> ()

B)

Otherwise, let SMUPi be SMPPEi.

2)

The General Rules of Subclause 22.4, “Evaluation of a selective <path pattern>” ,

are applied with PG as PROPERTY GRAPH, PPL as PATH PATTERN LIST, MACH as

MACHINERY, PPi as SELECTIVE PATH PATTERN, and SMUPi as INPUT SET OF

LOCAL MATCHES; let SMi be the OUTPUT SET OF LOCAL MATCHES returned from the application of those General Rules.

ii)

Otherwise, let SMi be SMPPEi.

6)

Let CROSS be the cross product SM 1 ⨯ ... ⨯ SMNP.

7)

Let INNER be the set of multi-path bindings MPB in CROSS such that, for every unconditional singleton

<element variable> USV exposed by PPL, USV is bound to a unique graph element by the elementary bindings of USV contained in MPB.

NOTE 163 — Anonymous symbols are not <element variable> s; there is no requirement that two anonymous symbols bind to the same graph element.

8)

Case:

« WG3:UTC-024 »

a)

If MM is <different edges match mode> , then let BINDINGS be the set of different-edges-matched multi-path bindings in INNER.

NOTE 164 — If an edge variable has been multiply declared within a <graph pattern> GP, then no matches are returned for GP. For example, the following produces no results:

MATCH DIFFERENT EDGES () -[E]-> (), () -[E]-> ()

and neither does the following:

215

IWD 39075:202y(E)

16.8 <graph pattern>

MATCH DIFFERENT EDGES () -[E]-> () -[E]-> ()

b)

Otherwise, let BINDINGS be INNER.

« Email from: Jim Melton 2022-12-08 0219 »

9)

A match of GPT is a multi-path binding M = ( PB 1, ..., PBNP ) of NP path bindings in BINDINGS, such that all of the following are true:

a)

For every j, 1 (one) ≤ j ≤ NP, and for or every <parenthesized path pattern expression> PPPE

contained in PPj, let i be the bracket index of PPPE, and let `[ì and `]ì be the bracket symbols associated with PPPE. A binding of PPPE is a substring of PBj that begins with the bracket

binding (`[ i`, `[ i`) and ends with the next bracket binding (`] i`, `] i`).

NOTE 165 — “Bracket index” is defined in Subclause 22.2, “Machinery for graph pattern matching”.

« Email from: Jim Melton 2022-12-08 0219 »

For every binding BPPPE of PPPE contained in PBj all of the following are true:

i)

For every <element variable> EV that is exposed as an unconditional singleton by PPPE, EV is bound to a unique graph element by the element variable bindings contained in

BPPPE.

NOTE 166 — Anonymous symbols are not <element variable>s; there is no requirement that two

anonymous symbols bind to the same graph element.

ii)

If PPPE contains a <parenthesized path pattern where clause> PPPWC, then the value

of V1 is True when the General Rules of Subclause 22.6, “Applying bindings to evaluate

an expression”, are applied with GPT as GRAPH PATTERN, the <search condition> simply contained in PPPWC as EXPRESSION, MACH as MACHINERY, M as MULTI-PATH BINDING,

and a reference to BPPPE as REFERENCE TO LOCAL CONTEXT; let V1 be the VALUE

returned from the application of those General Rules.

b)

If GPT contains a <graph pattern where clause> GPWC, then the value of V2 is True when the General Rules of Subclause 22.6, “Applying bindings to evaluate an expression” , are applied

with GPT as GRAPH PATTERN, GPWC as EXPRESSION, MACH as MACHINERY, M as MULTI-PATH

BINDING, and a reference to M as REFERENCE TO LOCAL CONTEXT; let V2 be the VALUE

returned from the application of those General Rules.

10) A reduced match RM = ( RPB 1, ..., RPBNP ) is obtained from a match M = ( PB 1, ..., PBNP ) as RM =

REDUCE( M).

« Editorial: Align with Directives Part 2 »

NOTE 167 — Set-theoretic deduplication will occur here. That is, two or more matches can reduce to the same

reduced match; this scenario is regarded as contributing only a single reduced match to the result set.

11) Let SRM be the set of reduced matches.

12) Evaluation of the General Rules is terminated and control is returned to the invoking Subclause,

which receives SRM as SET OF REDUCED MATCHES.

Conformance Rules

1)

Without Feature G002, “Different-edges match mode”, conforming GQL language shall not contain

a <different edges match mode> .

2)

Without Feature G003, “Explicit REPEATABLE ELEMENTS keyword”, conforming GQL language

shall not contain a <match mode> that specifies REPEATABLE ELEMENTS or REPEATABLE ELEMENT

BINDINGS.

216

IWD 39075:202y(E)

16.8 <graph pattern>

3)

Without Feature G004, “Path variables”, conforming GQL language shall not contain a <path pattern>

that simply contains a <path variable declaration>.

4)

Without Feature G005, “Path search prefix in a path pattern”, conforming GQL language shall not

contain a <path pattern> that simply contains a <path pattern prefix> that is a <path search prefix>.

5)

Without Feature G006, “Graph pattern KEEP clause: path mode prefix”, conforming GQL language

shall not contain a <keep clause> that simply contains a <path mode prefix>.

6)

Without Feature G007, “Graph pattern KEEP clause: path search prefix”, conforming GQL language

shall not contain a <keep clause> that simply contains a <path search prefix> .

217





IWD 39075:202y(E)

16.9 <path pattern prefix>

16.9 <path pattern prefix>

Function

Specify a path-finding operation and a path mode.

Format

<path pattern prefix> ::=

<path mode prefix>

| <path search prefix>

<path mode prefix> ::=

<path mode> [ <path or paths> ]

<path mode> ::=

WALK

| TRAIL

| SIMPLE

| ACYCLIC

<path search prefix> ::=

<all path search>

| <any path search>

| <shortest path search>

** Editor’s Note (number 29) **

The ability to specify “cheapest” queries (analogous to SHORTEST, but minimizing the sum of costs along a path) is desirable.

See Language Opportunity GQL-052 .

<all path search> ::=

ALL [ <path mode> ] [ <path or paths> ]

<path or paths> ::=

PATH | PATHS

<any path search> ::=

ANY [ <number of paths> ] [ <path mode> ] [ <path or paths> ]

<number of paths> ::=

<unsigned integer specification>

** Editor’s Note (number 30) **

This differs from the SQL/PGQ definition of <number of paths> .

<shortest path search> ::=

<all shortest path search>

| <any shortest path search>

| <counted shortest path search>

| <counted shortest group search>

<all shortest path search> ::=

ALL SHORTEST [ <path mode> ] [ <path or paths> ]

<any shortest path search> ::=

ANY SHORTEST [ <path mode> ] [ <path or paths> ]

<counted shortest path search> ::=

218

IWD 39075:202y(E)

16.9 <path pattern prefix>

SHORTEST <number of paths> [ <path mode> ] [ <path or paths> ]

<counted shortest group search> ::=

SHORTEST <number of groups> [ <path mode> ] [ <path or paths> ] { GROUP | GROUPS }

<number of groups> ::=

<unsigned integer specification>

** Editor’s Note (number 31) **

This differs from the SQL/PGQ definition of <number of groups> .

** Editor’s Note (number 32) **

In addition to SHORTEST GROUP, it has been proposed to support SHORTEST [ k ] WITH TIES, with the semantics to return

the first k matches (where k defaults to 1) when sorting matches in ascending order on number of edges, and also return every match that has the same number of edges as the last of the k matches. This is the semantics of WITH TIES in Subclause 7.17,

“<query expression>” in SQL/Foundation. See Language Opportunity GQL-053 .

Syntax Rules

1)

If a <parenthesized path pattern expression> does not specify a <path mode prefix>, then WALK

PATHS is implicit.

2)

If a <path pattern prefix> PPP does not specify <all path search>, then: a)

Case:

i)

If PPP does not simply contain a <path mode>, then let PM be WALK.

ii)

Otherwise, let PM be the <path mode> simply contained in PPP.

b)

Case:

i)

If PPP does not simply contain a <number of paths> or <number of groups> , then let N be an <unsigned integer> whose value is 1 (one).

ii)

Otherwise, let N be the <number of paths> or <number of groups> simply contained in PPP. The declared type of N shall be exact numeric with scale 0 (zero). If N is a <lit-

eral> , then the value of N shall be positive.

c)

Case:

i)

If PPP is an <any path search> , then PPP is equivalent to:

ANY N PM PATHS

ii)

If PPP is a <shortest path search> , then

Case:

1)

If PPP is <all shortest path search> , then PPP is equivalent to:

SHORTEST 1 PM GROUP

2)

If PPP is <any shortest path search>, then PPP is equivalent to:

SHORTEST 1 PM PATH

3)

If PPP is <counted shortest path search> , then PPP is equivalent to:

219

IWD 39075:202y(E)

16.9 <path pattern prefix>

SHORTEST N PM PATHS

4)

If PPP is <counted shortest group search> , then PPP is equivalent to:

SHORTEST N PM GROUPS

3)

A <path pattern prefix> that specifies a <path mode> other than WALK is restrictive. A <parenthesized

path pattern expression> that immediately contains a restrictive <path mode prefix> is restrictive.

4)

A <path search prefix> other than <all path search> is selective. A <path pattern> that simply contains a selective <path search prefix> is selective.

5)

Let PPPE be a selective <path pattern> .

a)

An element variable exposed by PPPE is an interior variable of PPPE.

« Email from: Jim Melton 2022-12-08 0219 »

b)

A node variable LVV is the left boundary variable of PPPE if all of the following conditions are

true:

i)

PPPE exposes LVV as an unconditional singleton variable.

ii)

LVV is declared in the first implicit or explicit <node pattern> LVP contained in PPPE.

iii)

LVP is not contained in a <path pattern union> or <path multiset alternation> that is contained in PPPE.

« Email from: Jim Melton 2022-12-08 0219 »

c)

A node variable RVV is the right boundary variable of PPPE if all of the following conditions

are true:

i)

PPPE exposes RVV as an unconditional singleton variable.

ii)

RVV is declared in the last implicit or explicit <node pattern> RVP contained in PPPE.

iii)

RVP is not contained in a <path pattern union> or <path multiset alternation> that is contained in PPPE.

** Editor’s Note (number 33) **

With more work, it is possible to recognize when a node variable is declared uniformly in the first or

the last position in every operand of a <path pattern union> . However, WG3:W04-009R1 declined to

make the effort because it is easy for the user to factor out such a node pattern. For example, instead of

(X) -> (Y) | (X) -> (Z)

the user can write

(X) ( -> (Y) | -> (Z))

Thus a more general definition of right or left boundary variable is possible. See Language Opportunity

GQL-056 .

d)

An element variable that is exposed by PPPE that is neither a left boundary variable of PPPE

nor a right boundary variable of PPPE is a strict interior variable of PPPE.

6)

An element variable that is not declared in a selective <path pattern> is an exterior variable.

7)

A strict interior variable of one selective <path pattern> shall not be equivalent to an exterior

variable, nor to an interior variable of another selective <path pattern> .

NOTE 168 — Implicit joins of boundary variables of selective <path pattern> s with exterior variables or boundary variables of other selective <path pattern> s are permitted.

220

IWD 39075:202y(E)

16.9 <path pattern prefix>

8)

A selective <path pattern> SPP shall not contain a reference to a graph pattern variable that is not declared by SPP.

« Editorial: Align with Directives Part 2 »

NOTE 169 — This rule, and the prohibition of implicit joins to exterior variables and interior variables of other

selective <path pattern> s, insure that each selective <path pattern> can be evaluated in isolation from any other

<path pattern>.

General Rules

None.

NOTE 170 — Restrictive <path mode> s are enforced as part of the check for consistent path bindings in the generation of the set of local matches in Subclause 16.10, “<path pattern expression>” . Selective <path pattern> s are evaluated by

Subclause 22.4, “Evaluation of a selective <path pattern>” .

Conformance Rules

1)

Without Feature G010, “Explicit WALK keyword”, conforming GQL language shall not contain a

<path mode> that specifies WALK.

2)

Without Feature G011, “Advanced path modes: TRAIL”, conforming GQL language shall not contain

a <path mode> that specifies TRAIL.

3)

Without Feature G012, “Advanced path modes: SIMPLE”, conforming GQL language shall not contain

a <path mode> that specifies SIMPLE.

4)

Without Feature G013, “Advanced path modes: ACYCLIC”, conforming GQL language shall not contain

a <path mode> that specifies ACYCLIC.

5)

Without Feature G014, “Explicit PATH/PATHS keywords”, conforming GQL language shall not

contain a <path or paths>.

6)

Without Feature G015, “All path search: explicit ALL keyword”, conforming GQL language shall not

contain an <all path search>.

7)

Without Feature G016, “Any path search”, conforming GQL language shall not contain an <any path

search> .

8)

Without Feature G017, “All shortest path search”, conforming GQL language shall not contain <all

shortest path search> .

9)

Without Feature G018, “Any shortest path search”, conforming GQL language shall not contain an

<any shortest path search> .

10) Without Feature G019, “Counted shortest path search”, conforming GQL language shall not contain

a <counted shortest path search>.

11) Without Feature G020, “Counted shortest group search”, conforming GQL language shall not contain

a <counted shortest group search> .

221





IWD 39075:202y(E)

16.10 <path pattern expression>

16.10 <path pattern expression>

Function

Specify a pattern to match a single path in a property graph.

Format

<path pattern expression> ::=

<path term>

| <path multiset alternation>

| <path pattern union>

<path multiset alternation> ::=

<path term> <multiset alternation operator> <path term>

[ { <multiset alternation operator> <path term> }... ]

<path pattern union> ::=

<path term> <vertical bar> <path term> [ { <vertical bar> <path term> }... ]

<path term> ::=

<path factor>

| <path concatenation>

<path concatenation> ::=

<path term> <path factor>

<path factor> ::=

<path primary>

| <quantified path primary>

| <questioned path primary>

<quantified path primary> ::=

<path primary> <graph pattern quantifier>

<questioned path primary> ::=

<path primary> <question mark>

NOTE 171 — Unlike most regular expression languages, <question mark> is not equivalent to the quantifier {0,1}: the quantifier {0,1} exposes variables as group, whereas <question mark> does not change the singleton variables that it exposes to group. However, <question mark> does expose any singleton variables as conditional singletons.

<path primary> ::=

<element pattern>

| <parenthesized path pattern expression>

| <simplified path pattern expression>

<element pattern> ::=

<node pattern>

| <edge pattern>

<node pattern> ::=

<left paren> <element pattern filler> <right paren>

<element pattern filler> ::=

[ <element variable declaration> ]

[ <is label expression> ]

[ <element pattern predicate> ]

<element variable declaration> ::=

[ TEMP ] <element variable>

222

IWD 39075:202y(E)

16.10 <path pattern expression>

<is label expression> ::=

<is or colon> <label expression>

<is or colon> ::=

IS

| <colon>

<element pattern predicate> ::=

<element pattern where clause>

| <element property specification>

<element pattern where clause> ::=

WHERE <search condition>

<element property specification> ::=

<left brace> <property key value pair list> <right brace>

<property key value pair list> ::=

<property key value pair> [ { <comma> <property key value pair> }... ]

<property key value pair> ::=

<property name> <colon> <value expression>

<edge pattern> ::=

<full edge pattern>

| <abbreviated edge pattern>

<full edge pattern> ::=

<full edge pointing left>

| <full edge undirected>

| <full edge pointing right>

| <full edge left or undirected>

| <full edge undirected or right>

| <full edge left or right>

| <full edge any direction>

<full edge pointing left> ::=

<left arrow bracket> <element pattern filler> <right bracket minus>

<full edge undirected> ::=

<tilde left bracket> <element pattern filler> <right bracket tilde>

<full edge pointing right> ::=

<minus left bracket> <element pattern filler> <bracket right arrow>

<full edge left or undirected> ::=

<left arrow tilde bracket> <element pattern filler> <right bracket tilde>

<full edge undirected or right> ::=

<tilde left bracket> <element pattern filler> <bracket tilde right arrow>

<full edge left or right> ::=

<left arrow bracket> <element pattern filler> <bracket right arrow>

<full edge any direction> ::=

<minus left bracket> <element pattern filler> <right bracket minus>

** Editor’s Note (number 34) **

In the BNF for <full edge any direction>, the delimiter tokens <~[ ]~> have been suggested as a synonym for -[ ]- as part of Feature GA07, “Undirected edge patterns”. The synonym for the <abbreviated edge pattern> - (<minus sign> ) would then be

<~>, the synonym for <simplified defaulting any direction> would use the delimiter tokens <~/ /~> and the synonym for

<simplified override any direction> would use the tokens <~ and > surrounding a label as originally proposed in WG3:MMX-223

IWD 39075:202y(E)

16.10 <path pattern expression>

060. These synonyms might be considered to make the table of edge patterns more harmonious and internally consistent. See

Language Opportunity GQL-212 .

<abbreviated edge pattern> ::=

<left arrow>

| <tilde>

| <right arrow>

| <left arrow tilde>

| <tilde right arrow>

| <left minus right>

| <minus sign>

<parenthesized path pattern expression> ::=

<left paren>

[ <subpath variable declaration> ]

[ <path mode prefix> ]

<path pattern expression>

[ <parenthesized path pattern where clause> ]

<right paren>

<subpath variable declaration> ::=

<subpath variable> <equals operator>

<parenthesized path pattern where clause> ::=

WHERE <search condition>

Syntax Rules

1)

Let RIGHTMINUS be the following collection of <token>s: <right bracket minus>, <left arrow>, <slash

minus>, and <minus sign> .

NOTE 172 — These are the tokens ]-, <-, /-, and -, which expose a minus sign on the right.

2)

Let LEFTMINUS be the following collection of <token> s: <minus left bracket>, <right arrow>, <minus

slash>, and <minus sign>.

NOTE 173 — These are the tokens -[, ->, -/, and -, which expose a minus sign on the left. <minus sign> itself is in both RIGHTMINUS and LEFTMINUS.

3)

A <path pattern expression> shall not juxtapose a <token> from RIGHTMINUS followed by a <token>

from LEFTMINUS without a <separator> between them.

NOTE 174 — Otherwise, the concatenation of the two tokens would include the sequence of two <minus sign>s,

which is a <simple comment introducer>.

4)

A <path pattern expression> that contains at the same depth of graph pattern matching a variable

quantifier, a <questioned path primary> , a <path multiset alternation>, or a <path pattern union>

is a possibly variable length path pattern.

5)

A <path pattern expression> that is not a possibly variable length path pattern is a fixed length path pattern.

6)

The minimum path length of certain BNF non-terminals defined in this Subclause is defined

recursively as follows:

a)

The minimum path length of a <node pattern> is 0 (zero).

b)

The minimum path length of an <edge pattern> is 1 (one).

c)

The minimum path length of a <path concatenation> is the sum of the minimum path lengths

of its operands.

224

IWD 39075:202y(E)

16.10 <path pattern expression>

d)

The minimum path length of a <path pattern union> or <path multiset alternation> is the minimum of the minimum path length of its operands.

e)

The minimum path length of a <quantified path primary> is the product of the minimum path

length of the simply contained <path primary> and the value of the <lower bound>.

f)

The minimum path length of a <questioned path primary> is 0 (zero).

g)

The minimum path length of a <parenthesized path pattern expression> is the minimum path

length of the simply contained <path pattern expression>.

h)

If BNT1 and BNT2 are two BNF non-terminals such that BNT1 ::= BNT2 and the minimum path

length of BNT2 is defined, then the minimum path length of BNT1 is also defined and is the

same as the minimum path length of BNT2.

7)

The <path primary> immediately contained in a <quantified path primary> or <questioned path

primary> shall have minimum path length that is greater than 0 (zero).

8)

The <path primary> simply contained in a <quantified path primary> shall not contain a <quantified

path primary> at the same depth of graph pattern matching.

** Editor’s Note (number 35) **

It may be possible to permit nested quantifiers. WG3:W01-014 contained a discussion of a way to support aggregates

at different depths of aggregation if there are nested quantifiers. See Language Opportunity GQL-036 .

9)

Let PMA be a <path multiset alternation>.

a)

A <path term> simply contained in PMA is a multiset alternation operand of PMA.

b)

Let NOPMA be the number of multiset alternation operands of PMA. Let OPMA 1, ..., OPMANOPMA

be an enumeration of the operands of PMA.

c)

Any <subpath variable> s declared by <subpath variable declaration> s simply contained in the multiset alternation operands of PMA shall be mutually distinct.

d)

Let SOPMA 1, ..., SOPMANOPMA be implementation-dependent (UV008) <identifier> s that are mutually distinct and distinct from every <element variable>, <subpath variable> and <path

variable> contained in GP.

e)

For every i, 1 (one) ≤ i ≤ NOPMA.

Case:

i)

If OPMAi is a <parenthesized path pattern expression> that simply contains a <subpath

variable declaration> , then let OPMAXi be OPMAi.

ii)

Otherwise, let OPMAXi be the <parenthesized path pattern expression>

( SOPMAi = OPMAi)

f)

PMA is equivalent to:

OPMAX 1 | ... | OPMAXNOPMA

10) A <path term> PPUOP simply contained in a <path pattern union> PSD is a path pattern union operand of PSD.

** Editor’s Note (number 36) **

225

IWD 39075:202y(E)

16.10 <path pattern expression>

Path pattern union is not defined using left recursion. WG3:SXM-052 believed that it should be possible to support left

recursion but declined to do so for expediency. It is a Language Opportunity to support left recursion. See Language

Opportunity GQL-025 .

PPUOP shall not contain a reference to an element variable that is not declared in PPUOP or outside

of PSD.

11) An <element pattern> EP that contains an <element pattern where clause> EPWC is transformed as follows:

a)

Let EPF be the <element pattern filler> simply contained in EP.

b)

Let PREFIX be the <delimiter token> contained in EP before EPF and let SUFFIX be the

<delimiter token> contained in EP after EPF.

c)

Let EV be the <element variable> simply contained in EPF. Let ILE be the <is label expression>

contained in EPF, if any; otherwise, let ILE be the zero-length string.

d)

EP is replaced by

( PREFIX EV ILE SUFFIX EPWC )

12) An <element pattern> that does not contain an <element variable declaration> , an <is label

expression> , or an <element pattern predicate> is said to be empty.

13) Each <path pattern expression> is transformed in the following steps:

a)

If the <path primary> immediately contained in a <quantified path primary> or <questioned

path primary> is an <edge pattern> EP, then EP is replaced by ( EP )

NOTE 175 — For example,

->*

becomes:

(->) {0,}

which in later transformations becomes:

(() -> ()) {0,}

b)

If two successive <element pattern>s contained in a <path concatenation> at the same depth of graph pattern matching are <edge pattern>s, then an implicit empty <node pattern> is inserted between them.

c)

If an edge pattern EP contained in a <path term> PST at the same depth of graph pattern matching is not preceded by a <node pattern> contained in PST at the same depth of graph

pattern matching, then an implicit empty <node pattern> VP is inserted in PST immediately prior to EP.

d)

If an edge pattern EP contained in a <path term> PST at the same depth of graph pattern matching is not followed by a <node pattern> contained in PST at the same depth of graph

pattern matching, than an implicit empty <node pattern> VP is inserted in PST immediately after EP.

NOTE 176 — As a result of the preceding transformations, a fixed length path pattern has an odd number of

<element pattern> s, beginning and ending with <node pattern>s, and alternating between <node pattern> s and <edge pattern>s.

e)

Every <abbreviated edge pattern> AEP is replaced with an empty <full edge pattern> as follows.

226

IWD 39075:202y(E)

16.10 <path pattern expression>

Case:

« WG3:UTC-055R1 »

i)

If AEP is <left arrow>, then AEP is replaced by the <full edge pointing left>:

<-[ ]-

ii)

If AEP is <tilde> , then AEP is replaced by the <full edge undirected>:

~[ ]~

iii)

If AEP is <right arrow>, then AEP is replaced by the <full edge pointing right>:

-[ ]->

iv)

If AEP is <left arrow tilde> , then AEP is replaced by the <full edge left or undirected>:

<~[ ]~

v)

If AEP is <tilde right arrow> , then AEP is replaced by the <full edge undirected or right>:

~[ ]~>

vi)

If AEP is <left minus right> , then AEP is replaced by the <full edge left or right> :

<-[ ]->

vii)

If AEP is <minus sign>, then AEP is replaced by the <full edge any direction> :

-[ ]-

14) The minimum node count of certain BNF non-terminals defined in this Subclause is defined recursively

as follows:

a)

The minimum node count of a <node pattern> is 1 (one).

b)

The minimum node count of an <edge pattern> is 0 (zero).

c)

The minimum node count of a <path concatenation> PC is:

Case:

i)

If two successive <element pattern> s contained in PC at the same depth of graph pattern

matching are <node pattern>s, then 1 (one) less than the sum of the minimum node

counts of its operands.

ii)

Otherwise, the sum of the minimum node counts of its operands.

d)

The minimum node count of a <path pattern union> or <path multiset alternation> is the minimum of the minimum node count of its operands.

e)

The minimum node count of a <quantified path primary> is the product of the minimum node

count of the simply contained <path primary> and the value of the <lower bound> of the simply contained <graph pattern quantifier>.

f)

The minimum node count of a <questioned path primary> is 0 (zero).

g)

The minimum node count of a <parenthesized path pattern expression> is the minimum node

count of the simply contained <path pattern expression> .

227

IWD 39075:202y(E)

16.10 <path pattern expression>

h)

If BNF1 and BNF2 are two BNF non-terminals such that BNF1 ::= BNF2 and the minimum node

count of BNF2 is defined, then the minimum node count of BNF1 is also defined and is the

same as the minimum node count of BNF2.

15) The <path pattern expression> simply contained in a <path pattern> shall have a minimum node count that is greater than 0 (zero).

NOTE 177 — The minimum node count is computed after the syntactic transform that adds implicit node patterns.

Thus a single <edge pattern> is a permitted <path pattern> because it implies two <node pattern>s.

« WG3:UTC-080 »

NOTE 178 — A later Syntax Rule makes the same requirement of a <parenthesized path pattern expression> that simply contains a <subpath variable declaration> .

« WG3:UTC-087R2 »

16) An <element variable> EV contained in an <element variable declaration> GPVD is said to be declared by GPVD, and by the <element pattern> EP that simply contains GPVD. The <element variable> is the name of an element variable, which is also declared by GPVD and EP. If GPVD simply contains

TEMP, then EV is a temporary element variable.

NOTE 179 — Element bindings to temporary element variables are removed prior to set-theoretic deduplication of

matches. See GR 10) of Subclause 16.8, “<graph pattern>” and GR 14) of Subclause 22.2, “Machinery for graph pattern

matching”.

17) Prior to the application of syntactic transformations, conforming GQL-language shall not contain

an <element variable declaration> that immediately contains TEMP.

18) An element variable that is declared by a <node pattern> is a node variable. An element variable that is declared by an <edge pattern> is an edge variable.

19) The scope of an <element variable> EV that is declared by an <element pattern> EP is defined as follows. If EV is a temporary element variable, then the scope of EV is the innermost <path term>

containing EP; otherwise, the scope of EV is the innermost <graph pattern binding table> containing EP.

« WG3:UTC-080 »

20) A <subpath variable> SV contained in a <subpath variable declaration> SVD is said to be declared by SVD, and by the <parenthesized path pattern expression> PPPE that simply contains SVD. SV is the name of a subpath variable, which is also declared by SVD and PPPE. If PPPE simply contains a

<subpath variable declaration> , then the minimum node count of PPPE shall be greater than 0

(zero).

21) If EP is an <element pattern> that contains an <element pattern where clause> EPWC, then EP shall simply contain an <element variable declaration> GPVD.

22) If EV is an element variable or subpath variable, and BNT is an instance of a BNF non-terminal, then

the terminology “BNT exposes EV” is defined as follows. The full terminology is one of the following:

“BNT exposes EV as an unconditional singleton variable”, “BNT exposes EV as a conditional singleton variable”, “BNT exposes EV as an effectively bounded group variable” or “BNT exposes EV as an effectively unbounded group variable”. The terms “unconditional singleton variable”, “conditional

singleton variable”, “effectively bounded group variable”, and “effectively unbounded group variable”

are called the degree of exposure.

a)

An <element pattern> EP that declares an element variable EV exposes EV as an unconditional singleton.

b)

A <parenthesized path pattern expression> PPPE that simply contains a <subpath variable

declaration> that declares EV exposes EV as an unconditional singleton variable. PPPE shall not contain another <parenthesized path pattern expression> that declares EV.

228

IWD 39075:202y(E)

16.10 <path pattern expression>

c)

If a <path concatenation> PPC declares EV then let PT be the <path term> and let PF be the

<path factor> simply contained in PPC.

Case:

i)

If EV is exposed as an unconditional singleton by both PT and PF, then EV is exposed

as an unconditional singleton by PPC. EV shall not be a subpath variable.

NOTE 180 — This case expresses an implicit join on EV within PPC. Implicit joins between conditional

singleton variables, group variables, or subpath variables are forbidden.

ii)

Otherwise, EV shall only be exposed by one of PT or PF. In this case EV is exposed by

PPC in the same degree that it is exposed by PT or PF.

d)

If a <path pattern union> or <path multiset alternation> PA declares EV, then Case:

i)

If every operand of PA exposes EV as an unconditional singleton variable, then PA

exposes EV as an unconditional singleton variable.

ii)

If at least one operand of PA exposes EV as an effectively unbounded group variable,

then PA exposes EV as an effectively unbounded group variable.

iii)

If at least one operand of PA exposes EV as an effectively bounded group variable, then

PA exposes EV as an effectively bounded group variable.

iv)

Otherwise, PA exposes EV as a conditional singleton variable.

e)

If a <quantified path primary> QPP declares EV, then let PP be the <path primary> simply contained in QPP.

Case:

i)

If QPP contains a <graph pattern quantifier> that is a <fixed quantifier> or a <general

quantifier> that contains an <upper bound> and PP does not expose EV as an effectively unbounded group variable, then QPP exposes EV as an effectively bounded group

variable.

ii)

If QPP is contained at the same depth of graph pattern matching in a restrictive <par-

enthesized path pattern expression>, then QPP exposes EV as an effectively bounded

group variable.

NOTE 181 — The preceding definition is applied after the syntactic transformation to insure that

every <path mode prefix> is at the head of a <parenthesized path pattern expression> .

iii)

Otherwise, QPP exposes EV as an effectively unbounded group variable.

f)

If a <questioned path primary> QUPP declares EV, then let PP be the <path primary> simply contained in QUPP.

Case:

i)

If PP exposes EV as a group variable, then QUPP exposes EV as a group variable with

the same degree of exposure.

ii)

Otherwise, QUPP exposes EV as a conditional singleton variable.

g)

A <parenthesized path pattern expression> exposes the same variables as the simply contained

<path pattern expression> , in the same degree of exposure.

NOTE 182 — A restrictive <path mode> declared by a <parenthesized path pattern expression> makes variables effectively bounded, but it does so even for proper subexpressions within the scope of the <path mode> and has already been handled by the rules for <quantified path primary>.

229

IWD 39075:202y(E)

16.10 <path pattern expression>

h)

If a <path pattern> PP declares EV, then let PPE be the simply contained <path pattern

expression> .

Case:

i)

If PPE exposes EV as an unconditional singleton, a conditional singleton, or an effectively

bounded group variable, then PP exposes EV with the same degree of exposure.

ii)

Otherwise, PP exposes EV as an effectively bounded group variable.

NOTE 183 — That is, even if PPE exposes EV as an effectively unbounded group variable, PP still

exposes EV as effectively bounded, because in this case PP is required to be a selective <path pattern> .

i)

If BNT1 and BNT2 are two BNF non-terminals such that BNT1 ::= BNT2 and BNT2 exposes EV, then BNT1 exposes EV to the same degree of exposure as BNT2.

** Editor’s Note (number 37) **

WG3:W04-009R1 defined “effectively bounded group variable” but did not use the definition. The definition will

be used when we define predicates on aggregates, at which time we will want a Syntax Rules stating that if a

group variable GV is referenced in a WHERE clause, then it shall be effectively bounded and the reference shall

be contained in an aggregated argument of an <aggregate function>.

23) If BNT is a BNF non-terminal that exposes a graph pattern variable GPV with a degree of exposure

DEGREE, then BNT is also said to expose the name of GPV with degree of exposure DEGREE.

24) A <parenthesized path pattern where clause> PPPWC simply contained in a <parenthesized path

pattern expression> PPPE shall not reference a path variable.

** Editor’s Note (number 38) **

WG3:W04-009R1 recognized that a graph query may have a sequence of MATCH clauses, with the bindings of one

MATCH clause MC1 visible in all subsequent MATCH clauses in the same invocation of <graph table> , and that it should be permissible to reference such variables in any <parenthesized path pattern where clause> simply contained in a subsequent MATCH clause MC2. The relevance of this LO to GQL needs to be investigated. See Language Opportunity

GQL-051 .

General Rules

None.

NOTE 184 — The evaluation of a <path pattern expression> is performed by the General Rules of Subclause 22.3, “Evaluation

of a <path pattern expression>” .

Conformance Rules

1)

Without Feature G030, “Path multiset alternation”, conforming GQL language shall not contain a

<path multiset alternation>.

2)

Without Feature G031, “Path multiset alternation: variable length path operands”, in conforming

GQL language, an operand of a <path multiset alternation> shall be a fixed length path pattern.

3)

Without Feature G032, “Path pattern union”, conforming GQL language shall not contain a <path

pattern union>.

4)

Without Feature G033, “Path pattern union: variable length path operands”, in conforming GQL

language, an operand of a <path pattern union> shall be a fixed length path pattern.

5)

Without Feature G035, “Quantified paths”, conforming GQL language shall not contain a <quantified

path primary> that does not immediately contain a <path primary> that is an <edge pattern> .

230

IWD 39075:202y(E)

16.10 <path pattern expression>

6)

Without Feature G036, “Quantified edges”, conforming GQL language shall not contain a <quantified

path primary> that immediately contains a <path primary> that is an <edge pattern>.

7)

Without Feature G037, “Questioned paths”, conforming GQL language shall not contain a <questioned

path primary> .

8)

Without Feature G038, “Parenthesized path pattern expression”, conforming GQL language shall

not contain a <parenthesized path pattern expression>.

9)

Without Feature G041, “Non-local element pattern predicates”, in conforming GQL language, the

<element pattern where clause> of an <element pattern> EP shall only reference the <element

variable> declared in EP.

10) Without Feature G043, “Complete full edge patterns”, conforming GQL language shall not contain

a <full edge pattern> that is not a <full edge any direction> , a <full edge pointing left>, or a <full

edge pointing right> .

11) Without Feature G044, “Basic abbreviated edge patterns”, conforming GQL language shall not contain

an <abbreviated edge pattern> that is a <minus sign> , <left arrow> , or <right arrow> .

12) Without Feature G045, “Complete abbreviated edge patterns”, conforming GQL language shall not

contain an <abbreviated edge pattern> that is not a <minus sign>, <left arrow>, or <right arrow>.

13) Without Feature G046, “Relaxed topological consistency: adjacent vertex patterns”, in conforming

GQL language, between any two <node pattern> s contained in a <path pattern expression> there shall be at least one <edge pattern>, <left paren>, or <right paren>.

14) Without Feature G047, “Relaxed topological consistency: concise edge patterns”, in conforming

GQL language, any <edge pattern> shall be immediately preceded and followed by a <node pattern>.

15) Without Feature G048, “Parenthesized path pattern: subpath variable declaration”, conforming

GQL language shall not contain a <parenthesized path pattern expression> that simply contains a

<subpath variable declaration> .

16) Without Feature G049, “Parenthesized path pattern: path mode prefix”, conforming GQL language

shall not contain a <parenthesized path pattern expression> that immediately contains a <path

mode prefix>.

17) Without Feature G050, “Parenthesized path pattern: WHERE clause”, conforming GQL language

shall not contain a <parenthesized path pattern where clause> .

18) Without Feature G051, “Parenthesized path pattern: non-local predicates”, in conforming GQL

language, a <parenthesized path pattern where clause> simply contained in a <parenthesized path

pattern expression> PPPE shall not reference an <element variable> that is not declared in PPPE.

231





IWD 39075:202y(E)

16.11 <insert graph pattern>

16.11 <insert graph pattern>

Function

Define an <insert graph pattern> .

Format

<insert graph pattern> ::=

<insert path pattern list>

<insert path pattern list> ::=

<insert path pattern> [ <comma> <insert path pattern>... ]

<insert path pattern> ::=

<insert node pattern> [ { <insert edge pattern> <insert node pattern> }... ]

<insert node pattern> ::=

<left paren> [ <insert element pattern filler> ] <right paren>

<insert edge pattern> ::=

<insert edge pointing left>

| <insert edge pointing right>

| <insert edge undirected>

<insert edge pointing left> ::=

<left arrow bracket> [ <insert element pattern filler> ] <right bracket minus>

<insert edge pointing right> ::=

<minus left bracket> [ <insert element pattern filler> ] <bracket right arrow>

<insert edge undirected> ::=

<tilde left bracket> [ <insert element pattern filler> ] <right bracket tilde>

<insert element pattern filler> ::=

<element variable declaration> [ <label and property set specification> ]

| [ <element variable declaration> ] <label and property set specification>

<label and property set specification> ::=

<label set specification> [ <element property specification> ]

| [ <label set specification> ] <element property specification>

Syntax Rules

« WG3:UTC-094 »

1)

Let IGP be the <insert graph pattern>.

2)

Let IDNSET be the empty set.

3)

For every <insert element pattern filler> IEPF simply contained in IGP that does not immediately contain an <element variable declaration> :

a)

Let IDN be an implementation-dependent (UV011) name that is not equal to the name of the

<element variable declaration> of any other <element pattern> in IGP, any column name in the declared type of the incoming working table of IGP, any field name in the declared type of

the incoming working record of IGP, or any name of a catalog object in the GQL-catalog.

b)

Include IDN in IDNSET.

232

IWD 39075:202y(E)

16.11 <insert graph pattern>

c)

IEPF is effectively replaced by:

IDN IEPF

4)

The implementation-assigned variable names of IGP are IDNSET.

5)

Let IS be the <insert statement> that immediately contains IGP.

6)

An <element variable> EV contained in an <element variable declaration> EVD is said to be declared by EVD, and by the <insert node pattern> or <insert edge pattern> EP that simply contains EVD.

The <element variable> specifies the name of an element variable, which is also declared by EVD

and EP.

7)

For every <value expression> VE immediately contained in a <property key value pair> PKVP

immediately contained in an <element property specification> simply contained in IGP:

a)

The declared type of the incoming working record of VE is the declared type of the incoming

working record of IS amended with the record type of the declared type of the incoming

working table of IS.

b)

The declared type of the incoming working table of VE is the material unit binding table type.

c)

The declared type of VE shall be a supported property value type.

« WG3:UTC-094 »

8)

An insert element pattern is either an <insert node pattern> or an <insert edge pattern> that is simply contained in IGP.

9)

A bound insert element pattern is an insert element pattern IEP that declares an <element variable>

EV whose name is either the name of a column C of the declared type of the incoming working table

of IS or is the name of a field F of the declared type of the incoming working record of IS. The declared type of IEP is the column type of C or the field value type of F.

10) No <property key value pair list> simply contained in a bound insert element pattern shall simply contain two equivalent <property name> s that are each immediately contained in a different

<property key value pair> .

11) For every <element variable> EV simply contained in IGP:

« WG3:UTC-009 P00-USA-169 »

a)

For every bound insert element pattern EP that declares EV:

i)

EP shall not be an <insert node pattern>.

ii)

The declared type of EP shall be a node reference value type.

iii)

EP shall not simply contain a <label and property set specification> .

b)

The defining insert element pattern of EV is the first insert element pattern that declares EV.

Every insert element pattern that declares EV and is not the defining insert element pattern

of EV shall not simply contain a <label and property set specification>.

« Email from: Jim Melton 2022-12-08 0219 »

« Editorial: Correct use of equivalent »

12) If an <insert edge pattern> EP1 declares an <element variable> EV1, then there shall not be an

<insert node pattern> or <insert edge pattern> EP2 that declares an <element variable> EV2 equivalent to EV1.

NOTE 185 — This rule has two consequences.

233

IWD 39075:202y(E)

16.11 <insert graph pattern>

—

If an <insert node pattern> declares an <element variable> EV, then there is not an <insert edge pattern> that declares an <element variable> with the same name as EV.

—

Every <insert edge pattern> is the defining insert element pattern of the element variable it declares.

General Rules

None.

Conformance Rules

None.

234





IWD 39075:202y(E)

16.12 <label expression>

16.12 <label expression>

Function

Specify an expression that matches one or more labels of a graph.

Format

<label expression> ::=

<label term>

| <label disjunction>

<label disjunction> ::=

<label expression> <vertical bar> <label term>

<label term> ::=

<label factor>

| <label conjunction>

<label conjunction> ::=

<label term> <ampersand> <label factor>

<label factor> ::=

<label primary>

| <label negation>

<label negation> ::=

<exclamation mark> <label primary>

<label primary> ::=

<label name>

| <wildcard label>

| <parenthesized label expression>

<wildcard label> ::=

<percent>

<parenthesized label expression> ::=

<left paren> <label expression> <right paren>

Syntax Rules

« WG3:UTC-096R1 »

1)

Let LE be the <label expression> and let GP be the <graph pattern> that simply contains LE.

2)

Let PG be the current working graph available at LE.

NOTE 186 — If no current working graph is available at LE, then this rule cannot be satisfied. See Subclause 4.7.3,

“Working objects” .

3)

Every <label name> contained in LE shall identify a label of PG.

4)

Case:

a)

If LE is simply contained in a <node pattern> , then LE is a node <label expression> . Every <label

name> contained in LE shall identify a node label of PG.

b)

Otherwise, LE is an edge <label expression> . Every <label name> contained in LE shall identify an edge label of PG.

235

IWD 39075:202y(E)

16.12 <label expression>

General Rules

None.

Conformance Rules

1)

Without Feature G074, “Label expression: wildcard label”, conforming GQL language shall not

contain a <wildcard label>.

236





IWD 39075:202y(E)

16.13 <graph pattern quantifier>

16.13 <graph pattern quantifier>

Function

Specify a graph pattern quantifier.

Format

<graph pattern quantifier> ::=

<asterisk>

| <plus sign>

| <fixed quantifier>

| <general quantifier>

<fixed quantifier> ::=

<left brace> <unsigned integer> <right brace>

<general quantifier> ::=

<left brace> [ <lower bound> ] <comma> [ <upper bound> ] <right brace>

<lower bound> ::=

<unsigned integer>

<upper bound> ::=

<unsigned integer>

Syntax Rules

1)

The maximum value of <upper bound> is implementation-defined (IL018). <upper bound>, if specified, shall not be greater than this value.

2)

Every <graph pattern quantifier> is normalized, as follows:

a)

<asterisk> is equivalent to:

{0,}

b)

<plus sign> is equivalent to:

{1,}

c)

If <fixed quantifier> FQ is specified, then let UI be the <unsigned integer> contained in FQ. FQ

is equivalent to:

{ UI, UI}

d)

If <general quantifier> GQ is specified, and if <lower bound> is not specified, then the <unsigned

integer> 0 (zero) is supplied as the <lower bound> .

3)

If <general quantifier> GQ is specified or implied by the preceding normalizations, then

Case:

a)

If <upper bound> is specified, then:

i)

The value of <upper bound> VUP shall be greater than 0 (zero).

ii)

The value of <lower bound> LUP shall be less than or equal to VUP.

237

IWD 39075:202y(E)

16.13 <graph pattern quantifier>

iii)

If LUP equals VUP, then GQ is a fixed quantifier.

iv)

GQ is a bounded quantifier.

b)

Otherwise, GQ is an unbounded quantifier.

4)

A <graph pattern quantifier> that is not a fixed quantifier is a variable quantifier.

General Rules

None.

Conformance Rules

1)

Without Feature G060, “Bounded graph pattern quantifiers”, conforming GQL language shall not

contain a <fixed quantifier> or a <general quantifier> that immediately contains an <upper bound>.

2)

Without Feature G061, “Unbounded graph pattern quantifiers”, conforming GQL language shall not

contain a <graph pattern quantifier> that immediately contains <asterisk>, <plus sign>, or a <general

quantifier> that does not immediately contain an <upper bound> .

238





IWD 39075:202y(E)

16.14 <simplified path pattern expression>

16.14 <simplified path pattern expression>

Function

Express a path pattern as a regular expression of edge labels.

Format

<simplified path pattern expression> ::=

<simplified defaulting left>

| <simplified defaulting undirected>

| <simplified defaulting right>

| <simplified defaulting left or undirected>

| <simplified defaulting undirected or right>

| <simplified defaulting left or right>

| <simplified defaulting any direction>

<simplified defaulting left> ::=

<left minus slash> <simplified contents> <slash minus>

<simplified defaulting undirected> ::=

<tilde slash> <simplified contents> <slash tilde>

<simplified defaulting right> ::=

<minus slash> <simplified contents> <slash minus right>

<simplified defaulting left or undirected> ::=

<left tilde slash> <simplified contents> <slash tilde>

<simplified defaulting undirected or right> ::=

<tilde slash> <simplified contents> <slash tilde right>

<simplified defaulting left or right> ::=

<left minus slash> <simplified contents> <slash minus right>

<simplified defaulting any direction> ::=

<minus slash> <simplified contents> <slash minus>

<simplified contents> ::=

<simplified term>

| <simplified path union>

| <simplified multiset alternation>

<simplified path union> ::=

<simplified term> <vertical bar> <simplified term>

[ { <vertical bar> <simplified term> }... ]

<simplified multiset alternation> ::=

<simplified term> <multiset alternation operator> <simplified term>

[ { <multiset alternation operator> <simplified term> }... ]

<simplified term> ::=

<simplified factor low>

| <simplified concatenation>

<simplified concatenation> ::=

<simplified term> <simplified factor low>

<simplified factor low> ::=

<simplified factor high>

| <simplified conjunction>

239

IWD 39075:202y(E)

16.14 <simplified path pattern expression>

<simplified conjunction> ::=

<simplified factor low> <ampersand> <simplified factor high>

<simplified factor high> ::=

<simplified tertiary>

| <simplified quantified>

| <simplified questioned>

<simplified quantified> ::=

<simplified tertiary> <graph pattern quantifier>

<simplified questioned> ::=

<simplified tertiary> <question mark>

<simplified tertiary> ::=

<simplified direction override>

| <simplified secondary>

<simplified direction override> ::=

<simplified override left>

| <simplified override undirected>

| <simplified override right>

| <simplified override left or undirected>

| <simplified override undirected or right>

| <simplified override left or right>

| <simplified override any direction>

<simplified override left> ::=

<left angle bracket> <simplified secondary>

<simplified override undirected> ::=

<tilde> <simplified secondary>

<simplified override right> ::=

<simplified secondary> <right angle bracket>

<simplified override left or undirected> ::=

<left arrow tilde> <simplified secondary>

<simplified override undirected or right> ::=

<tilde> <simplified secondary> <right angle bracket>

<simplified override left or right> ::=

<left angle bracket> <simplified secondary> <right angle bracket>

<simplified override any direction> ::=

<minus sign> <simplified secondary>

<simplified secondary> ::=

<simplified primary>

| <simplified negation>

<simplified negation> ::=

<exclamation mark> <simplified primary>

<simplified primary> ::=

<label name>

| <left paren> <simplified contents> <right paren>

** Editor’s Note (number 39) **

It has been proposed that a macro name may be a <simplified primary> in a <simplified path pattern expression> . See Language

Opportunity GQL-034 .

240

IWD 39075:202y(E)

16.14 <simplified path pattern expression>

Syntax Rules

1)

A <simplified negation> shall not contain a <simplified concatenation>, <simplified quantified> ,

<simplified questioned>, or <simplified multiset alternation> .

2)

A <simplified direction override> shall not contain another <simplified direction override>.

3)

A <simplified direction override> shall not contain <simplified concatenation>, <simplified quanti-

fied>, <simplified questioned>, or <simplified multiset alternation>.

4)

A <simplified conjunction> shall not contain a <simplified concatenation>, <simplified quantified> ,

<simplified questioned>, or <simplified multiset alternation> .

5)

A <simplified path pattern expression> SPPE is replaced by:

( SPPE )

NOTE 187 — This is done once for each <simplified path pattern expression> prior to the following recursive transformation and not with each iteration of the transformation.

6)

The following rules are recursively applied until no <simplified path pattern expression>s remain.

« Editorial: Align with Directives Part 2 »

NOTE 188 — The rules work from the root of the parse tree of a <simplified path pattern expression> . At each step, the coarsest analysis of a <simplified path pattern expression> is replaced, eliminating at least one level of the parse tree, measured from the root. Note that each replacement can create more <simplified path pattern expression>s

than before, but these replacements have less depth. Eventually the recursion replaces <simplified path pattern

expression> with <edge pattern> .

a)

Let SPPE be a <simplified path pattern expression>.

i)

Let SC be the <simplified contents> contained in SPPE.

ii)

Let PREFIX be the <minus slash> , <left minus slash> , <tilde slash>, <left tilde slash>,

or <left minus slash> contained in SPPE.

iii)

Let SUFFIX be the <slash minus right>, <slash minus> , <slash tilde>, or <slash tilde

right> contained in SPPE.

iv)

Let EDGEPRE and EDGESUF be determined by Table 3, “Conversion of simplified syntax

delimiters to default edge delimiters” , from the row containing the values of PREFIX

and SUFFIX.

« WG3:UTC-013 P16-DEU-019 »

Table 3 — Conversion of simplified syntax delimiters to default

edge delimiters

PREFIX

SUFFIX

EDGEPRE

EDGESUF

-/

/->

-[

]->

<-/

/-

<-[

]-

~/

/~

~[

]~

~/

/~>

~[

]~>

<~/

/~

<~[

]~

<-/

/->

<-[

]->

241

IWD 39075:202y(E)

16.14 <simplified path pattern expression>

PREFIX

SUFFIX

EDGEPRE

EDGESUF

-/

/-

-[

]-

b)

Case:

i)

If SC is a <simplified path union> SPU, then let N be the number of <simplified term>s

simply contained in SPU, and let ST 1, ..., STN be those <simplified term>s; SPPE is replaced by:

PREFIX ST 1 SUFFIX | PREFIX ST 2 SUFFIX | ... | PREFIX STN SUFFIX

ii)

If SC is a <simplified multiset alternation> SMA, then let N be the number of <simplified

term> s simply contained in SMA, and let ST 1, ..., STN be those <simplified term>s; SPPE

is replaced by:

PREFIX ST 1 SUFFIX |+| PREFIX ST 2 SUFFIX |+| ... |+| PREFIX STN SUFFIX

iii)

If SC is a <simplified concatenation> SCAT, then let ST be the <simplified term> and let SFL be the <simplified factor low> simply contained in SCAT; SPPE is replaced by: PREFIX ST SUFFIX PREFIX SFL SUFFIX

iv)

If SC is a <simplified conjunction> SAND, then SPPE is replaced by:

EDGEPRE IS SAND EDGESUF

NOTE 189 — As a result, SAND is now interpreted as a <label expression> within an <edge pattern> .

By earlier Syntax Rules, there are no operators allowed in SAND that cannot be interpreted as oper-

ators of a <label expression> .

v)

If SC is a <simplified quantified> SQ, then let ST be the <simplified tertiary> simply contained in SC and let GPQ be the <graph pattern quantifier> simply contained in SQ; SPPE is replaced by:

( PREFIX ST SUFFIX ) GPQ

vi)

If SC is a <simplified questioned> SQU, then let ST be the <simplified tertiary> simply contained in SC; SPPE is replaced by:

( PREFIX ST SUFFIX ) ?

vii)

If SC is a <simplified direction override> SDO, then let SS be the <simplified secondary>

simply contained in SDO.

Case:

NOTE 190 — As a result of the following replacements, SDO is now interpreted as a <label expression>

within an <edge pattern>. By earlier Syntax Rules, there are no operators allowed in SDO that cannot be interpreted as operators of a <label expression> .

1)

If SDO is <simplified override left>, then SPPE is replaced by:

<-[ IS SS ]-

2)

If SDO is <simplified override undirected>, then SPPE is replaced by:

~[ IS SS ]~

3)

If SDO is <simplified override left or undirected>, then SPPE is replaced by:

242

IWD 39075:202y(E)

16.14 <simplified path pattern expression>

<~[ IS SS ]~

4)

If SDO is <simplified override undirected or right>, then SPPE is replaced by:

~[ IS SS ]~>

5)

If SDO is <simplified override left or right> , then SPPE is replaced by:

<-[ IS SS ]->

6)

If SDO is <simplified override any direction> , then SPPE is replaced by:

-[ IS SS ]-

viii)

If SC is a <simplified negation> SN, then SPPE is replaced by:

EDGEPRE IS SN EDGESUF

NOTE 191 — As a result, SN is now interpreted as a <label expression> within an <edge pattern>. By earlier Syntax Rules, there are no operators allowed in SN that cannot be interpreted as operators of

a <label expression>.

ix)

If SC is a <simplified primary> SP, then

Case:

1)

If SP is a <label name>, then SPPE is replaced by:

EDGEPRE IS SP EDGESUF

2)

Otherwise, let INNER be the <simplified contents> simply contained in SC; SPPE

is replaced by:

( PREFIX INNER SUFFIX )

7)

The Conformance Rules of Subclause 16.10, “<path pattern expression>” are applied to the result

of the previous syntactic transformation.

General Rules

None.

Conformance Rules

1)

Without Feature G039, “Simplified path pattern expression: full defaulting”, conforming GQL language

shall not contain a <simplified path pattern expression> that is not a <simplified defaulting left> , a

<simplified defaulting right> , or a <simplified defaulting any direction> .

2)

Without Feature G080, “Simplified path pattern expression: basic defaulting”, conforming GQL

language shall not contain a <simplified defaulting left>, a <simplified defaulting right>, or a <sim-

plified defaulting any direction> .

3)

Without Feature G081, “Simplified path pattern expression: full overrides”, conforming GQL language

shall not contain a <simplified direction override> that is not a <simplified override left>, <simplified

override right>, or a <simplified override any direction>.

4)

Without Feature G082, “Simplified path pattern expression: basic overrides”, conforming GQL lan-

guage shall not contain a <simplified override left>, a <simplified override right> , or a <simplified

override any direction> .

243





IWD 39075:202y(E)

16.15 <where clause>

16.15 <where clause>

Function

Compute a new binding table by selecting records from the current working table fulfilling the specified

<search condition> .

Format

<where clause> ::=

WHERE <search condition>

Syntax Rules

1)

Let WC be the <where clause> and let SC be the <search condition> immediately contained in WC.

2)

The declared type of the incoming working record of SC is the declared type of the incoming

working record of WC amended with the record type of the declared type of the incoming working

table of WC.

3)

The declared type of the incoming working table of SC is the material unit binding table type.

4)

The declared type of WC is the declared type of incoming working table of WC.

General Rules

1)

Let WHERE be a new empty binding table.

2)

For each record R of the current working table:

a)

Let INCLUDE be the result of SC in a new child execution context amended with R.

b)

If INCLUDE is True, then add R to WHERE.

« WG3:UTC-096R1 »

3)

The result of WC is WHERE.

Conformance Rules

None.

« WG3:UTC-086R1 deleted one Subclause »

« WG3:UTC-122 moved two Subclauses »

244





IWD 39075:202y(E)

16.16 <yield clause>

16.16 <yield clause>

Function

« WG3:UTC-108 »

Select and rename columns of a binding table.

Format

<yield clause> ::=

YIELD <yield item list>

<yield item list> ::=

<yield item> [ { <comma> <yield item> }... ]

<yield item> ::=

{ <yield item name> [ <yield item alias> ] }

<yield item name> ::=

<field name>

<yield item alias> ::=

AS <binding variable>

Syntax Rules

1)

Let YC be the <yield clause>.

2)

Let COYI be the collection of <yield item>s simply contained in YC.

3)

Let n be the number of <yield item>s in COYI.

« WG3:UTC-108 »

4)

For each <yield item> YIi, 1 (one) ≤ i ≤ n, in COYI:

a)

Let YINi be the <yield item name> specified by YIi.

b)

If YIi does not immediately contain a <yield item alias>, then:

i)

YIN i shall be a <binding variable>.

ii)

YIi is effectively replaced by:

YINi AS YINi

5)

Let YCT be the <yield clause> after the preceding transformation and let COYIT be the collection of n <yield item>s simply contained in YCT.

6)

If COYIT simply contains a <yield item alias> that simply contains a <binding variable> YIABV1, then COYIT shall not simply contain another <yield item alias> that simply contains a <binding

variable> YIABV2 such that YIABV1 and YIABV2 are equivalent.

7)

The declared type of YCT is a binding table type BTT defined as follows:

a)

BTT has n columns.

« WG3:UTC-108 »

245

IWD 39075:202y(E)

16.16 <yield clause>

b)

For each <yield item> YIi, 1 (one) ≤ i ≤ n in COYIT:

i)

Let YINi be the <yield item name> specified by YIi.

ii)

Let YIAi be the <binding variable> simply contained in the <yield item alias> specified by YIi.

iii)

The declared type of the incoming working table of YC shall have a column SC with

column name YINi.

iv)

BTT has a column TC.

v)

The column type of TC is the column type of SC.

General Rules

1)

Let YIELD be a new empty binding table.

2)

For each record R of the current working table in a new child execution context amended with R:

a)

Let T be a new empty record.

b)

For each <yield item> YIi, 1 (one) ≤ i ≤ n, from COYIT:

i)

Let YINi be the <yield item name> specified by YIi.

ii)

Let Fi be the field of the current working record whose field name is YINi.

iii)

Let YIVi be the field value of Fi.

NOTE 192 — As opposed to the General Rules for <binding variable> , <yield item>s only consider the current working record and ignore the working records of any parent execution contexts that

precede the current execution context in the current execution stack.

iv)

Let YIAi be the <binding variable> simply contained in the <yield item alias> specified by YIi.

v)

Add a new field with field name YIAi and with field value YIVi to T.

c)

Add T to YIELD.

3)

The result of YTC is YIELD.

« WG3:UTC-108 »

Conformance Rules

None.

246





IWD 39075:202y(E)

16.17 <group by clause>

16.17 <group by clause>

Function

Define a <group by clause> for specifying the set of grouping keys to be used during grouping.

** Editor’s Note (number 40) **

Aggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 .

Format

<group by clause> ::=

GROUP BY <grouping element list>

<grouping element list> ::=

<grouping element> [ { <comma> <grouping element> } ]

| <empty grouping set>

<grouping element> ::=

<binding variable reference>

<empty grouping set> ::=

<left paren> <right paren>

Syntax Rules

1)

Let GBC be the <group by clause> and let GEL be the <grouping element list> .

2)

Let COLS be the sequence of columns determined as follows.

Case:

a)

If GEL is the <empty grouping set>, then COLS is the zero-length sequence.

b)

Otherwise:

i)

Let GESEQ be the sequence of <grouping element>s immediately contained in GEL and

let NGESEQ be the number of such <grouping element> s in GESEQ.

ii)

For every i-th element GEi of GESEQ, 1 (one) ≤ i ≤ NGESEQ:

1)

Let BVRi be the <binding variable reference> immediately contained in GEi.

« WG3:UTC-081 »

2)

The declared type of the incoming working record of BVRi is the declared type of

the incoming working record of GBC amended with the record type of the declared

type of the incoming working table of GBC.

3)

The declared type of the incoming working table of BVRi is the unit binding table

type.

« Editorial: Correct application »

4)

BVRi is an operand of a grouping operation. The Syntax Rules and Conformance

Rules of Subclause 22.14, “Grouping operations”, apply.

5)

Let GEBVi be the name of the binding variable referenced by BVRi.

247

IWD 39075:202y(E)

16.17 <group by clause>

6)

Let COL i be the column whose name is GEBVi and whose type is the declared type

of BVRi.

7)

Append COL to COLS.

3)

The declared type of the outgoing working table of GBC is a material binding table whose set of

columns is COLS.

4)

The declared type of the outgoing working record of GBC is the declared type of the incoming

working record of GBC.

5)

The declared type of GBC is the declared type of the outgoing working table of GBC.

General Rules

1)

Case:

a)

If GEL is the <empty grouping set>, then let GROUP_BY be a unit binding table.

b)

Otherwise:

i)

Let GEi, 1 (one) ≤ i ≤ NGESEQ, be the i-th element of GESEQ and let GEBVi be the

<binding variable reference> simply contained in GEBVi.

ii)

Let GROUP_BY be a new empty binding table with the column set COLS.

iii)

For each record R of the current working table in a new child execution context amended

with R:

1)

Let T be a new record comprising fields Fi, 1 (one) ≤ i ≤ NGESEQ, such that the

field name of Fi is the column name of COLSi and the field value of Fi is the value

of GEBVi in R.

« WG3:UTC-081 »

2)

If T is distinct from every record in GROUP_BY, then T is added to GROUP_BY.

« WG3:UTC-081 »

2)

The result of GBC is GROUP_BY.

Conformance Rules

« WG3:UTC-081 »

1)

Without Feature GC11, “GROUP BY clause”, conforming GQL-language shall not contain <group by

clause> .

248





IWD 39075:202y(E)

16.18 <order by clause>

16.18 <order by clause>

Function

« WG3:UTC-096R1 »

Apply a <sort specification list> to the current working table.

Format

<order by clause> ::=

ORDER BY <sort specification list>

Syntax Rules

« WG3:UTC-096R1 »

1)

Let OBC be the <order by clause>.

2)

Let SSL be the <sort specification list> that is immediately contained in OBC.

3)

The declared type of OBC is the declared type of the incoming working table of OBC.

General Rules

« WG3:UTC-096R1 Deleted 2 GRs »

« WG3:UTC-096R1 »

1)

The result of OBC is the result of SSL.

Conformance Rules

None.

249





IWD 39075:202y(E)

16.19 <aggregate function>

16.19 <aggregate function>

Function

Specify a value computed from a collection of records.

** Editor’s Note (number 41) **

Aggregation functionality should be improved for the needs of GQL. See Language Opportunity GQL-017 .

« WG3:UTC-081 Deleted 1 (one) editor's note in consequence »

Format

<aggregate function> ::=

COUNT <left paren> <asterisk> <right paren>

| <general set function>

| <binary set function>

** Editor’s Note (number 42) **

Consider inclusion of aggregate function calls to procedures with formal parameters of multiple parameter cardinality. See

Language Opportunity GQL-186 .

« WG3:UTC-123R2 »

<general set function> ::=

<general set function type>

<left paren> [ <set quantifier> ] <value expression> <right paren>

<binary set function> ::=

<binary set function type>

<left paren> <dependent value expression> <comma> <independent value expression>

<right paren>

« WG3:UTC-081 »

<general set function type> ::=

AVG

| COUNT

| MAX

| MIN

| SUM

| COLLECT

| STDDEV_SAMP

| STDDEV_POP

<set quantifier> ::=

DISTINCT

| ALL

« WG3:UTC-081 »

<binary set function type> ::=

PERCENTILE_CONT

| PERCENTILE_DISC

<dependent value expression> ::=

[ <set quantifier> ] <numeric value expression>

<independent value expression> ::=

250

IWD 39075:202y(E)

16.19 <aggregate function>

<numeric value expression>

Syntax Rules

« WG3:UTC-081 deleted an editor's note »

1)

Let AF be the <aggregate function> .

« Editorial: Reword to use AF »

2)

If AF immediately contains a <general set function> that does not specify the <set quantifier> , then ALL is implicit.

« WG3:UTC-081 Deleted 1 (one) SR »

3)

AF shall not contain a <procedure body> .

« WG3:UTC-056R1 Deleted 1 (one) editor's note consequently »

4)

AF shall not directly contain an <aggregate function> .

« WG3:UTC-123R2 »

5)

Let the <value expression> or the <dependent value expression> VE be defined as follows.

Case:

a)

If AF is directly contained in a <value expression> that is not immediately contained in an

<aggregating value expression>, then VE is the <value expression> or the <dependent value

expression> immediately contained in AF.

b)

If AF immediately contains a <general set function> GSF, then VE is the <value expression>

immediately contained in GSF.

c)

Otherwise, AF immediately contains a <binary set function> BSF and VE is the <dependent

value expression> immediately contained in BSF.

6)

Let DT be the declared type of VE.

« WG3:UTC-081 Deleted 2 SRs »

« WG3:UTC-123R2 Consequence »

7)

If AF immediately contains COUNT, then:

a)

If AF immediately contains <asterisk>, then AF shall be directly contained in an <aggregating

value expression>.

b)

The declared type of the result is an implementation-defined (ID059) exact numeric type with

scale 0 (zero).

8)

If AF immediately contains a <general set function>, then:

« WG3:UTC-123R2 »

« WG3:UTC-123R2 Deleted 1 (one) SR in consequence »

« WG3:UTC-123R2 Deleted 1 (one) SR »

a)

If AF specifies a <general set function> whose <set quantifier> is DISTINCT, then VE is an operand of a grouping operation. The Syntax Rules and Conformance Rules of Subclause 22.14,

“Grouping operations” , apply.

b)

If AF specifies a <general set function type> that is MAX or MIN, then VE is an operand of an ordering operation. The Syntax Rules and Conformance Rules of Subclause 22.13, “Ordering

operations”, apply.

251

IWD 39075:202y(E)

16.19 <aggregate function>

« WG3:UTC-081 Deleted 1 (one) GR »

c)

If MAX or MIN is specified, then the declared type of the result is DT.

d)

If SUM or AVG is specified, then:

i)

DT shall be a numeric type.

ii)

If SUM is specified and DT is exact numeric with scale S, then the declared type of the

result is an implementation-defined (ID095) exact numeric type with scale S.

iii)

If AVG is specified and DT is exact numeric, then the declared type of the result is an

implementation-defined (ID096) exact numeric type with precision not less than the

precision of DT and scale not less than the scale of DT.

iv)

If DT is approximate numeric, then the declared type of the result is an implementation-

defined (ID097) approximate numeric type with precision not less than the precision

of DT.

e)

If STDDEV_POP or STDDEV_SAMP is specified, then DT shall be a numeric type and the declared

type of the result shall be an implementation-defined (ID098) approximate numeric type. If

DT is an approximate numeric type, then the precision of the result is not less than the precision

of DT.

« WG3:UTC-123R2 »

f)

If COLLECT is specified, then the declared type of the result is the regular list value type whose

list element type is DT.

9)

If AF immediately contains a <binary set function> , then:

a)

Let DVEXP be the <numeric value expression> immediately contained in the <dependent value

expression> immediately contained in AF.

b)

Let IVE be the <independent value expression> simply contained in AF.

c)

If AF specifies no <set quantifier>, then ALL is implicit.

d)

The declared type of the incoming working record of the DVEXP is the declared type of the

incoming working record of AF amended with the record type of declared type of the incoming

working table of AF.

e)

The declared type of the incoming working table of DVEXP is the material unit binding table

type.

f)

The declared type of the incoming working record of IVE is the declared type of the incoming

working record of AF.

g)

The declared type of the incoming working table of IVE is the material unit binding table type.

« WG3:UTC-123R2 »

h)

Let DTIVE be the declared type of IVE.

i)

The declared type of the result is an implementation-defined (ID099) approximate numeric

type. If DT is an approximate numeric type, then the precision of the result is not less than

the precision of DT. If DTIVE is an approximate numeric type, then the precision of the result

is not less than the precision of DTIVE.

General Rules

1)

Let TABLE be the current working table.

252

IWD 39075:202y(E)

16.19 <aggregate function>

« WG3:UTC-081 »

2)

If, during the computation of the result of AF, an intermediate result is not representable in the

declared type of the site that contains that intermediate result, then

Case:

a)

If the most specific type of the result of AF is a list value type, then an exception condition is

raised: data exception — list data, right truncation (22G0B).

b)

If the most specific type of the result of AF is a character string type, then an exception condition

is raised: data exception — string data, right truncation (22001).

c)

Otherwise, an exception condition is raised: data exception — numeric value out of range

(22003).

« WG3:UTC-123R2 »

3)

Let SQ be defined as follows.

Case:

a)

If AF is a <general set function> GSF, then SQ is the <set quantifier> immediately contained in GSF.

« WG3:UTC-081 »

b)

Otherwise, AF is a <binary set function> BSF SQ is the <set quantifier> immediately contained in the <dependent value expression> immediately contained in BSF.

« WG3:UTC-123R2 »

4)

Let the collection VALUES be determined as follows.

Case:

a)

If AF is directly contained in a <value expression> that is not immediately contained in an

<aggregating value expression>, then:

i)

Let GLBV be the binding variable referenced by <binding variable reference> s simply

contained in AF without an intervening instance of <independent value expression>

whose declared type is the group list value type.

ii)

General Rules of Subclause 22.7, “Evaluating an expression on a group variable” , are

applied with GLBV as GROUP LIST BINDING VARIABLE and VE as EXPRESSION; let VALUES be the LIST VALUE returned from the application of those General Rules

b)

Otherwise:

i)

Initially, VALUES is an empty collection.

ii)

For each record R of TABLE in a new child execution context amended with R:

1)

Let EXPRE be the result of VE.

2)

Case:

A)

If SQ is DISTINCT and EXPRE is not in VALUES, then EXPRE is added to

VALUES;

B)

Otherwise, SQ is ALL and EXPRE is added to VALUES.

« WG3:UTC-081 »

5)

Let N be the cardinality of VALUES.

253

IWD 39075:202y(E)

16.19 <aggregate function>

« WG3:UTC-081 »

6)

Let RESULT be defined as follows.

Case:

a)

If AF is COUNT(*), then RESULT is N.

b)

If AF is the <general set function> GSF, then

Case:

i)

If COUNT is specified, then RESULT is N.

ii)

If VALUES is empty, then RESULT is the null value.

iii)

If MAX or MIN is specified, then RESULT is the result, respectively, of the maximum

value or the minimum value in VALUES. RESULT is determined using the comparison

rules specified in Subclause 19.3, “<comparison predicate>”.

iv)

If SUM is specified, then RESULT is the sum of the values in VALUES. If RESULT is not

within the range of the declared type of RESULT, then an exception condition is raised:

data exception — numeric value out of range (22003).

v)

If STDDEV_POP or STDDEV_SAMP is specified, then let SX be the sum of values in VALUES

and let SXS be the sum of the squares of the values in VALUES.

1)

If STDDEV_POP is specified, then RESULT is SQRT(( SXS- SX* SX/ N)/ N).

2)

If STDDEV_SAMP is specified, then

Case:

A)

If N is 1 (one), then RESULT is the null value.

B)

Otherwise, then RESULT is SQRT(( SXS- SX* SX/ N)/( N - 1))

3)

If COLLECT is specified, then RESULT is the list comprised of all values in VALUES.

If RESULT is not within the range of the declared type of RESULT, then an exception

condition is raised: data exception — list data, right truncation (22G0B).

c)

Otherwise, AF is the <binary set function> BSF. Let IVE be the <independent value expression>

immediately contained in BSF, let IVERE be the result of evaluating IVE in a new child execution

context, and

Case:

i)

If VALUES is empty, then RESULT is the null value.

ii)

EXP is an operand of an ordering operation. The Syntax Rules and Conformance Rules

of Subclause 22.13, “Ordering operations” , apply.

iii)

Let ORDERED_VALUES be the sequence of non-null elements in VALUES ordered from

least to greatest. ORDERED_VALUES is determined using the comparison rules specified

in Subclause 19.3, “<comparison predicate>” . Let N_ORDERED_VALUES be the cardin-

ality of ORDERED_VALUES.

iv)

Let INDEX be the result of 1 + ( IVERE * ( N_ORDERED_VALUES - 1)).

v)

If PERCENTILE_CONT is specified, then

Case:

254

IWD 39075:202y(E)

16.19 <aggregate function>

1)

If INDEX is an integer, then RESULT is the value in ORDERED_VALUES at position

INDEX.

2)

If INDEX is an integer, then RESULT is the value in ORDERED_VALUES at position

INDEX.

vi)

If PERCENTILE_DISC is specified, then

Case:

1)

If INDEX is an integer, then RESULT is the value in ORDERED_VALUES at position

INDEX.

2)

Otherwise, RESULT is the value in ORDERED_VALUES at the position obtained as

a result of rounding or truncating INDEX. The choice of whether to round or

truncate is implementation-defined (ID100).

« WG3:UTC-081 Deleted 1 (one) editor's note by implication »

7)

The result of evaluating AF is RESULT.

Conformance Rules

« WG3:UTC-060 »

1)

Without Feature GC21, “Advanced aggregate functions: general set functions”, conforming GQL

language shall not contain an <aggregate function> that immediately contains a <general set function

type> that is that is COLLECT, STDDEV_SAMP, or STDDEV_POP.

2)

Without Feature GC22, “Advanced aggregate functions: binary set functions”, conforming GQL lan-

guage shall not contain an <aggregate function> that immediately contains a <binary set function

type> .

255





IWD 39075:202y(E)

16.20 <sort specification list>

16.20 <sort specification list>

Function

« WG3:UTC-096R1 »

Obtaining an ordered binding table from the current working table.

Format

<sort specification list> ::=

<sort specification> [ { <comma> <sort specification> }... ]

<sort specification> ::=

<sort key> [ <ordering specification> ] [ <null ordering> ]

« WG3:UTC-081 »

<sort key> ::=

<aggregating value expression>

« WG3:UTC-050 »

<ordering specification> ::=

ASC

| ASCENDING

| DESC

| DESCENDING

<null ordering> ::=

NULLS FIRST

| NULLS LAST

Syntax Rules

1)

Each <value expression> immediately contained in the <sort key> contained in a <sort specification>

is an operand of an ordering operation. The Syntax Rules and Conformance Rules of Subclause 22.13,

“Ordering operations” , apply.

2)

Let SSL be the <sort specification list>

3)

Let NSS be the number of <sort specification>s immediately contained in SSL.

4)

Let SSi, 1 (one) ≤ i ≤ NSS, be the i-th <sort specification> immediately contained in SSL.

5)

For each SSi, 1 (one) ≤ i ≤ NSS:

a)

Let SKi be the <sort key> immediately contained in SSi.

b)

If SSi does not immediately contain an <ordering specification> , then SSi is effectively replaced by:

SKi ASC

c)

The declared type of the incoming working record of SKi is the declared type of the incoming

working record of SSL amended with the record type of the declared type of the incoming

working table of SSL.

d)

The declared type of the incoming working table of SKi is the material unit binding table type.

256

IWD 39075:202y(E)

16.20 <sort specification list>

e)

The declared type of SKi is the declared type of the <value expression> immediately contained in SKi.

6)

If <null ordering> is not specified, then an implementation-defined (ID060) <null ordering> is implicit. The implementation-defined default for <null ordering> shall not depend on the context

outside of <sort specification list>.

« WG3:UTC-096R1 »

7)

The declared type of SSL is the declared type of the incoming working table of SSL.

General Rules

« WG3:UTC-096R1 »

1)

Let SORTED be a new ordered binding table created from the collection of records of the current

working table by ordering the records, as follows:

a)

Let N be the number of <sort specification>s.

b)

Let Ki, 1 (one) ≤ i ≤ N, be the <sort key> contained in the i-th <sort specification> .

« WG3:UTC-050 »

c)

Each <sort specification> specifies the sort direction for the corresponding sort key Ki. If neither DESC nor DESCENDING is specified in the i-th <sort specification>, then the sort direction for Ki is ascending and the applicable <comp op> is the <less than operator>; otherwise, the sort direction for Ki is descending and the applicable <comp op> is the <greater than

operator>.

d)

Let P be any record of the collection of records to be ordered, and let Q be any other record

of the same collection of records.

e)

Let PVi be the result of Ki in a new child execution context amended with P.

f)

Let QVi be the result of Ki in a new child execution context amended with Q.

g)

The relative position of records P and Q in the result is determined by comparing PVi and QVi

as follows:

« WG3:UTC-050 »

i)

The comparison is performed according to the General Rules of Subclause 19.3,

“<comparison predicate>”, where the <comp op> is the applicable <comp op> for Ki.

ii)

The comparison is performed with the following special treatment of null values.

Case:

1)

If PVi and QVi are both the null value, then they are considered equal to each other.

2)

If PVi is the null value and QVi is not the null value, then

Case:

A)

If NULLS FIRST is specified or implied, then PVi <comp op> QVi is considered

to be True.

B)

If NULLS LAST is specified or implied, then PVi <comp op> QVi is considered

to be False.

257

IWD 39075:202y(E)

16.20 <sort specification list>

3)

If PVi is not the null value and QVi is the null value, then

Case:

A)

If NULLS FIRST is specified or implied, then PVi <comp op> QVi is considered

to be False.

B)

If NULLS LAST is specified or implied, then PVi <comp op> QVi is considered

to be True.

h)

PVi is said to precede QVi if the result of the <comparison predicate> “PV

” is

i <comp op> QVi

True for the applicable <comp op>.

i)

If PVi and QVi are not the null value and the result of “PVi <comp op> QVi” is Unknown, then the relative ordering of PVi and QVi is implementation-dependent (US007).

j)

The relative position of record P is before record Q if PVn precedes QVn for some n, 1 (one) ≤

n ≤ N, and PVi is not distinct from QVi for all i < n.

k)

Two records that are not distinct with respect to the <sort specification> s are said to be peers of each other. The relative ordering of peers is implementation-dependent (US006).

« WG3:UTC-096R1 »

l)

The result of SSL is SORTED.

Conformance Rules

1)

Without Feature GB10, “Elementary OLAP operations”, conforming GQL language shall not contain

a <null ordering> .

258





IWD 39075:202y(E)

16.21 <limit clause>

16.21 <limit clause>

Function

« WG3:UTC-096R1 »

Obtain a new binding table that retains only a limited number of records of the current working table.

Format

<limit clause> ::=

LIMIT <unsigned integer specification>

** Editor’s Note (number 43) **

WITH TIES, ONLY, RECORDS, and GROUPS to be added. See Language Opportunity GQL-161

Syntax Rules

« WG3:UTC-096R1 »

1)

Let LC be the <limit clause>.

2)

The declared type of LC is the declared type of the incoming working table of LC.

General Rules

1)

Let TABLE be the current working table.

2)

If TABLE is not ordered, then let ORDERED_TABLE be a new ordered binding table created from the

result of sorting the collection of all records of TABLE according to an implementation-dependent

(US001) order; otherwise, let ORDERED_TABLE be TABLE.

3)

Let V be the result of the <unsigned integer specification>.

4)

Let LIMIT be a new ordered binding table obtained by selecting only the first V records of

ORDERED_TABLE and discarding all subsequent records.

« WG3:UTC-096R1 »

NOTE 193 — If the order of the result of LC has no effect on the outcome of a <GQL-program> , there is no need for LIMIT to be indicated as ordered.

5)

The result of LC is LIMIT.

Conformance Rules

None.

259





IWD 39075:202y(E)

16.22 <offset clause>

16.22 <offset clause>

Function

« WG3:UTC-096R1 »

Obtaining a new binding table that retains all records of the current working table except for some dis-

carded initial records.

Format

<offset clause> ::=

<offset synonym> <unsigned integer specification>

<offset synonym> ::=

OFFSET | SKIP

** Editor’s Note (number 44) **

WITH TIES, ONLY, RECORDS, and GROUPS to be added. See Language Opportunity GQL-162 .

Syntax Rules

« WG3:UTC-096R1 »

1)

Let OC be the <offset clause> .

2)

The declared type of OC is the declared type of the incoming working table of OC.

General Rules

1)

Let TABLE be the current working table.

2)

If TABLE is not ordered, then let ORDERED_TABLE be a new ordered binding table created from the

result of sorting the collection of all records of TABLE according to an implementation-dependent

(US001) order; otherwise, let ORDERED_TABLE be TABLE.

« WG3:UTC-096R1 »

NOTE 194 — If the order of the result of OC has no effect on the outcome of a <GQL-program> , there is no need for OFFSET to be indicated as ordered.

3)

Let V be the result of the <unsigned integer specification>.

4)

Let OFFSET be a new ordered binding table obtained from all but the first V records of

ORDERED_TABLE.

« WG3:UTC-096R1 »

5)

The result of OC is OFFSET.

Conformance Rules

None.

260





IWD 39075:202y(E)

17 Type elements

« WG3:UTC-042 »

17.1 <graph type specification>

Function

Define a graph type.

Format

<graph type specification> ::=

[ PROPERTY ] GRAPH TYPE <nested graph type specification>

<nested graph type specification> ::=

<left brace> <graph type specification body> <right brace>

<graph type specification body> ::=

<element type definition list>

<element type definition list> ::=

<element type definition> [ { <comma> <element type definition> }... ]

<element type definition> ::=

<node type definition>

| <edge type definition>

Syntax Rules

1)

Let GTDB be the <graph type specification body> .

2)

Let NTDS be the set of <node type definition>s simply contained in GTDB.

3)

NTDS shall not contain two <node type definition>s that simply contain <node type name> s that specify the same node type name.

4)

Let NTND be the node type name dictionary that maps every <node type name> NTN in NTDS to the node type defined by the <node type definition> that simply contains NTN.

5)

Let ETDS be the set of <edge type definition> s simply contained in GTDB.

6)

ETDS shall not contain two <edge type definition>s that simply contain <edge type name> s that specify the same edge type name.

7)

Let ETND be the edge type name dictionary that maps every <edge type name> ETN in ETDS to the node type defined by the <edge type definition> that simply contains ETN.

General Rules

1)

The graph type defined by the <graph type specification> GTS is the graph type defined by the

<graph type specification body> simply contained in GTS.

261

IWD 39075:202y(E)

17.1 <graph type specification>

2)

The graph type defined by the <nested graph type specification> NGTS is the graph type defined by the <graph type specification body> simply contained in NGTS.

3)

The graph type defined by GTDB is described by the graph type descriptor containing:

« WG3:UTC-015 »

a)

The name of the associated base type of all graph types (PROPERTY GRAPH DATA).

b)

The set of all node type descriptors defined by the <node type definition> s contained in NTDS

as the node type set.

c)

The set of all edge type descriptors defined by the <edge type definition> s contained in ETDS

as the edge type set.

d)

The node type name dictionary NTND.

e)

The edge type name dictionary ETND.

Conformance Rules

None.

262





IWD 39075:202y(E)

17.2 <node type definition>

17.2 <node type definition>

Function

Define a node type.

Format

<node type definition> ::=

<node type pattern>

| <node synonym> <node type phrase>

<node type pattern> ::=

<left paren> [ <node type name> ] [ <node type filler> ] <right paren>

<node type phrase> ::=

[ TYPE ] <node type name> [ <node type filler> ]

| <node type filler>

<node type name> ::=

<element type name>

<node type filler> ::=

<node type label set definition>

| <node type property type set definition>

| <node type label set definition> <node type property type set definition>

<node type label set definition> ::=

<label set definition>

<node type property type set definition> ::=

<property type set definition>

Syntax Rules

1)

Let NTD be the <node type definition> .

« WG3:UTC-086R1 »

2)

If NTD is simply contained in a <closed node reference value type> , then NTD shall not contain a

<node type name>.

3)

If NTD is simply contained in a <graph type specification body> GTSB and contains a <node type

name> NTN but does not contain a <node type label set definition> , then NTD is transformed as follows:

a)

If NTD contains a <node type property type set definition> , then let NTPTSD be that <node

type property type set definition>; otherwise, let NTPTSD be the zero-length character string.

b)

The following <node type filler> is implicit and replaces the existing <node type filler> , if any:

: NTN NTPTSD

4)

If NTD is simply contained in a <graph type specification body> and does not contain a <node type

name> , then NTN is set to an implementation-dependent (UD001) name different from any other node type name in the <graph type specification body> .

263

IWD 39075:202y(E)

17.2 <node type definition>

5)

If NTD contains a <node type label set definition> NTLSD, then let NTLS the label set that is specified by the <label set definition> immediately contained in NTLSD. Otherwise, let NTLS be an empty label set.

6)

If the cardinality of NTLS is less than the implementation-defined (IL001) node label set minimum

cardinality, then an exception condition is raised: syntax error or access rule violation — number of

node labels below supported minimum (42009).

7)

If the cardinality of NTLS is greater than the implementation-defined (IL003) node label set maximum cardinality, then an exception condition is raised: syntax error or access rule violation — number of

node labels exceeds supported maximum (42010).

8)

The base type of node types is named NODE DATA. The preferred name of node types is implemen-

tation-defined (ID089) as either NODE or VERTEX.

« WG3:UTC-096R1 »

9)

If NTD contains a <node type property type set definition> NTPTSD, then let NTPTS be the property type set that is specified by the <property type set definition> immediately contained in NTPTSD.

Otherwise, let NTPTS be an empty property type set.

10) If the cardinality of NTPTS is greater than the implementation-defined (IL004) node property set maximum cardinality, then an exception condition is raised: syntax error or access rule violation —

number of node properties exceeds supported maximum (42011).

General Rules

1)

The node type defined by NTD is described by a node type descriptor NTDESC containing:

« WG3:UTC-015 »

a)

The name of the associated base type of all node types (NODE DATA).

b)

The node type label set NTLS.

c)

The node type property type set NTPTS.

2)

Case:

a)

If NTD is simply contained in a <graph type specification body> , then:

i)

NTDESC is added to the set of node type descriptors in GTSB.

ii)

NTN is added to the node type name dictionary in GTSB.

« WG3:UTC-086R1 »

b)

Otherwise NTDESC is added to the <closed node reference value type> in which it is contained.

Conformance Rules

1)

Without Feature GA08, “Named node types in graph types”, conforming GQL Language shall not

contain a <node type definition> that contains a <node type phrase>.

264





IWD 39075:202y(E)

17.3 <edge type definition>

17.3 <edge type definition>

Function

Define an edge type.

Format

<edge type definition> ::=

<edge type pattern>

| [ <edge kind> ] <edge synonym> <edge type phrase>

<edge type pattern> ::=

<full edge type pattern>

| <abbreviated edge type pattern>

<edge type phrase> ::=

[ TYPE ] <edge type name> [ <edge type filler> <endpoint definition> ]

| <edge type filler> <endpoint definition>

<edge type name> ::=

<element type name>

<edge type filler> ::=

<edge type label set definition>

| <edge type property type set definition>

| <edge type label set definition> <edge type property type set definition>

<edge type label set definition> ::=

<label set definition>

<edge type property type set definition> ::=

<property type set definition>

<full edge type pattern> ::=

<full edge type pattern pointing right>

| <full edge type pattern pointing left>

| <full edge type pattern undirected>

<full edge type pattern pointing right> ::=

<source node type reference> <arc type pointing right> <destination node type reference>

<full edge type pattern pointing left> ::=

<destination node type reference> <arc type pointing left> <source node type reference>

<full edge type pattern undirected> ::=

<source node type reference> <arc type undirected> <destination node type reference>

<arc type pointing right> ::=

<minus left bracket> <arc type filler> <bracket right arrow>

<arc type pointing left> ::=

<left arrow bracket> <arc type filler> <right bracket minus>

<arc type undirected> ::=

<tilde left bracket> <arc type filler> <right bracket tilde>

<arc type filler> ::=

[ <edge type name> ] [ <edge type filler> ]

<abbreviated edge type pattern> ::=

<abbreviated edge type pattern pointing right>

265

IWD 39075:202y(E)

17.3 <edge type definition>

| <abbreviated edge type pattern pointing left>

| <abbreviated edge type pattern undirected>

<abbreviated edge type pattern pointing right> ::=

<source node type reference> <right arrow> <destination node type reference>

<abbreviated edge type pattern pointing left> ::=

<destination node type reference> <left arrow> <source node type reference>

<abbreviated edge type pattern undirected> ::=

<source node type reference> <tilde> <destination node type reference>

<node type reference> ::=

<source node type reference>

| <destination node type reference>

<source node type reference> ::=

<left paren> <source node type name> <right paren>

| <left paren> [ <node type filler> ] <right paren>

<destination node type reference> ::=

<left paren> <destination node type name> <right paren>

| <left paren> [ <node type filler> ] <right paren>

<edge kind> ::=

DIRECTED

| UNDIRECTED

<endpoint definition> ::=

CONNECTING <endpoint pair definition>

<endpoint pair definition> ::=

<endpoint pair definition pointing right>

| <endpoint pair definition pointing left>

| <endpoint pair definition undirected>

| <abbreviated edge type pattern>

<endpoint pair definition pointing right> ::=

<left paren> <source node type name> <connector pointing right>

<destination node type name> <right paren>

<endpoint pair definition pointing left> ::=

<left paren> <destination node type name> <left arrow>

<source node type name> <right paren>

<endpoint pair definition undirected> ::=

<left paren> <source node type name> <connector undirected>

<destination node type name> <right paren>

<connector pointing right> ::=

TO

| <right arrow>

<connector undirected> ::=

TO

| <tilde>

<source node type name> ::=

<element type name>

<destination node type name> ::=

<element type name>

266

IWD 39075:202y(E)

17.3 <edge type definition>

Syntax Rules

1)

Let ETD be the <edge type definition> .

« WG3:UTC-086R1 »

2)

If ETD is simply contained in a <closed edge reference value type> , then:

a)

ETD shall not contain an <edge type name>.

b)

ETD shall not contain a <source node type name> or a <destination node type name> .

3)

If the <edge type phrase> ETP is simply contained in a <graph type specification body>, then ETD

shall contain both an <edge kind> and an <edge type name> .

4)

If ETD immediately contains an <edge type name> , then let ETN be that <edge type name> ; otherwise, let ETN be the zero-length character string.

5)

If ETD immediately contains an <edge type label set definition>, then let ETLSD be that <edge type

label set definition>; otherwise, let ETLSD be the zero-length character string.

6)

If ETD contains an <edge type property type set definition>, then let ETPTSD be that <edge type

property type set definition>; otherwise, let ETPTSD be the zero-length character string.

7)

If ETD simply contains an <endpoint pair definition> EPD, then

Case:

a)

If DIRECTED is simply contained in ETD, then EPD shall not contain an <endpoint pair definition

undirected> or an <abbreviated edge type pattern undirected> .

b)

If UNDIRECTED is simply contained in ETD, then EPD shall contain an <endpoint pair definition

undirected> or an <abbreviated edge type pattern undirected> .

8)

For each endpoint pair EP comprising two <node type reference>s, there is an implementation-

defined (IV005) endpoint pair, EPPNF( EP), known as the normal form of EP (which may be EP

itself), such that:

a)

If NTR is a <node type reference> , then EPPNF(( NTR, NTR)) = ( NTR, NTR).

b)

If NTR1 and NTR2 are two <node type reference> s, then EPPNF(( NTR1, NTR2)) is either ( NTR2, NTR1) or it is ( NTR1, NTR2).

c)

EPPNF( EPPNF( EP)) = EPPNF( EP).

9)

ETD is transformed in the following steps:

a)

If ETD simply contains an <endpoint pair definition> EPD and EPD does not contain an

<abbreviated edge type pattern> , then:

i)

Let SNTN be the <source node type name> simply contained in EPD.

ii)

Let DNTN be the <destination node type name> simply contained in EPD.

iii)

Case:

1)

If DIRECTED is simply contained in ETD, then EPD is replaced by:

( SNTN ) -> ( DNTN )

2)

If UNDIRECTED is simply contained in ETD, then EPD is replaced by:

( SNTN ) ~ ( DNTN )

267

IWD 39075:202y(E)

17.3 <edge type definition>

NOTE 195 — This rewrites an ETD containing an <endpoint pair definition> that is not an <abbreviated

edge type pattern> into an ETD containing an <endpoint pair definition> that is an <abbreviated edge

type pattern>.

b)

If ETD simply contains an <abbreviated edge type pattern> AETP, then:

i)

Let ASNTR be the <source node type reference> simply contained in AETP.

ii)

Let ADNTR be the <destination node type reference> simply contained in AETP.

iii)

Case:

1)

If AETP does not contain an <abbreviated edge type pattern undirected>, then

ETD is replaced by:

ASNTR -[ ETN ETLSD ETPTSD ]-> ADNTR

2)

If AETP contains an <abbreviated edge type pattern undirected> , then:

« Email from: Jim Melton 2022-12-08 0219 »

A)

Let ( ANSTR2, ADNTR2) be EPPNF(( ASNTR, ADNTR)).

B)

ETD is replaced by:

ANSTR2 ~[ ETN ETLSD ETPTSD ]~ ADNTR2

NOTE 196 — This rewrites an ETD containing an <abbreviated edge type pattern> into

an ETD containing a <full edge type pattern>.

c)

If ETD simply contains a <full edge type pattern pointing left> FETPPL, then:

i)

Let SNTR be the <source node type reference> simply contained in FETPPL.

ii)

Let DNTR be the <destination node type reference> simply contained in FETPPL.

iii)

ETD is replaced by:

SNTR -[ ETN ETLSD ETPTSD ]-> DNTR

NOTE 197 — This rewrites an ETD containing a <full edge type pattern pointing left> into an ETD

containing a <full edge type pattern pointing right> .

d)

If ETD is simply contained in a <graph type specification body> and simply contains an <edge

type name> but does not simply contain an <edge type label set definition>, then: i)

Let ETLSD be ETN.

ii)

The following <edge type filler> is implicit and replaces the existing <edge type filler>,

if any:

: ETN ETPTSD

e)

If ETD is simply contained in a <graph type specification body> and simply contains a <source

node type name> SNTN, then:

i)

GTDB shall simply contain a <node type definition> NTD that simply contains a <node

type name> that immediately contains SNTN.

ii)

If NTD contains a <node type filler> , then let NTF be that <node type filler> ; otherwise, let NTF be the zero-length character string.

iii)

SNTN is replaced by:

NTF

268

IWD 39075:202y(E)

17.3 <edge type definition>

NOTE 198 — This rewrites an ETD containing a <source node type name> into an ETD containing the appropriate <node type filler> .

f)

If ETD is simply contained in a <graph type specification body> and simply contains a <destin-

ation node type name> DNTN, then:

i)

GTDB shall simply contain a <node type definition> NTD that simply contains a <node

type name> that immediately contains DNTN.

ii)

If NTD contains a <node type filler> , then let NTF be that <node type filler> ; otherwise, let NTF be the zero-length character string.

iii)

DNTN is replaced by:

NTF

NOTE 199 — This rewrites an ETD containing a <destination node type name> into an ETD containing the appropriate <node type filler> .

10) If ETD is simply contained in an <edge reference value type>, then ETD identifies the edge type that it defines.

« WG3:UTC-009 P00-USA-169 »

11) If ETD is simply contained in a <graph type specification body> and does not contain an <edge type

name> , then ETN is set to an implementation-dependent (UD002) name different from any other edge type name in the <graph type specification body> .

12) Let ETDAT be the <edge type definition> after the transformations in the previous Syntax Rules.

13) Let SNT be the node type defined by SNTR.

14) Let DNT be the node type defined by DNTR.

15) If ETDAT is simply contained in a <graph type specification body> GTSB, then:

a)

Let NTS be the set of all node types defined by the <node type definition> s simply contained in GTSB.

b)

SNT is not of a node type in NTS, then an exception condition is raised: syntax error or access

rule violation — endpoint node type not defined in graph type definition (42005).

c)

DNT is not of a node type in NTS, then an exception condition is raised: syntax error or access

rule violation — endpoint node type not defined in graph type definition (42005).

16) If ETLSD is not a zero length string, then let ETLS be the label set that is specified by ETLSD. Otherwise, let ETLS be an empty label set.

17) If the cardinality of ETLS is less than the implementation-defined (IL002) edge label set minimum cardinality, then an exception condition is raised: syntax error or access rule violation — number of

edge labels below supported minimum (42006).

18) If the cardinality of ETLS is greater than the implementation-defined (IL005) edge label set maximum cardinality, then an exception condition is raised: syntax error or access rule violation — number of

edge labels exceeds supported maximum (42007).

« WG3:UTC-096R1 »

19) If ETDAT contains an <edge type property type set definition> ETPTSD, then let ETPTS be the property type set that is specified by the <property type set definition> immediately contained in

ETPTSD. Otherwise, let ETPTS be an empty property type set.

269

IWD 39075:202y(E)

17.3 <edge type definition>

20) If the cardinality of ETPTS is greater than the implementation-defined (IL006) edge property set maximum cardinality, then an exception condition is raised: syntax error or access rule violation —

number of edge properties exceeds supported maximum (42008).

21) The preferred name of edge types is implementation-defined (ID090) as either EDGE or RELATION-

SHIP.

General Rules

1)

The edge type defined by ETDAT is described by the edge type descriptor ETDESC containing:

« WG3:UTC-015 »

a)

The name of the associated base type of all edge types (EDGE DATA).

b)

The edge type label set ETLS.

c)

The edge type property type set ETPTS.

d)

Case:

i)

If ETDAT does not simply contain a <full edge type pattern undirected>, then:

1)

An indication that the edge type is directed.

2)

SNT as the source node type of ETDAT.

3)

DNT as the destination node type of ETDAT.

ii)

Otherwise:

1)

An indication that the edge type is undirected.

2)

A set of endpoint node types containing SNT and DNT.

2)

Case:

« WG3:UTC-009 P00-USA-169 »

a)

If ETD is simply contained in a <graph type specification body> , then:

i)

ETDESC is added to the set of edge type descriptors in GTSB.

ii)

ETN is added to the edge type name dictionary in GTSB.

« WG3:UTC-086R1 »

b)

Otherwise, ETDESC is added to the <closed edge reference value type> in which it is contained.

Conformance Rules

1)

Without Feature GA07, “Undirected edge patterns”, conforming GQL language shall not contain an

<edge type definition> that simply contains an <edge kind> that is UNDIRECTED, an <endpoint pair

definition> that is an <endpoint pair definition undirected> , or a <full edge type pattern> that is a

<full edge type pattern undirected> .

2)

Without Feature GA09, “Named edge types in graph types”, conforming GQL Language shall not

contain an <edge type definition> that contains an <edge synonym> and an <edge type phrase> .

270





IWD 39075:202y(E)

17.4 <label set definition>

17.4 <label set definition>

Function

Define a label set.

Format

<label set definition> ::=

LABEL <label name>

| LABELS <label name set>

| <is or colon> <label name set>

<label name set> ::=

<label name> [ <comma> <label name> ]

| <left paren> <label name> [ <comma> <label name> ] <right paren>

Syntax Rules

1)

Let LSD be the set of distinct <label name> s simply contained in <label set definition> .

2)

For each label set definition LSD, there is an implementation-defined (IV006) label set definition, LSDNF( LSD), known as the normal form of LSD (which may be LSD itself), such that:

a)

If LSD1 and LSD2 are two label set definitions with the same label name sets, then LSDNF( LSD1)

= LSDNF( LSD2).

b)

LSDNF( LSDNF( LSD)) = LSDNF( LSD).

General Rules

None.

Conformance Rules

None.

271





IWD 39075:202y(E)

17.5 <property type set definition>

17.5 <property type set definition>

Function

Define a property type set.

Format

<property type set definition> ::=

<left brace> [ <property type definition list> ] <right brace>

<property type definition list> ::=

<property type definition> [ { <comma> <property type definition> }... ]

Syntax Rules

1)

Let PTSD be the set of distinct <property type definition>s simply contained in <property type set

definition>.

2)

For each property type set definition PTSD, there is an implementation-defined (IV007) property

type set definition, PTSDNF( PTSD), known as the normal form of PTSD (which may be PTSD itself), such that:

a)

If PTSD1 and PTSD2 are two property type set definitions that specify the same property type

sets, then PTSDNF( PTSD1) = PTSDNF( PTSD2).

b)

PTSDNF( PTSDNF( PTSD1)) = PTSDNF( PTSD2).

General Rules

None.

Conformance Rules

None.

272





IWD 39075:202y(E)

17.6 <property type definition>

17.6 <property type definition>

Function

Define a property type.

Format

<property type definition> ::=

<property name> [ <typed> ] <property value type>

Syntax Rules

1)

Let PTDL be the <property type definition list> that simply contains <property type definition>.

2)

<property name> shall not be equivalent to the <property name> of any other <property type

definition> simply contained in PTDL.

3)

The <property name> specifies the property name of PT.

4)

The <property value type> specifies the property value type of PT.

General Rules

1)

A data type descriptor is created that describes the property value type of the property type being

defined.

2)

A property type descriptor is created that describes the property type being defined. The property

type descriptor includes the following:

a)

The property name.

b)

The data type descriptor of the property value type.

Conformance Rules

1)

Without Feature GD01, “Nested record types”, conforming GQL language shall not contain a

<property type definition> that simply contains a <record type> .

273





IWD 39075:202y(E)

17.7 <property value type>

17.7 <property value type>

Function

Define a property value type.

Format

<property value type> ::=

<value type>

Syntax Rules

1)

Let PV be the <property value type> .

2)

Let VT be the <value type> immediately contained in PV.

3)

PV specifies the property value type that is specified by VT.

4)

The property value type specified by PV shall be a supported property value type.

General Rules

None.

Conformance Rules

None.

274





IWD 39075:202y(E)

17.8 <binding table type>

17.8 <binding table type>

Function

Define a binding table type.

Format

<binding table type> ::=

[ BINDING ] TABLE <field types specification>

Syntax Rules

1)

The base type of binding table types is named BINDING TABLE DATA.

2)

Every <binding table type> BTT specifies a material binding table type whose record type is the closed material record type whose field types are specified by the <field types specification>

immediately contained in BTT.

3)

For each binding table type BTT, there is an implementation-defined (IV004) binding table type,

BTNF( BTT), known as the normal form of BTT (which may be BTT itself), such that:

a)

If BTT1 and BTT2 are two binding table types whose record types have the same normal form

and whose indications regarding the inclusion of the null value are the same, then BTNF( BTT1)

= BTNF( BTT2).

b)

BTNF( BTNF( BTT)) = BTNF( BTT).

General Rules

« Editorial: P00-USA-312 »

1)

Let BTT be the binding table type specified by <binding table type> .

2)

A record data type descriptor for the record type RT of BTT is created that comprises:

a)

The base type name of all record types (RECORD DATA).

b)

An indication that RT does not include records with additional fields.

c)

A field type descriptor for every <field type> simply contained in <binding table type>,

according to the Syntax Rules and General Rules of Subclause 17.10, “<field type>”, applied

to the <field type> s in the order in which they were specified.

« WG3:UTC-051 »

d)

An indication that RT excludes the null value.

3)

A binding table data type descriptor is created that comprises:

a)

The base type name of all binding table types (BINDING TABLE DATA).

b)

The record data type descriptor RT.

c)

An indication that BTT excludes the null value.

275

IWD 39075:202y(E)

17.8 <binding table type>

Conformance Rules

None.

276





IWD 39075:202y(E)

17.9 <value type>

17.9 <value type>

Function

Specify a value type.

Format

« WG3:W23-029R1 deleted an editor's note »

« WG3:UTC-015 »

<value type> ::=

« WG3:UTC-015 deleted one alternative »

<predefined type>

| <constructed type>

| <dynamic union type>

« WG3:UTC-015 deleted four alternatives »

<typed> ::=

<double colon> | TYPED

<predefined type> ::=

<boolean type>

| <character string type>

| <byte string type>

| <numeric type>

| <temporal type>

| <reference value type>

« WG3:UTC-051 »

<boolean type> ::=

{ BOOL | BOOLEAN } [ <not null> ]

<character string type> ::=

{ STRING | VARCHAR } [ <left paren> <max length> <right paren> ] [ <not null> ]

<byte string type> ::=

BYTES

[ <left paren> [ <min length> <comma> ] <max length> <right paren> ]

[ <not null> ]

| BINARY [ <left paren> <fixed length> <right paren> ] [ <not null> ]

| VARBINARY [ <left paren> <max length> <right paren> ] [ <not null> ]

<min length> ::=

<unsigned integer>

<max length> ::=

<unsigned integer>

<fixed length> ::=

<unsigned integer>

<numeric type> ::=

<exact numeric type>

| <approximate numeric type>

<exact numeric type> ::=

<binary exact numeric type>

| <decimal exact numeric type>

277

IWD 39075:202y(E)

17.9 <value type>

<binary exact numeric type> ::=

<signed binary exact numeric type>

| <unsigned binary exact numeric type>

« WG3:UTC-051 »

<signed binary exact numeric type> ::=

INT8 [ <not null> ]

| INT16 [ <not null> ]

| INT32 [ <not null> ]

| INT64 [ <not null> ]

| INT128 [ <not null> ]

| INT256 [ <not null> ]

| SMALLINT [ <not null> ]

| INT [ <left paren> <precision> <right paren> ] [ <not null> ]

| BIGINT

| [ SIGNED ] <verbose binary exact numeric type> [ <not null> ]

<unsigned binary exact numeric type> ::=

UINT8 [ <not null> ]

| UINT16 [ <not null> ]

| UINT32 [ <not null> ]

| UINT64 [ <not null> ]

| UINT128 [ <not null> ]

| UINT256 [ <not null> ]

| USMALLINT [ <not null> ]

| UINT [ <left paren> <precision> <right paren> ] [ <not null> ]

| UBIGINT [ <not null> ]

| UNSIGNED <verbose binary exact numeric type> [ <not null> ]

<verbose binary exact numeric type> ::=

INTEGER8 [ <not null> ]

| INTEGER16 [ <not null> ]

| INTEGER32 [ <not null> ]

| INTEGER64 [ <not null> ]

| INTEGER128 [ <not null> ]

| INTEGER256 [ <not null> ]

| SMALL INTEGER [ <not null> ]

| INTEGER [ <left paren> <precision> <right paren> ] [ <not null> ]

| BIG INTEGER [ <not null> ]

<decimal exact numeric type> ::=

{ DECIMAL | DEC } [ <left paren> <precision> [ <comma> <scale> ] <right paren>

[ <not null> ] ]

<precision> ::=

<unsigned decimal integer>

<scale> ::=

<unsigned decimal integer>

« WG3:UTC-051 »

<approximate numeric type> ::=

FLOAT16 [ <not null> ]

| FLOAT32 [ <not null> ]

| FLOAT64 [ <not null> ]

| FLOAT128 [ <not null> ]

| FLOAT256 [ <not null> ]

| FLOAT [ <left paren> <precision> [ <comma> <scale> ] <right paren> ] [ <not null> ]

| REAL [ <not null> ]

| DOUBLE [ PRECISION ] [ <not null> ]

« WG3:UTC-117 »

278

IWD 39075:202y(E)

17.9 <value type>

<temporal type> ::=

<temporal instant type>

| <temporal duration type>

<temporal instant type> ::=

<datetime type>

| <localdatetime type>

| <date type>

| <time type>

| <localtime type>

<temporal duration type> ::=

<duration type>

<datetime type> ::=

ZONED DATETIME [ <not null> ]

| TIMESTAMP WITH TIMEZONE [ <not null> ]

<localdatetime type> ::=

LOCAL DATETIME [ <not null> ]

| TIMESTAMP [ WITHOUT TIMEZONE ] [ <not null> ]

<date type> ::=

DATE [ <not null> ]

<time type> ::=

ZONED TIME [ <not null> ]

| TIME WITH TIMEZONE [ <not null> ]

<localtime type> ::=

LOCAL TIME [ <not null> ]

| TIME WITHOUT TIMEZONE [ <not null> ]

<duration type> ::=

DURATION [ <not null> ]

<reference value type> ::=

<graph reference value type>

| <binding table reference value type>

| <node reference value type>

| <edge reference value type>

« WG3:UTC-086R1 »

<graph reference value type> ::=

<open graph reference value type>

| <closed graph reference value type>

« WG3:UTC-051 »

<closed graph reference value type> ::=

<graph type specification> [ <not null> ]

<open graph reference value type> ::=

OPEN [ PROPERTY ] GRAPH [ <not null> ]

<binding table reference value type> ::=

<binding table type> [ <not null> ]

« WG3:UTC-086R1 »

<node reference value type> ::=

<open node reference value type>

| <closed node reference value type>

« WG3:UTC-051 »

279

IWD 39075:202y(E)

17.9 <value type>

<closed node reference value type> ::=

<node type definition> [ <not null> ]

<open node reference value type> ::=

[ OPEN ] <node synonym> [ <not null> ]

« WG3:UTC-086R1 »

<edge reference value type> ::=

<open edge reference value type>

| <closed edge reference value type>

« WG3:UTC-086R1 »

<closed edge reference value type> ::=

<edge type definition> [ <not null> ]

« WG3:UTC-015 »

<open edge reference value type> ::=

[ OPEN ] <edge synonym> [ <not null> ]

<constructed type> ::=

<list value type>

| <record type>

« Editorial: Correct grammar mistake »

« WG3:UTC-051 »

<list value type> ::=

{

<list value type name> <left angle bracket> <value type> <right angle bracket>

| <value type> <list value type name>

} [ <left bracket> <max length> <right bracket> ] [ <not null> ]

« WG3:UTC123R2 »

<list value type name> ::=

[ GROUP ] <list value type name synonym>

<list value type name synonym> ::=

LIST | ARRAY

<record type> ::=

[ OPEN ] RECORD [ <not null> ]

| [ RECORD ] <field types specification> [ <not null> ]

<field types specification> ::=

<left brace> [ <field type list> ] <right brace>

<field type list> ::=

<field type> [ { <comma> <field type> }... ]

« WG3:UTC-015 »

<dynamic union type> ::=

<open dynamic union type>

| <dynamic property value type>

| <closed dynamic union type>

<open dynamic union type> ::=

ANY

<dynamic property value type> ::=

[ ANY ] PROPERTY VALUE

<closed dynamic union type> ::=

ANY <left angle bracket> <component type list> <right angle bracket>

280

IWD 39075:202y(E)

17.9 <value type>

| <component type list>

<component type list> ::=

<component type> [ { <vertical bar> <component type> }... ]

<component type> ::=

<value type>

<path value type> ::=

PATH

« WG3:UTC-051 »

<not null> ::=

NOT NULL

« WG3:W24-026R2 deleted an editor's note »

Syntax Rules

1)

Every <value type> specifies the value type that is the data type specified by the immediately contained BNF element.

2)

Every <predefined type> specifies the data type specified by the immediately contained BNF element.

3)

Every <reference value type> specifies the reference value type that is the data type specified by the immediately contained <graph reference value type>, <binding table reference value type>,

<node reference value type>, or <edge reference value type> .

« WG3:UTC-051 »

4)

The nullability specified by a BNF non-terminal NT that is a <value type> is defined as follows.

Case:

NOTE 200 — See Subclause 4.16.4, “Nullability”.

a)

If NT contains <not null> without an intervening instance of <value type> , then NT specifies known not nullable.

b)

Otherwise, NT specifies possibly nullable.

5)

The base type of Boolean types is named BOOLEAN DATA. The preferred name of Boolean types is

implementation-defined (ID021) as either BOOLEAN or BOOL.

« WG3:UTC-051 »

6)

Every <boolean type> BT specifies the Boolean type with the nullability specified by BT.

7)

For each Boolean type BT, there is a Boolean type BNF( BT), known as the normal form of BT (which may be BT itself), such that the nullability of BNF( BT) is the nullability of BT and the declared name of BNF( BT) is the preferred name of Boolean types.

8)

The value of every <max length> shall be greater than or equal to 1 (one).

9)

The base type of character string types is named STRING DATA. The preferred name of character

string types is implementation-defined (ID023) as either VARCHAR or STRING.

« WG3:UTC-051 »

10) Every <character string type> CST specifies the character string type the nullability specified by CST.

11) If the <max length> CSMAXL is specified in a <character string type> CST, then the maximum length of the character string type specified by CST is the value of CSMAXL; otherwise, the maximum length

281

IWD 39075:202y(E)

17.9 <value type>

of the character string type specified by CST is implementation-defined (IL013) but shall be greater than or equal to 214−1 = 16383 characters.

« WG3:UTC-051 »

12) For each character string type CST, there is a character string type CSNF( CST), known as the normal form of CST (which may be CST itself), such that CSNF( CST) and CST have the same maximum length and the nullability of CSNF( CST) is the nullability of CST and the declared name of CSNF( CST) is the preferred name of character string types.

13) Every character string type with maximum length CSMAXL only includes character strings with a

length that is less than or equal to CSMAXL.

« WG3:UTC-90R1 deleted one SR »

14) The value of every <min length> shall be greater than or equal to 0 (zero).

15) If <min length> is omitted, then a <min length> of 0 (zero) is implicit.

16) The value of every <fixed length> shall be greater than or equal to 1 (one).

17) If <fixed length> is omitted, then a <fixed length> of 1 (one) is implicit.

18) The base type of byte string types is named BINARY DATA. The preferred name of fixed-length byte

string types is implementation-defined (ID024) as either BINARY or BYTES. The preferred name

of variable-length byte string types is implementation-defined (ID027) as either VARBINARY or

BYTES.

« WG3:UTC-051 »

19) Every <byte string type> BST specifies the byte string type with the nullability specified by BST.

20) If both the <min length> MINL and the <max length> MAXL are specified in a <byte string type> , then MINL shall be less than or equal to MAXL.

21) If the <min length> BSMINL is specified in a <byte string type> BST, then the minimum length of the byte string type specified by BST is the value of BSMINL.

22) If the <max length> BSMAXL is specified in a <byte string type> BST, then the maximum length of the byte string type specified by BST is the value of BSMAXL.

23) If the <fixed length> BSFIXL is specified in a <byte string type> BST, then the minimum length of the byte string type specified by BST is the value of BSFIXL and the maximum length of the byte

string type specified by BST is the value of BSFIXL.

24) If neither the <max length> nor the <fixed length> are specified in a <byte string type> BST, then the maximum length of the byte string type specified by BST is implementation-defined (IL014)

but shall be greater than or equal to 216-2 = 65534 bytes.

« WG3:UTC-051 »

25) For each byte string type BST, there is a byte string type BSNF( BST), known as the normal form of BST (which may be BST itself), such that BSNF( BST) and BST have the same minimum length and the same maximum length and the nullability of BSNF( BST) is the nullability of BST and

Case:

a)

If BST is a fixed-length byte string type, then the declared name of BSNF( BST) is the preferred

name of fixed-length byte string types.

b)

If BST is a variable-length byte string type, then the declared name of BSNF( BST) is the pre-

ferred name of variable-length byte string types.

282

IWD 39075:202y(E)

17.9 <value type>

26) Every byte string type with minimum length BSMINL only includes byte strings with a length that

is greater than or equal to BSMINL.

27) Every byte string type with maximum length BSMAXL only includes byte strings with a length that

is less than or equal to BSMAXL.

28) The minimum length of every byte string type BST shall be less than or equal to the maximum length

of BST.

« WG3:UTC-90R1 deleted one SR »

29) The value of every <precision> shall be greater than or equal to 1 (one).

« WG3:UTC-015 »

30) The base type of exact numeric types is named EXACT NUMERIC DATA.

31) The base type of approximate numeric types is named FLOAT NUMERIC DATA.

32) Every <numeric type> specifies the numeric type specified by the immediately contained <exact

numeric type> or the immediately contained <approximate numeric type> .

33) For each exact numeric type ENT, there is an implementation-defined exact numeric type, ENNF( ENT),

known as the normal form of ENT (which may be ENT itself), such that:

a)

If ENT1 and ENT2 are exact numeric types whose declared names individually are either

SIGNED INTEGER, INTEGER, or INT, then ENNF( ENT1) is the same as ENNF( ENT2).

b)

If ENT1 and ENT2 are exact numeric types whose declared names individually are either

SIGNED SMALL INTEGER, SMALL INTEGER, or SMALLINT, then ENNF( ENT1) is the same as

ENNF( ENT2).

c)

If ENT1 and ENT2 are exact numeric types whose declared names individually are either

SIGNED BIG INTEGER, BIG INTEGER, or BIGINT, then ENNF( ENT1) is the same as ENNF( ENT2).

d)

For each p from the set {16, 32, 64, 128, 256}: if ENT1 and ENT2 are exact numeric types

whose declared names individually are either SIGNED INTEGER p, INTEGER p, or INT p, then

ENNF( ENT1) is the same as ENNF( ENT2).

e)

If ENT1 and ENT2 are exact numeric types whose declared names individually are either

UNSIGNED INTEGER or UINT, then ENNF( ENT1) is the same as ENNF( ENT2).

f)

If ENT1 and ENT2 are exact numeric types whose declared names individually are either

UNSIGNED SMALL INTEGER, or USMALLINT, then ENNF( ENT1) is the same as ENNF( ENT2).

g)

If ENT1 and ENT2 are exact numeric types whose declared names individually are either

UNSIGNED BIG INTEGER, or UBIGINT, then ENNF( ENT1) is the same as ENNF( ENT2).

h)

For each p from the set {16, 32, 64, 128, 256}: if ENT1 and ENT2 are exact numeric types

whose declared names individually are either UNSIGNED INTEGER p or UINT p, then

ENNF( ENT1) is the same as ENNF( ENT2).

i)

If ENT1 and ENT2 are exact numeric types whose declared names individually are either DEC

or DECIMAL, then ENNF( ENT1) is the same as ENNF( ENT2).

j)

The precision, scale, and radix of ENNF( ENT) are the same as the precision, scale, and radix,

respectively, of ENT.

NOTE 201 — The precision, scale, and radix are determined when an exact numeric type is specified prior to

the construction of its descriptor.

« WG3:UTC-051 »

k)

The nullability of ENNF( ENT) is the nullability of ENT.

283

IWD 39075:202y(E)

17.9 <value type>

l)

ENNF( ENNF( ENT)) is the same as ENNF( ENT).

34) For the <exact numeric type>s:

a)

The maximum value of a <precision> is implementation-defined (IL016). <precision> shall not be greater than this value.

b)

The maximum value of a <scale> is implementation-defined (IL017). <scale> shall not be greater than this maximum value.

35) Every <exact numeric type> specifies the exact numeric type specified by the immediately contained

<binary exact numeric type> or the immediately contained <decimal exact numeric type> .

36) Every<binary exact numeric type> specifies the binary exact numeric type specified by the immediately contained <signed binary exact numeric type> or the immediately contained <unsigned binary

exact numeric type>.

37) Every <signed binary exact numeric type> BESNT specifies a signed binary exact numeric type.

Case:

« WG3:UTC-051 »

a)

If BESNT starts with SIGNED INTEGER8, INTEGER8, or INT8, then BESNT specifies the signed

8-bit integer type with precision of 7 and with scale 0 (zero) and with the nullability specified

by BESNT.

b)

If BESNT starts with SIGNED INTEGER16, INTEGER16, or INT16, then BESNT specifies the

signed 16-bit integer type with precision of 15 and with scale 0 (zero) and with the nullability

specified by BESNT.

c)

If BESNT starts with SIGNED INTEGER32, INTEGER32, or INT32, then BESNT specifies the

signed 32-bit integer type with precision of 31 and with scale 0 (zero) and with the nullability

specified by BESNT.

d)

If BESNT starts with SIGNED INTEGER64, INTEGER64, or INT64, then BESNT specifies the

signed 64-bit integer type with precision of 63 and with scale 0 (zero) and with the nullability

specified by BESNT.

e)

If BESNT starts with SIGNED INTEGER128, INTEGER128, or INT128, then BESNT specifies

the signed 128-bit integer type with precision of 127 and with scale 0 (zero) and with the

nullability specified by BESNT.

f)

If BESNT starts with SIGNED INTEGER256, INTEGER256, or INT256, then BESNT specifies

the signed 256-bit integer type with precision of 255 and with scale 0 (zero) and with the

nullability specified by BESNT.

g)

If BESNT starts with SIGNED INTEGER, INTEGER, or INT, then BESNT specifies the signed

regular integer type with implementation-defined (ID028) precision greater than or equal to

31 and with scale 0 (zero) and with the nullability specified by BESNT.

h)

If BESNT starts with SIGNED SMALL INTEGER, SMALL INTEGER, or SMALLINT, then BESNT

specifies the signed small integer type with implementation-defined (ID029) precision less

than or equal to the precision of the signed regular integer type and with scale 0 (zero) and

with the nullability specified by BESNT.

i)

If BESNT starts with SIGNED BIG INTEGER, BIG INTEGER, or BIGINT, then BESNT specifies

the signed big integer type with implementation-defined (ID030) precision greater than or

equal to the precision of the signed regular integer type and with scale 0 (zero) and with the

nullability specified by BESNT.

284

IWD 39075:202y(E)

17.9 <value type>

j)

Otherwise, BESNT specifies the signed user-specified integer type with implementation-defined

(ID031) precision greater than or equal to the value of the <precision> that is immediately contained in BESNT as its binary precision in bits and with scale 0 (zero) and with the nullability specified by BESNT.

38) Every <unsigned binary exact numeric type> BEUNT specifies an unsigned binary exact numeric type.

Case:

a)

If BEUNT start with UNSIGNED INTEGER8 or UINT8, then BEUNT specifies the unsigned 8-bit

integer type with precision of 7 and with scale 0 (zero) and with the nullability specified by

BEUNT.

b)

If BEUNT start with UNSIGNED INTEGER16 or UINT16, then BEUNT specifies the unsigned

16-bit integer type with precision of 15 and with scale 0 (zero) and with the nullability specified

by BEUNT.

c)

If BEUNT start with UNSIGNED INTEGER32 or UINT32, then BEUNT specifies the unsigned

32-bit integer type with precision of 31 and with scale 0 (zero) and with the nullability specified

by BEUNT.

d)

If BEUNT start with UNSIGNED INTEGER64 or UINT64, then BEUNT specifies the unsigned

64-bit integer type with precision of 63 and with scale 0 (zero) and with the nullability specified

by BEUNT.

e)

If BEUNT start with UNSIGNED INTEGER128 or UINT128, then BEUNT specifies the unsigned

128-bit integer type with precision of 127 and with scale 0 (zero) and with the nullability

specified by BEUNT.

f)

If BEUNT start with UNSIGNED INTEGER256 or UINT256, then BEUNT specifies the unsigned

256-bit integer type with precision of 255 and with scale 0 (zero) and with the nullability

specified by BEUNT.

g)

If BEUNT start with UNSIGNED INTEGER or UINT, then BEUNT specifies the unsigned regular

integer type with the same precision as the regular signed integer type SIGNED INTEGER and

with scale 0 (zero) and with the nullability specified by BEUNT.

h)

If BESNT start with UNSIGNED SMALL INTEGER or USMALLINT, then BESNT specifies the

unsigned small integer type with the same precision as the signed small integer type SIGNED

SMALL INTEGER and with scale zero (0) and with the nullability specified by BEUNT.

i)

If BESNT start with UNSIGNED BIG INTEGER or UBIGINT, then BESNT specifies the unsigned

big integer type with the same precision as the signed big integer type SIGNED BIG INTEGER

and with scale zero (0) and with the nullability specified by BEUNT.

j)

Otherwise, BEUNT specifies the unsigned user-specified integer type with implementation-

defined (ID033) precision greater than or equal to the value of the <precision> that is immediately contained in BEUNT as its binary precision in bits and with scale 0 (zero) and with the

nullability specified by BEUNT.

39) The value of every <scale> shall be greater than or equal to 0 (zero).

40) If an <exact numeric type> ENT contains the <scale> SCALE, then the value of SCALE shall not be greater than the value of the <precision> contained in ENT.

41) Every <decimal exact numeric type> DENT specifies an exact numeric type with decimal precision.

Case:

« WG3:UTC-051 »

285

IWD 39075:202y(E)

17.9 <value type>

a)

If DENT immediately contains DECIMAL or DEC and the <precision> PREC and the <scale>

SCALE, then DENT specifies the user-specified decimal exact numeric type with implementation-

defined (ID036) decimal precision in digits greater than or equal to the decimal precision in

digits specified by PREC and with implementation-defined (ID080) decimal scale in digits

specified by SCALE and with the nullability specified by DENT.

b)

If DENT immediately contains DECIMAL or DEC and the <precision> PREC but no <scale>,

then DENT specifies the user-specified decimal exact numeric type with implementation-

defined (ID035) decimal precision in digits greater than or equal to the decimal precision in

digits specified by PREC and with scale 0 (zero) and with the nullability specified by DENT

and with the nullability specified by DENT.

c)

Otherwise, DENT specifies the regular decimal exact numeric type with implementation-defined

(ID034) decimal precision and with scale 0 (zero) and with the nullability specified by DENT.

42) The value of every <precision> contained in an <approximate numeric type> shall be equal to or greater than 2.

NOTE 202 — This accounts for the possible inclusion of a leading bit in the precision describing the size of the

mantissa of an approximate numeric value that is implied by but not included in the underlying physical represent-

ation.

43) For each approximate numeric type ANT, there is an implementation-defined approximate numeric

type ANNF( ANT), known as the normal form of ANT (which may be ANT itself), such that: a)

The precision and scale of ANNF( ANT) are the same as the precision and scale, respectively,

of ANT.

NOTE 203 — The precision and scale are determined when an exact numeric type is specified prior to the

construction of its descriptor.

« WG3:UTC-051 »

b)

The nullability of ANNF( ANT) is the nullability of ANT.

c)

If ANT1 and ANT2 are exact numeric types whose declared names individually are either

DOUBLE or DOUBLE PRECISION, then ANNF( ANT1) is the same as ANNF( ANT2).

d)

ANNF( ANNF( ANT)) is the same as ANNF( ANT).

44) For the <approximate numeric type> s:

a)

The maximum value of a <precision> is implementation-defined (IL011). <precision> shall not be greater than this value.

b)

The maximum value of a <scale> is implementation-defined (IL012). <scale> shall not be greater than this maximum value.

45) Every <approximate numeric type> ANT specifies an approximate numeric type:

Case:

« WG3:UTC-051 »

a)

If ANT starts with FLOAT16, then ANT specifies the 16-bit approximate numeric type with

precision 10 and with scale 5 and with the nullability specified by ANT.

b)

If ANT starts with FLOAT32, then ANT specifies the 32-bit approximate numeric type with

precision of 23 and with scale 8 and with the nullability specified by ANT.

c)

If ANT starts with FLOAT64, then ANT specifies the 64-bit approximate numeric type with

precision of 52 and with scale 11 and with the nullability specified by ANT.

286

IWD 39075:202y(E)

17.9 <value type>

d)

If ANT starts with FLOAT128, then ANT specifies the 128-bit approximate numeric type with

precision of 112 and with scale 15 and with the nullability specified by ANT.

e)

If ANT starts with FLOAT256, then ANT specifies the 256-bit approximate numeric type with

precision of 236 and with scale 19 and with the nullability specified by ANT.

f)

If ANT starts with FLOAT, then ANT specifies the regular approximate numeric type with

implementation-defined (ID037) precision greater than or equal to 23 and with implemen-

tation-defined (ID038) scale greater than or equal to 8 and with the nullability specified by

ANT.

g)

If ANT starts with REAL, then ANT specifies the real approximate numeric type with an

implementation-defined (ID039) precision less than or equal to the precision of the regular

approximate numeric type and with implementation-defined (ID040) scale and with the nul-

lability specified by ANT.

h)

If ANT starts with DOUBLE or DOUBLE PRECISION, then ANT specifies the double approximate

numeric type with implementation-defined (ID041) precision greater than or equal to the

precision of the regular approximate numeric type and with implementation-defined (ID042)

scale and with the nullability specified by ANT.

i)

Otherwise, ANT specifies a user-specified approximate numeric type:

Case:

i)

If ANT immediately contains the <precision> PREC but no scale, then ANT specifies the user-specified approximate numeric type with implementation-defined (ID043) precision

greater than or equal to PREC and with implementation-defined (ID044) scale and with

the nullability specified by ANT.

ii)

Otherwise, ANT immediately contains the <precision> PREC and the <scale> SCALE, then ANT specifies the user-specified approximate numeric type with implementation-

defined (ID045) precision greater than or equal to PREC and with implementation-

defined (ID046) scale greater than or equal to SCALE and with the nullability specified

by ANT.

46) The preferred name of every numeric type is the declared name of its normal form.

47) If a <numeric type> NT contains the <precision> PREC, then PREC is the explicitly specified precision of the numeric type specified by NT.

48) If a <numeric type> NT contains the <scale> SCALE, then SCALE is the explicitly specified scale of the numeric type specified by NT.

« WG3:UTC-117 Deleted 1 (one) editor's note »

« WG3:UTC-051 »

49) Every <temporal type> specifies the temporal type specified by the immediately contained <datetime

type> , <localdatetime type>, <date type> , <time type> , <localtime type> , or <duration type> .

« WG3:UTC-117 »

50) Every <datetime type> DTT specifies the zoned datetime type with the nullability specified by DTT.

51) Every <localdatetime type> LDT specifies the local datetime type with the nullability specified by LDT.

52) Every <date type> DT specifies the date type with the nullability specified by DT.

53) Every <time type> TT specifies the zoned time type with the nullability specified by TT.

54) Every <localtime type> LT specifies the local time type with the nullability specified by LT.

287

IWD 39075:202y(E)

17.9 <value type>

« Editorial: WG3:UTC-117 omitted to define »

55) For each temporal instant type TINT, there is an implementation-defined (IV015) temporal instant type, TINTNF( TINT), known as the normal form of TINT (which may be TINT itself), such that:

a)

If TINT1 and TINT2 are two temporal instant types whose indications regarding whether their

values capture the date, indications regarding whether their values capture the time of day,

indications regarding whether their values include a time zone displacement, and indications

regarding the inclusion of the null value are all the same, then TINTF( TINT1) = TINTF( TINT2).

b)

TINTF( TINTNF( TINT)) = TINTF( TINT).

56) Every <duration type> DUT specifies the duration type with the nullability specified by DUT.

57) The base type of graph reference value types is named GRAPH REFERENCE. The preferred name

of graph reference value types is implementation-defined (ID087) as either GRAPH or PROPERTY

GRAPH.

« WG3:UTC-086R1 »

58) Every <graph reference value type> specifies the graph reference value type specified by its

immediately contained <open graph reference value type> or its immediately contained <closed

graph reference value type> .

« WG3:UTC-051 »

59) Every <open graph reference value type> OGRVT specifies the open graph reference value type with the nullability specified by OGRVT.

« WG3:UTC-086R1 »

60) Every <closed graph reference value type> CGRVT specifies the closed graph reference value type whose constraining object type is the graph type identified by its immediately contained <graph

type specification> and whose nullability is the nullability specified by CGRVT.

61) The base type of binding table reference value types is named TABLE REFERENCE. The preferred

name of binding table reference value types is implementation-defined (ID088) as either TABLE

or BINDING TABLE.

« WG3:UTC-086R1 »

« WG3:UTC-051 »

62) Every <binding table reference value type> BTRVT specifies the binding table reference value type whose constraining object type is the binding table type identified by its immediately contained

<binding table type> and whose nullability is the nullability specified by BTRVT.

63) The base type of node reference value types is named NODE REFERENCE. The preferred name of

node reference value types is implementation-defined (ID089) as either NODE or VERTEX.

« WG3:UTC-086R1 »

64) Every <node reference value type> specifies the node reference value type specified by its immediately contained <open node reference value type> or <closed node reference value type> .

« WG3:UTC-051 »

65) Every <open node reference value type> ONRVT specifies the open node reference value type with the nullability specified by ONRVT.

« WG3:UTC-086R1 »

66) Every <closed node reference value type> CNRVT specifies the closed node reference value type whose constraining object type is the node type identified by its immediately contained <node type

definition> and whose nullability is the nullability specified by CNRVT.

288

IWD 39075:202y(E)

17.9 <value type>

67) The base type of edge reference value types is named EDGE REFERENCE. The preferred name of

edge reference value types is implementation-defined (ID090) as either EDGE or RELATIONSHIP.

« WG3:UTC-086R1 »

68) Every <edge reference value type> specifies the edge reference value type specified by its immediately contained <open edge reference value type> or <closed edge reference value type>.

« WG3:UTC-051 »

69) Every <open edge reference value type> OERVT specifies the open edge reference value type with the nullability specified by OERVT.

« WG3:UTC-086R1 »

70) Every <closed edge reference value type> CERVT specifies the closed edge reference value type whose constraining object type is the edge type identified by its immediately contained <edge type

definition> and whose nullability is the nullability specified by CERVT.

71) The associated base type of path value types is named PATH DATA.

« WG3:UTC-051 »

72) Every <path value type> PVT specifies the path value type with the nullability specified by PVT.

73) The base type of list value types is named LIST DATA.

« WG3:UTC-123R2 »

74) Prior to the application of Syntax Rules, conforming GQL language shall not specify a <list value

type name> that specifies GROUP.

NOTE 204 — GROUP is not syntax available to the user, it is a specification device to indicate the group characteristic

of a list value type in the syntactic representation of the type.

75) If GROUP is specified in the <list value type name> simply contained in <list value type> LVT, then the <value type> simply contained in LVT shall specify either a node reference value type or an edge reference value type.

76) Every <list value type> LVT specifies the list value type determined as follows: a)

Let LET be the value type specified by <value type> simply contained in LVT.

b)

LVT specifies a closed list value type whose list element type is LET.

« WG3:UTC-123R2 »

c)

The group characteristics of LVT is defined as follows.

Case:

i)

If GROUP is specified in the <list value type name> simply contained in LVT, then the

list value type specified by LVT is a group list value type.

ii)

Otherwise, the list value type specified by LVT is a regular list value type.

d)

Case:

i)

If the <max length> LTMAXL is specified in LVT, then the maximum cardinality of the

list value type specified by LVT is the value of LTMAX L. The value of LTMAXL shall be

less or equal than implementation-defined (IL021) maximum cardinality for list value

types whose list element type is LET.

ii)

Otherwise, the maximum cardinality of the list value type specified by LVT is the

implementation-defined (IL021) maximum cardinality for list value types whose list

element type is LET.

« WG3:UTC-051 »

289

IWD 39075:202y(E)

17.9 <value type>

e)

he nullability of the list value type specified by LVT is the nullability specified by LVT.

77) For each list value type LVT, there is an implementation-defined (IV009) list value type, LNF( LVT), known as the normal form of LVT (which may be LVT itself), such that:

« WG3:UTC-123R2 »

a)

If LVT1 and LVT2 are two list value types whose list element type have the same normal form,

whose group characteristics are the same, whose maximum cardinalities are the same, and

whose indications regarding the inclusion of the null value are the same, then LNF( LVT1) =

LNF( LVT2).

b)

The group characteristic of LNF( LVT) is the group characteristic of LVT.

« WG3:UTC-051 »

c)

The nullability of LNF( LVT) is the nullability of LVT.

d)

LNF( LNF( LVT)) = LNF( LVT).

« WG3:UTC-015 »

78) The associated base type of all record types is named RECORD DATA.

79) Every <record type> RT specifies the record type determined as follows.

Case:

« WG3:UTC-051 »

a)

If RT simply contains a <field types specification> FTS, then RT specifies a closed record type whose field types are specified by FTS with the nullability specified by RT.

b)

Otherwise, RT specifies the open record type with the nullability specified by RT.

80) For each record type RT, there is an implementation-defined (IV008) record type, RNF( RT), known as the normal form of RT (which may be RT itself), such that:

« Editorial: Correct application »

a)

If RT1 and RT2 are two record types that have the same set of field names FNS, whose field

value types for each field name in FNS have the same normal form, whose indications of

whether the type is closed or open are the same, and whose indications regarding the inclusion

of the null value are the same, then RNF( RT1) = RNF( RT2).

« WG3:UTC-051 »

b)

The nullability of RNF( RT) is the nullability of RT.

c)

RNF( RNF( RT)) = RNF( RT).

81) Every <field types specification> specifies the field types specified by the <field type list> that it immediately contains.

82) Every <field type list> specifies the field types that are specified by the <field type> s that it immediately contains.

83) The maximum number of <field type> s immediately contained in a <field type list> is the implemen-

tation-defined (IL019) maximum number of record fields.

« WG3:UTC-015 »

84) The dynamic base type of all value types is named ANY DATA.

290

IWD 39075:202y(E)

17.9 <value type>

85) Every <dynamic union type> specifies the dynamic union type that is the data type specified by the

<open dynamic union type> or the <closed dynamic union type> that it contains.

86) If the <dynamic property value type> DPT is specified, then DPT is effectively replaced by a dynamic union type that specifies the dynamic property value type.

NOTE 205 — See Subclause 4.3.2, “Properties and supported property value types”, for the definitions of supported property value type and dynamic property value type.

87) Every <open dynamic union type> specifies an open dynamic union type.

88) Every <closed dynamic union type> specifies a closed dynamic union type.

« Editorial: Corrected to use CTL »

89) If the <component type list> CTL is specified, then CTL specifies the set of value types specified by at least one of the <value type> s simply contained in CTL.

« WG3:UTC-051 »

90) If a <component type list> CTL is specified, then either every <value type> simply contained in CTL

shall specify possibly nullable or every <value type> simply contained in CTL shall specify known not nullable.

91) For each dynamic union type DUT, there is an implementation-defined (IV013) value type DVNF( DUT) known as the normal form of DUT (which may be DUT itself), such that:

a)

For each subtype VT of DUT: VT is a subtype of DVNF( DUT).

b)

Every component type of DVNF( DUT) is a static value type.

c)

For each open value type OVT: DVNF( DUT) shall not include a proper closed subtype of OVT.

d)

If the component types of DUT include a nullable value type, then the component types of

DVNF( DUT) include no material value types.

« WG3:UTC-123R2 »

e)

If the component types of DUT include a regular list value type, then the component types of

DVNF( DUT) include no group list value type.

f)

If the component types of DUT contain two value types VT1 and VT2 such that VT1 is a proper supertype of VT2 and DVNF( DUT) excludes VT2, then for every other dynamic union type

ODUT whose component types include both VT1 and VT2 it holds that DVNF( ODUT) also

excludes VT2.

g)

If the component types of DVNF( DUT) are the component types of the dynamic union type

specified by ANY PROPERTY VALUE, then DVNF( DUT) is DVNF(PROPERTY VALUE).

h)

If DVT is a closed dynamic union type, then the order in which the component types are spe-

cified by the <component type list> CTL simply contained in DVNF( DUT) is restricted as follows.

i)

The Syntax Rules of Subclause 22.18, “Static value type set precedence determination” ,

are applied with the set of component types of DUT as NDTSET; let CDTLIST be the

NDTLIST returned from the application of those Syntax Rules.

ii)

The component types specified by the <component type list> CTL simply contained in

DVNF( DUT) shall be specified in the same order as in CDTLIST.

i)

If DUT has exactly one component type CT, then DVNF( DUT) is the <value type> that specifies CT.

j)

DVNF( DVNF( DUT)) is the same as DVNF( DUT).

291

IWD 39075:202y(E)

17.9 <value type>

General Rules

1)

If <boolean type> is specified, then a Boolean data type descriptor is created for the specified Boolean type BT that describes BT and comprises:

« WG3:UTC-015 »

a)

The name of the associated base type of all Boolean types (BOOLEAN DATA).

b)

The preferred name of BT.

« WG3:UTC-051 »

c)

An indication of whether BT includes the null value as determined by the nullability specified

by the <boolean type> .

2)

If <character string type> is specified, then a character string data type descriptor is created for

the specified character string type CST that describes CST and comprises:

« WG3:UTC-015 »

a)

The name of the associated base type of all character string types (STRING DATA).

b)

The preferred name of CST.

c)

An indication that CST includes the null value.

d)

The maximum length in characters of CST.

3)

If <byte string type> is specified, then a byte string data type descriptor is created for the specified byte string type BST that describes BST and comprises:

« WG3:UTC-015 »

a)

The name of the associated base type of all byte string types (BINARY DATA).

b)

The preferred name of BST.

« WG3:UTC-051 »

c)

An indication of whether BST includes the null value as determined by the nullability specified

by the <byte string type>.

d)

The minimum length in bytes of BST.

e)

The maximum length in bytes of BST.

4)

If <exact numeric type> is specified, then a numeric data type descriptor is created for the specified exact numeric type ENT that describes ENT and comprises:

a)

The name of the associated base type of ENT (INTEGER DATA or EXACT NUMERIC DATA).

b)

The preferred name of ENT, which is the declared name of the normal form of ENT.

« WG3:UTC-051 »

c)

An indication of whether ENT includes the null value as determined by the nullability specified

by the <exact numeric type>.

d)

The (implemented) precision of ENT.

e)

If ENT specifies an exact numeric type with decimal precision, then the (implemented) scale

of ENT.

292

IWD 39075:202y(E)

17.9 <value type>

f)

An indication of whether the precision and the scale of ENT are expressed in binary or decimal

terms.

g)

The explicit declared precision of ENT, if specified.

h)

The explicit declared scale of ENT, if specified.

5)

If <approximate numeric type> is specified, then a numeric data type descriptor is created for the

specified approximate numeric type ANT that describes ANT and comprises:

a)

The name of the associated base type of ANT (FLOAT NUMERIC DATA).

b)

The preferred name of ANT, which is the declared name of the normal form of ANT.

« WG3:UTC-051 »

c)

An indication of whether ANT includes the null value as determined by the nullability specified

by the <approximate numeric type>.

d)

The (implemented) precision of ANT.

e)

The (implemented) scale of ANT.

f)

An indication that the precision and the scale are expressed in binary terms.

g)

The explicit declared precision of ANT, if specified.

h)

The explicit declared scale of ANT, if specified.

« WG3:UTC-117 »

6)

If <temporal instant type> is specified, then a temporal instant data type descriptor is created for

the specified temporal instant type TINT that describes TINT and comprises:

a)

The name of the associated base type of all temporal instant types (TEMPORAL INSTANT

DATA).

b)

The preferred name of TINT, which is the declared name of the normal form of TINT.

c)

An indication of whether values of TINT capture the date.

d)

An indication of whether values of TINT capture the time of day.

e)

An indication of whether values of TINT include a time zone displacement.

f)

An indication of whether TINT includes the null value as determined by the nullability specified

by the <temporal instant type> .

7)

If <temporal duration type> is specified, then a temporal duration data type descriptor is created

for the specified temporal duration type TDURT that describes TDURT and comprises:

a)

The name of the associated base type of all temporal duration types (TEMPORAL DURATION

DATA).

b)

An indication of whether TDURT includes the null value as determined by the nullability spe-

cified by the <temporal duration type>.

8)

If <open graph reference value type> is specified, then a graph reference value data type descriptor

is created for the specified open graph reference value type OGRVT that describes OGRVT and

comprises:

a)

The reference base type name of graph reference value types (GRAPH REFERENCE).

b)

The object base type name of graph types (PROPERTY GRAPH DATA).

« WG3:UTC-086R1 »

293

IWD 39075:202y(E)

17.9 <value type>

c)

No constraining object type.

« WG3:UTC-051 »

d)

An indication of whether OGRVT includes the null value as determined by the nullability spe-

cified by the <open graph reference value type> .

« WG3:UTC-086R1 »

9)

If <closed graph reference value type> is specified, then a graph reference value data type descriptor is created for the specified graph reference value type CGRVT that describes CGRVT and comprises:

a)

The reference base type name of graph reference value types (GRAPH REFERENCE).

b)

The object base type name of graph types (PROPERTY GRAPH DATA).

« WG3:UTC-086R1 »

c)

The specified constraining object type.

« WG3:UTC-051 »

d)

An indication of whether CGRVT includes the null value as determined by the nullability spe-

cified by the <closed graph reference value type> .

10) If <binding table reference value type> is specified, then a binding table reference value data type descriptor is created for the specified binding table reference value type BTRVT that describes

BTRVT and comprises:

a)

The reference base type name of binding table reference value types (BINDING TABLE REF-

ERENCE).

b)

The object base type name of binding table types (BINDING TABLE DATA).

« WG3:UTC-086R1 »

c)

The specified constraining object type.

« WG3:UTC-051 »

d)

An indication of whether BTRVT includes the null value as determined by the nullability spe-

cified by the <binding table reference value type> .

11) If <open node reference value type> is specified, then a node reference value data type descriptor is created for the specified open node reference value type ONRVT that describes ONRVT and comprises:

a)

The reference base type name, which is the implementation-defined (ID091) preferred name

of the base type of node reference value types (NODE REFERENCE) or (VERTEX REFERENCE).

b)

The object base type name, which is the implementation-defined (ID092) preferred name of

the base type of node types (NODE DATA) or (VERTEX DATA).

« WG3:UTC-086R1 »

c)

No constraining object type.

« WG3:UTC-051 »

d)

An indication of whether ONRVT includes the null value as determined by the nullability spe-

cified by the <open node reference value type>.

« WG3:UTC-086R1 »

12) If <closed node reference value type> is specified, then a node reference value data type descriptor is created for the specified closed node reference value type CNRVT that describes CNRVT and

comprises:

294

IWD 39075:202y(E)

17.9 <value type>

a)

The reference base type name, which is the implementation-defined (ID091) preferred name

of the base type of node reference value types (NODE REFERENCE) or (VERTEX REFERENCE).

b)

The object base type name, which is the implementation-defined (ID092) preferred name of

the base type of node types (NODE DATA) or (VERTEX DATA).

« WG3:UTC-086R1 »

c)

The specified constraining object type.

d)

n indication of whether CNRVT includes the null value as determined by the nullability specified

by the <closed node reference value type>.

13) If <open edge reference value type> is specified, then an edge reference value data type descriptor is created for the specified open edge reference value type OERVT that describes OERVT and comprises:

a)

The reference base type name, which is the implementation-defined (ID093) preferred name

of the base type of edge reference value types (EDGE REFERENCE) or (RELATIONSHIP REF-

ERENCE).

b)

The object base type name, which is the implementation-defined (ID094) preferred name of

the base type of edge types (EDGE DATA) or (RELATIONSHIP DATA).

« WG3:UTC-086R1 »

c)

No constraining object type.

d)

n indication of whether OERVT includes the null value as determined by the nullability specified

by the <open edge reference value type>.

« WG3:UTC-086R1 »

14) If <closed edge reference value type> is specified, then an edge reference value data type descriptor is created for the specified edge reference value type CERVT that describes CERVT and comprises:

a)

The reference base type name, which is the implementation-defined (ID093) preferred name

of the base type of edge reference value types (EDGE REFERENCE) or (RELATIONSHIP REF-

ERENCE).

b)

The object base type name, which is the implementation-defined (ID094) preferred name of

the base type of edge types (EDGE DATA) or (RELATIONSHIP DATA).

« WG3:UTC-086R1 »

c)

The specified constraining object type.

d)

n indication of whether CERVT includes the null value as determined by the nullability specified

by the <closed edge reference value type> .

« Editorial: Reorder items »

15) If <list value type> is specified, then a list value data type descriptor is created for LVT that describes LVT and comprises:

a)

The base type name of all list value types (LIST DATA).

b)

The preferred name LNF( LVT), which is the declared name of the normal form of the list value

type.

c)

The specified list element type ( LET).

« WG3:UTC-123R2 »

d)

The specified group characteristic of the list value type.

295

IWD 39075:202y(E)

17.9 <value type>

e)

The specified maximum cardinality of the list value type.

« WG3:UTC-051 »

f)

An indication of whether LVT includes the null value as determined by the nullability specified

by the <list value type>.

« WG3:UTC-015 »

16) If the specified list element type of a list value type LVT is an open dynamic union type, then LVT is

open; otherwise, LVT is closed.

17) If <record type> is specified, then let RT be the specified record type.

Case:

a)

If RT is a closed record type, then a record data type descriptor is created for RT that describes

RT and comprises:

i)

The base type name of all record types (RECORD DATA).

ii)

An indication that RT is closed.

iii)

A field type descriptor for every <field type> simply contained in the <record type>,

according to the Syntax Rules and General Rules of Subclause 17.10, “<field type>”,

applied to the <field type>s in the order in which they were specified.

« WG3:UTC-051 »

iv)

An indication of whether RT includes the null value as determined by the nullability

specified by the <record type>.

b)

Otherwise, RT is the open record type and a record data type descriptor is created for RT that

describes RT and comprises:

i)

The base type name of all record types (RECORD DATA).

« Editorial: Correct application »

ii)

An indication that RT is open.

« WG3:UTC-051 »

iii)

An indication of whether RT includes the null value as determined by the nullability

specified by the <record type>.

18) If <path value type> is specified, then let PVT be the specified path value type and a path value data type descriptor is created for PVT that describes PVT and comprises:

« Editorial »

a)

The name of the associated base type of all path value types (PATH DATA).

« WG3:UTC-051 »

b)

An indication of whether PVT includes the null value as determined by the nullability specified

by the <path value type> .

« WG3:UTC-015 »

19) If <dynamic union type> is specified, then let DUT be the specified dynamic union type and a dynamic value data type descriptor is created for DUT that describes DUT and comprises:

a)

The name of the associated base type of all dynamic union types which is the dynamic base

type of all value types (ANY DATA).

b)

An indication whether DUT is open or closed.

296

IWD 39075:202y(E)

17.9 <value type>

c)

The component types of DUT.

20) The set of component types COVTSET of the dynamic union type specified by a <dynamic union

type> DUT is defined as follows.

Case:

a)

If DUT specifies a closed dynamic union type, then COVTSET is the set of all data types specified

by the <component type list> simply contained in DUT.

b)

Otherwise, DUT specifies an open dynamic union type and COVTSET is an implementation-

defined (IV014) set of value types that includes at least one supertype of every static value

type supported by the GQL-implementation.

21) The indication of whether the dynamic union type DUT specified by a <dynamic union type> includes the null value is defined as follows. If one of the component types of DUT is nullable, then the

indication is True; otherwise, it is False.

22) A dynamic union type DUT includes every material value of one of its component types DUT. If DUT

is nullable, then it additionally includes the null value. No other values are included in DUT.

Conformance Rules

« WG3:UTC-065 »

1)

Without Feature GB51, “8 bit signed integers”, conforming GQL language shall not contain a <signed

binary exact numeric type> that contains SIGNED INTEGER8, INTEGER8, or INT8.

2)

Without Feature GB52, “16 bit signed integers”, conforming GQL language shall not contain a <signed

binary exact numeric type> that contains SIGNED INTEGER16, INTEGER16, or INT16.

3)

Without Feature GB53, “32 bit signed integers”, conforming GQL language shall not contain a <signed

binary exact numeric type> that contains SIGNED INTEGER32, INTEGER32, or INT32.

4)

Without Feature GB54, “64 bit signed integers”, conforming GQL language shall not contain a <signed

binary exact numeric type> that contains SIGNED INTEGER64, INTEGER64, or INT64.

5)

Without Feature GB20, “128 bit signed integers”, conforming GQL language shall not contain a

<signed binary exact numeric type> that contains INT128, INTEGER128, or SIGNED INTEGER128.

6)

Without Feature GB21, “256 bit signed integers”, conforming GQL language shall not contain a

<signed binary exact numeric type> that contains INT256, INTEGER256, or SIGNED INTEGER256.

« WG3:UTC-065 »

7)

Without Feature GB55, “8 bit unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains UNSIGNED INTEGER8 or UINT8.

8)

Without Feature GB56, “16 bit unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains UNSIGNED INTEGER16 or UINT16.

9)

Without Feature GB57, “32 bit unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains UNSIGNED INTEGER32 or UINT32.

10) Without Feature GB58, “64 bit unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains UNSIGNED INTEGER64 or UINT64.

11) Without Feature GB59, “Small unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains USMALLINT.

297

IWD 39075:202y(E)

17.9 <value type>

12) Without Feature GB60, “Regular unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains UINT.

13) Without Feature GB61, “Big unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains UBIGINT.

14) Without Feature GB62, “Specified integer precision”, conforming GQL language shall not contain a

<signed binary exact numeric type> that contains a <precision> or a <scale>.

15) Without Feature GB22, “128 bit unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains UINT128, or UNSIGNED INTEGER128.

16) Without Feature GB23, “256 bit unsigned integers”, conforming GQL language shall not contain an

<unsigned binary exact numeric type> that contains UINT256, or UNSIGNED INTEGER256.

17) Without Feature GB63, “16 bit floats”, conforming GQL language shall not contain an <approximate

numeric type> that contains FLOAT16.

18) Without Feature GB64, “32 bit floats”, conforming GQL language shall not contain an <approximate

numeric type> that contains FLOAT32.

19) Without Feature GB65, “64 bit floats”, conforming GQL language shall not contain an <approximate

numeric type> that contains FLOAT64.

20) Without Feature GB24, “128 bit floats”, conforming GQL language shall not contain an <approximate

numeric type> that contains FLOAT128.

21) Without Feature GB25, “256 bit floats”, conforming GQL language shall not contain an <approximate

numeric type> that contains FLOAT256.

22) Without Feature GB66, “Float synonyms”, conforming GQL language shall not contain an <approx-

imate numeric type> that contains REAL or DOUBLE.

23) Without Feature GB67, “Specified float precision”, conforming GQL language shall not contain an

<approximate numeric type> that contains a <precision> or a <scale> .

24) Without Feature GB68, “Decimal numeric”, conforming GQL language shall not contain an <exact

numeric type> that contains DECIMAL or DEC.

25) Without Feature GB26, “Byte string types”, conforming GQL language shall not contain a <byte

string type> .

« WG3:UTC-065 »

26) Without Feature GB69, “Specified byte string maximum length”, conforming GQL language shall

not contain a <byte string type> that contains a <max length> .

27) Without Feature GB70, “Specified byte string minimum length”, conforming GQL language shall not

contain a <byte string type> that contains a <min length> .

28) Without Feature GB71, “Specified byte string fixed length”, conforming GQL language shall not

contain a <byte string type> that contains a <fixed length>.

29) Without Feature GB72, “Specified character string maximum length”, conforming GQL language

shall not contain a <character string type> that contains a <max length> .

« WG3:UTC-117 »

30) Without Feature GC23, “Date and time support”, conforming GQL language shall not contain a

<temporal instant type> .

31) Without Feature GC24, “Durations and temporal arithmetic support”, conforming GQL language

shall not contain a <temporal duration type>.

298

IWD 39075:202y(E)

17.9 <value type>

32) Without Feature GD02, “List value types”, conforming GQL language shall not contain a <list value

type> .

33) Without Feature GD03, “Record types”, conforming GQL language shall not contain a <record type>.

34) Without Feature GD04, “Closed record types”, conforming GQL language shall not contain a <record

type> containing a <field types specification>.

35) Without Feature GD05, “Open record types”, conforming GQL language shall not contain a <record

type> not containing a <field types specification>.

36) Without Feature GD06, “Path value types”, conforming GQL language shall not contain a <path value

type> .

« WG3:UTC-039R1 »

37) Without Feature GD07, “Graph reference value types”, conforming GQL language shall not contain

a <graph reference value type> .

38) Without Feature GD08, “Binding table reference value types”, conforming GQL language shall not

contain a <binding table reference value type> .

« WG3:UTC-015 »

39) Without Feature GD10, “Open dynamic union types”, conforming GQL language shall not contain

an <open dynamic union type> .

40) Without Feature GD11, “Closed dynamic union types”, conforming GQL language shall not contain

a <closed dynamic union type> .

41) Without Feature GD12, “Dynamic property value type”, conforming GQL language shall not contain

a <dynamic property value type>.

« WG3:UTC-051 »

42) Without Feature GD14, “Explicit value type nullability”, conforming GQL language shall not contain

<not null>.

299





IWD 39075:202y(E)

17.10 <field type>

17.10 <field type>

Function

Specify a field type.

Format

<field type> ::=

<field name> [ <typed> ] <value type>

Syntax Rules

1)

Let FTL be the <field type list> that simply contains a <field type> FT.

2)

The <field name> shall not be equivalent to the <field name> of any other <field type> simply contained in FTL.

3)

The <field name> specifies the field name of FT.

4)

The <value type> specifies the field value type of FT.

General Rules

1)

A data type descriptor is created that describes the field value type of the field type being defined.

2)

A field type descriptor is created that describes the field type being defined. The field type descriptor

includes the following:

a)

The field name.

b)

The data type descriptor of the field value type.

Conformance Rules

1)

Without Feature GD01, “Nested record types”, conforming GQL language shall not contain a <field

type> that simply contains a <record type>.

300





IWD 39075:202y(E)

18 Object references

« Editorial: One, past it's sell-by-date, Editor's note deleted »

18.1 <schema reference> and <catalog schema parent and name>

Function

Identify a GQL-schema in the GQL-catalog.

Format

<schema reference> ::=

<absolute catalog schema reference>

| <relative catalog schema reference>

| <reference parameter>

<absolute catalog schema reference> ::=

<solidus> | <absolute directory path> <schema name>

<catalog schema parent and name> ::=

<absolute directory path> <schema name>

<relative catalog schema reference> ::=

<predefined schema reference>

| <relative directory path> <schema name>

<predefined schema reference> ::=

HOME_SCHEMA | CURRENT_SCHEMA | <period>

<absolute directory path> ::=

<solidus> [ <simple directory path> ]

<relative directory path> ::=

<double period>

[ { <solidus> <double period> }... <solidus> [ <simple directory path> ] ]

<simple directory path> ::=

{ <directory name> <solidus> }...

Syntax Rules

1)

If the <schema reference> SR is specified, then the GQL-schema identified by SR is the GQL-schema identified by the immediately contained <absolute catalog schema reference> or <relative catalog

schema reference>.

2)

If the <absolute catalog schema reference> ACSR is specified, then

Case:

a)

If ACSR is a <solidus>, then:

i)

The catalog root shall be a GQL-schema.

301

IWD 39075:202y(E)

18.1 <schema reference> and <catalog schema parent and name>

ii)

The GQL-schema identified by ACSR is the catalog root.

b)

Otherwise:

i)

Let PARENT be the GQL-directory identified by the immediately contained <absolute

directory path>.

ii)

Let SN be the immediately contained <schema name>.

iii)

PARENT shall contain a GQL-schema S with name SN.

iv)

For every GQL-directory or GQL-schema DOS contained in PARENT: if the name by

which DOS is identified in PARENT and SN are visually confusable with each other, then

the following exception condition is raised: syntax error or access rule violation — use

of visually confusable identifiers (42004).

v)

The GQL-schema identified by ACSR is S.

3)

If the <relative catalog schema reference> RCSR is specified, then the GQL-schema identified by RCSR is defined as follows.

Case:

a)

If RCSR is the <predefined schema reference> PSR, then the GQL-schema identified by RCSR

is the GQL-schema identified by PSR.

b)

If RCSR immediately contains the <relative directory path> RDP and the <schema name> SN, then:

i)

Let PARENT be the GQL-directory identified by RDP.

ii)

SN shall identify an existing GQL-schema descriptor in PARENT.

iii)

The schema identified by RCSR is the GQL-schema identified by SN in PARENT.

4)

If the <predefined schema reference> PSR is specified, then the GQL-schema identified by PSR is defined as follows.

Case:

« WG3:UTC-045R1 »

a)

If PSR is HOME_SCHEMA, then:

i)

The current home schema shall be defined.

ii)

PSR identifies the current home schema.

b)

If PSR is CURRENT_SCHEMA or <period> , then PSR identifies the current working schema.

NOTE 206 — If no current working schema is available at PSR, then this rule cannot be satisfied. See

Subclause 4.7.3, “Working objects”.

5)

If the <absolute directory path> ADP is specified, then:

a)

The catalog root shall be a GQL-directory.

b)

The GQL-directory identified by ADP is defined as follows.

Case:

i)

If ADP does not immediately contain the <simple directory path>, then the GQL-directory

identified by ADP is the catalog root.

ii)

Otherwise:

302

IWD 39075:202y(E)

18.1 <schema reference> and <catalog schema parent and name>

1)

Let SDP be the <simple directory path> immediately contained in ADP. The Syntax

Rules of Subclause 22.9, “Resolving a <simple directory path> from a start direct-

ory” , are applied with SDP as SIMPLE DIRECTORY PATH and the catalog root as

START DIRECTORY; let RD be the RESOLVED DIRECTORY returned from the application of those Syntax Rules.

2)

The GQL-directory identified by ADP is RD.

6)

If the <relative directory path> RDP is specified, then:

a)

Let n be the number of all <double period> s that are immediately contained in RDP.

b)

Let PDn+1 be the current working schema.

c)

The GQL-directory PDj, 1 (one) ≤ j ≤ n, is defined as follows:

i)

GQL-directory PDj+1 shall not be the catalog root.

ii)

PDj is the parent directory of the GQL-directory or GQL-schema PDj+1.

d)

The GQL-directory identified by RDP is defined as follows.

Case:

i)

If RDP does not immediately contain the <simple directory path>, then the GQL-directory

identified by RDP is the GQL-directory PD 1.

ii)

Otherwise:

1)

Let SDP be the <simple directory path> immediately contained in RDP. The Syntax

Rules of Subclause 22.9, “Resolving a <simple directory path> from a start direct-

ory” , are applied with RDP as SIMPLE DIRECTORY PATH and PD 1 as START DIR-

ECTORY; let RD be the RESOLVED DIRECTORY returned from the application of those Syntax Rules.

2)

The GQL-directory identified by RDP is RD.

General Rules

None.

Conformance Rules

None.

303





IWD 39075:202y(E)

18.2 <graph reference> and <catalog graph parent and name>

18.2 <graph reference> and <catalog graph parent and name>

Function

Identify a graph in the GQL-catalog.

Format

« WG3:UTC-039R1 »

<graph reference> ::=

<catalog object parent reference> <graph name>

| <delimited graph name>

| <home graph>

| <reference parameter>

<catalog graph parent and name> ::=

[ <catalog object parent reference> ] <graph name>

« WG3:UTC-039R1 Deleted 1 (one) production »

<home graph> ::=

HOME_PROPERTY_GRAPH | HOME_GRAPH

« WG3:UTC-039R1 Deleted 1 (one) production »

Syntax Rules

« WG3:UTC-039R1 »

1)

If <graph reference> GR is specified, then

Case:

a)

If GR is a <home graph> and the current home graph is defined, then PGR identifies the current home graph.

« WG3:UTC-039R1 Deleted 1 (one) SR »

b)

If GR is a <delimited graph name> DGN, then the graph identified by GR is the graph identified by the <catalog graph parent and name> :

./ DGN

c)

Otherwise, GR simply contains a <catalog object parent reference> COPR and a <graph name>

GN and the graph identified by GR is the graph identified by the <catalog graph parent and

name> :

COPR GN

2)

If <catalog graph parent and name> CGPN is specified, then:

a)

If CGPN does not immediately contain a <catalog object parent reference> , then the following

<catalog object parent reference> is implicit:

./

b)

Let PARENT be the GQL-schema or the catalog object identified by the explicit or implicit

<catalog object parent reference> immediately contained in CGPN.

304

IWD 39075:202y(E)

18.2 <graph reference> and <catalog graph parent and name>

c)

Let GN be the <graph name> immediately contained in CGPN.

d)

Case:

i)

If PARENT contains an object O with name GN, then:

1)

O shall be a graph.

2)

For every primary object PO contained in PARENT: if the name by which PO is

identified in PARENT and GN are visually confusable with each other, then the

following exception condition is raised: syntax error or access rule violation —

use of visually confusable identifiers (42004).

3)

The graph identified by CGPN is O.

ii)

Otherwise, CGPN does not identify any object.

« WG3:UTC-039R1 Deleted 1 (one) SR »

General Rules

None.

Conformance Rules

None.

305





IWD 39075:202y(E)

18.3 <graph type reference> and <catalog graph type parent and name>

18.3 <graph type reference> and <catalog graph type parent and name>

Function

Identify a graph type in the GQL-catalog.

Format

<graph type reference> ::=

<catalog graph type parent and name>

| <reference parameter>

<catalog graph type parent and name> ::=

[ <catalog object parent reference> ] <graph type name>

Syntax Rules

1)

If <graph type reference> GTR is specified, then the immediately contained <catalog graph type

parent and name> CGTPN shall identify a graph type GT. The graph type identified by GTR is GT.

2)

If the <catalog graph type parent and name> CGTPN is specified, then:

a)

If CGTPN does not immediately contain a <catalog object parent reference> , then the following

<catalog object parent reference> is implicit:

./

b)

Let PARENT be the GQL-schema or the catalog object identified by the explicit or implicit

<catalog object parent reference> immediately contained in CGTPN.

c)

Let GTN be the <graph type name> immediately contained in CGTPN.

d)

Case:

i)

If PARENT contains an object O with name GTN, then:

1)

O shall be a graph type.

2)

For every primary object PO contained in PARENT: if the name by which PO is

identified in PARENT and GTN are visually confusable with each other, then the

following exception condition is raised: syntax error or access rule violation —

use of visually confusable identifiers (42004).

3)

The graph type identified by CGTPN is O.

ii)

Otherwise, CGTPN does not identify any object.

General Rules

None.

Conformance Rules

None.

306





IWD 39075:202y(E)

18.4 <binding table reference> and <catalog binding table parent and name>

18.4 <binding table reference> and <catalog binding table parent and name>

Function

Identify a binding table in the GQL-catalog.

Format

« WG3:UTC-039R1 »

<binding table reference> ::=

<catalog object parent reference> <binding table name>

| <delimited binding table name>

| <reference parameter>

<catalog binding table parent and name> ::=

[ <catalog object parent reference> ] <binding table name>

Syntax Rules

« WG3:UTC-039R1 Deleted 1 (one) SR »

« WG3:UTC-039R1 »

1)

If the <binding table reference> BTR is specified, then

Case:

a)

If BTR is a <delimited binding table name> DBTN, then the binding table identified by BTR is the binding table identified by the <catalog binding table parent and name>:

./ DBTN

b)

Otherwise, BTR simply contains a <catalog object parent reference> COPR and a <binding

table name> BTN and the binding table identified by BTR is the binding table identified by the

<catalog binding table parent and name>:

COPR BTN

2)

If the <catalog binding table parent and name> CBTPN is specified, then:

a)

If the <catalog binding table parent and name> does not immediately contain a <catalog object

parent reference>, then the following <catalog object parent reference> is implicit:

./

b)

Let PARENT be the GQL-schema or the catalog object identified by the <catalog object parent

reference> immediately contained in CBTPN.

« WG3:UTC-039R1 Deleted 1 (one) GR »

« WG3:UTC-039R1 »

c)

Let BTN be the <binding table name> immediately contained in CBTPN.

d)

Case:

i)

If PARENT contains an object O with name BTN, then:

1)

O shall be a binding table.

307

IWD 39075:202y(E)

18.4 <binding table reference> and <catalog binding table parent and name>

2)

For every primary object PO contained in PARENT: If the name by which PO is

identified in PARENT and BTN are visually confusable with each other, then the

following exception condition is raised: syntax error or access rule violation —

use of visually confusable identifiers (42004).

3)

The binding table identified by CBTPN is O.

ii)

Otherwise, CBTPN does not identify any object.

General Rules

None.

Conformance Rules

None.

308





IWD 39075:202y(E)

18.5 <procedure reference> and <catalog procedure parent and name>

18.5 <procedure reference> and <catalog procedure parent and name>

Function

Identify a procedure in the GQL-catalog.

Format

<procedure reference> ::=

<catalog procedure parent and name>

| <reference parameter>

<catalog procedure parent and name> ::=

[ <catalog object parent reference> ] <procedure name>

Syntax Rules

1)

If the <catalog procedure parent and name> does not immediately contain a <catalog object parent

reference>, then the following <catalog object parent reference> is implicit:

./

2)

If the <procedure reference> PR is specified, then the procedure identified by PR is the procedure identified by the immediately contained <catalog procedure parent and name> .

3)

If the <catalog procedure parent and name> CPPN is specified, then:

a)

Let PARENT be the GQL-schema or the catalog object identified by the <catalog object parent

reference> immediately contained in CPPN.

b)

The procedure identified by CPPN is defined as follows:

i)

Let PN be the <procedure name> immediately contained in CPPN.

ii)

PARENT shall contain a procedure P with name PN.

iii)

For every primary object PO contained in PARENT: if the name by which PO is identified

in PARENT and PN are visually confusable with each other, then the following exception

condition is raised: syntax error or access rule violation — use of visually confusable

identifiers (42004).

iv)

The procedure identified by CPPN is P.

General Rules

None.

Conformance Rules

None.

309





IWD 39075:202y(E)

18.6 <catalog object parent reference>

18.6 <catalog object parent reference>

Function

Identify the parent GQL-schema or parent catalog object in a reference to a catalog object.

Format

<catalog object parent reference> ::=

<schema reference> [ <solidus> ] [ { <object name> <period> }... ]

| { <object name> <period> }...

« WG3:UTC-023 Deleted 1 (one) production »

Syntax Rules

1)

Let COPR be the <catalog object parent reference> .

Case:

« WG3:UTC-009 P00-USA-169 »

a)

If COPR simply contains a <schema reference> that is a <solidus> , then COPR shall not immediately contain a <solidus>.

b)

Otherwise, COPR shall immediately contain a <solidus>.

NOTE 207 — // is not a valid <catalog object parent reference> .

2)

Let the GQL-schema SCHEMA be defined as follows.

Case:

a)

If COPR immediately contains a <schema reference> CSR, then SCHEMA is the GQL-schema identified by CSR.

b)

Otherwise, SCHEMA is the current working schema.

NOTE 208 — If no current working schema is available at CSR, then this rule cannot be satisfied. See

Subclause 4.7.3, “Working objects”.

3)

Let ONSEQ be the sequence of all <object name>s that are immediately contained in COPR and let n be the number of elements of ONSEQ.

4)

Let ONi, 1 (one) ≤ i ≤ n, be the i-th element of ONSEQ.

5)

The GQL-schema or catalog object identified by COPR is defined as follows.

Case:

a)

If n is 0 (zero), then COPR identifies the GQL-schema SCHEMA.

b)

Otherwise,

i)

The GQL-schema SCHEMA shall contain a catalog object with name ON 1.

ii)

Let CO 1 be the catalog object with name ON 1 contained in SCHEMA.

iii)

The catalog object COj, 2 (two) ≤ j ≤ n, is defined as follows:

1)

The catalog object COj-1 shall contain a catalog object with name ONj.

310

IWD 39075:202y(E)

18.6 <catalog object parent reference>

2)

COj is the catalog object with name ONj contained in COj-1.

6)

COPR identifies the catalog object COn.

General Rules

None.

Conformance Rules

None.

311





IWD 39075:202y(E)

18.7 <reference parameter>

18.7 <reference parameter>

Function

Use of a parameter within a catalog reference.

Format

<reference parameter> ::=

<parameter>

Syntax Rules

1)

Let RP be the <reference parameter>.

2)

Let P be the <parameter> immediately contained in RP.

3)

The declared type of P shall be a character string type.

4)

Let ROP be the result of P.

NOTE 209 — The result of P is determined from the GQL-request before regular execution and available during the

evaluation of Syntax Rules.

« WG3:UTC-039R1 »

5)

Let ROP′ be defined as follows.

Case:

a)

If RP is immediately contained in a <schema reference> , then:

i)

One of the following shall hold:

1)

ROP conforms to the Format and Syntax Rules of <absolute catalog schema refer-

ence>.

2)

ROP conforms to the Format and Syntax Rules of <relative catalog schema refer-

ence>.

ii)

ROP′ is ROP.

b)

If RP is immediately contained in a <graph reference> , then:

i)

One of the following shall hold:

1)

ROP conform to the Format and Syntax Rules of <catalog graph parent and name>.

2)

ROP conforms to the Format and Syntax Rules of <home graph> .

ii)

The Syntax Rules of Subclause Subclause 18.2, “<graph reference> and <catalog graph

parent and name>” are applied to ROP; ROP′ is ROP after the application of those Syntax Rules.

c)

If RP is immediately contained in a <graph type reference>, then ROP shall conform to the Format and Syntax Rules of <catalog graph type parent and name> and ROP′ is ROP.

d)

If RP is immediately contained in a <binding table reference>, then:

i)

ROP shall conform to the Format and Syntax Rules of <catalog binding table parent and

name> .

312

IWD 39075:202y(E)

18.7 <reference parameter>

ii)

The Syntax Rules of Subclause Subclause 18.4, “<binding table reference> and <catalog

binding table parent and name>” are applied to ROP; ROP′ is ROP after the application of those Syntax Rules.

e)

If RP is immediately contained in a <procedure reference>, then ROP shall conform to the Format and Syntax Rules of <catalog procedure parent and name> and ROP′ is ROP.

6)

RP is effectively replaced by ROP′.

General Rules

None.

Conformance Rules

None.

313





IWD 39075:202y(E)

18.8 <external object reference>

18.8 <external object reference>

Function

Identify a GQL-object with a URI.

Format

<external object reference> ::=

!! See the Syntax Rules.

Syntax Rules

1)

Let EOR be the <external object reference>.

« WG3:UTC-023 »

2)

EOR shall be a URI with a mandatory scheme as specified by RFC 3986 or alternatively shall be an

absolute-URL-with-fragment character string as specified by WHATWG URL.

« WG3:UTC-023 »

3)

EOR shall contain a <colon> .

NOTE 210 — This condition is true for any URI with a mandatory scheme as specified by RFC 3986 and, when this document was last edited, was true for any absolute-URL-with-fragment character string as specified by WHATWG

URL.

4)

It is implementation-defined (IE001) what EOR identifies.

5)

EOR shall identify a GQL-object.

General Rules

None.

Conformance Rules

1)

Without Feature GB11, “External object references”, conforming GQL language shall not contain an

<external object reference>.

314





IWD 39075:202y(E)

19 Predicates

19.1 <search condition>

Function

Specify a condition that is True, False, or Unknown, depending on the result of a <boolean value expression>.

Format

<search condition> ::=

<boolean value expression>

Syntax Rules

None.

General Rules

1)

The result of the <search condition> is the result of the <boolean value expression>.

2)

A <search condition> is said to be satisfied if and only if the result of the <boolean value expression>

is True.

Conformance Rules

None.

315





IWD 39075:202y(E)

19.2 <predicate>

19.2 <predicate>

Function

Specify a condition that can be evaluated to give a Boolean value.

Format

<predicate> ::=

<comparison predicate>

| <exists predicate>

| <null predicate>

| <normalized predicate>

| <directed predicate>

| <labeled predicate>

| <source/destination predicate>

| <all_different predicate>

| <same predicate>

« WG3:UTC-127R1 »

| <property_exists predicate>

** Editor’s Note (number 45) **

SQL contains other possibly relevant predicates such as:

—

The <in predicate> , which is effectively a syntactic shorthand for a <search condition> involving a <quantified comparison

predicate> The SQL variant allows table subqueries as well as lists, TigerGraph’s variant supports bags, but Cypher does not have the syntax although it does have an equivalent for the quantified comparison predicate and a predicate

function none() that is roughly equivalent to NOT IN.

—

The <quantified comparison predicate> , which can operate on arrays and multisets. TigerGraph has no direct equivalent (but see the IN predicate), Cypher has radically different syntax for the same result, it uses the all() and any() predicate

functions as well as the single() predicate function, which has no direct equivalent in SQL. Discussion is needed on how

to represent this functionality in GQL.

—

The <overlaps predicate>, which is syntactic shorthand for a complex <search condition> involving <comparison pre-

dicate>s and is very tricky to get right.

—

The <member predicate> , which operates on multisets.

—

The <submultiset predicate>, which operates on multisets.

—

The <set predicate>, which operates on multisets.

—

The <type predicate> , which concerns user-defined types. Does this have relevance in the dynamic type context of GQL?

—

The <period predicate>, which concerns periods. But see also the <overlaps predicate>.

Discussion on the inclusion or non-inclusion of the above predicates is required.

See Language Opportunity GQL-177 .

** Editor’s Note (number 46) **

SQL contains other predicates that may not be relevant:

—

The <exists predicate> , which operates on tables, whereas GQL has an equivalent predicate which operates on graphs.

—

The <unique predicate>, which operates on tables.

—

The <match predicate> , which operates on tables.

316

IWD 39075:202y(E)

19.2 <predicate>

« WG3:UTC-082R1 Deleted 1 (one) item »

See Language Opportunity GQL-177 .

** Editor’s Note (number 47) **

TigerGraph contains another predicate that may be relevant:

—

ISEMPTY, which operates on bags.

Discussion is required as to whether the functions named above should be incorporated into GQL.

See Language Opportunity GQL-177 .

Syntax Rules

None.

General Rules

1)

The result of a <predicate> is the result of the immediately contained <comparison predicate> ,

<exists predicate> , <null predicate> <normalized predicate> , <directed predicate> , <labeled predic-

ate>, <source/destination predicate> ,

« WG3:UTC-127R1 »

<all_different predicate> , <same predicate> , or <property_exists predicate> .

Conformance Rules

None.

317





IWD 39075:202y(E)

19.3 <comparison predicate>

19.3 <comparison predicate>

Function

Specify a comparison of two values.

Format

<comparison predicate> ::=

<comparison predicand> <comparison predicate part 2>

<comparison predicate part 2> ::=

<comp op> <comparison predicand>

<comp op> ::=

<equals operator>

| <not equals operator>

| <less than operator>

| <greater than operator>

| <less than or equals operator>

| <greater than or equals operator>

<comparison predicand> ::=

<common value expression>

| <boolean predicand>

Syntax Rules

1)

Let L and R respectively denote the first and second <comparison predicand>s.

2)

Case:

a)

If <comp op> is <equals operator> or <not equals operator>, then L and R are operands of an equality operation. The Syntax Rules and Conformance Rules of Subclause 22.12, “Equality

operations”, apply.

b)

Otherwise, L and R are operands of an ordering operation. The Syntax Rules and Conformance

Rules of Subclause 22.13, “Ordering operations” , apply.

3)

Case:

a)

If the declared types of L and R are list value types with list element types LET and RET,

respectively, then let LV and RV be <value expression> s whose declared types are LET and RET, respectively. The Syntax Rules of this Subclause are applied to:

LV <comp op> RV

b)

If the declared types of L and R are record types with same set of field names FNS, then let n

be the cardinality of FNS, let FNi, 1 (one) ≤ i ≤ n, be the i-th field name in a permutation of FNS, let LFVi denote a <value expression> whose declared type is the field value type of the field type with field name FNi in the declared types of L, and let RFVi denote a <value expression>

whose declared type is the field value type of the field type with field name FNi in the declared

types of R. For i, 1 (one) ≤ i ≤ n, the Syntax Rules of this Subclause are applied to:

LFVi <comp op> RFVi

4)

Let CP be the <comparison predicate> . The following syntactic transformations are applied.

318

IWD 39075:202y(E)

19.3 <comparison predicate>

Case:

a)

If the <comp op> is <not equals operator> , then CP is equivalent to: NOT ( L = R )

b)

If the <comp op> is <greater than operator> , then CP is equivalent to: ( R < L )

c)

If the <comp op> is <less than or equals operator> , then CP is equivalent to: ( L < R

OR

L = R )

d)

If the <comp op> is <greater than or equals operator>, then CP is equivalent to: ( R < L

OR

R = L )

General Rules

1)

Let LV and RV be the results of the <comparison predicand> s L and R, respectively.

« WG3:UTC-082R1 »

2)

If LV and RV are material values and not comparable, then the result of CP is implementation-defined

(IV010) and no further General Rules of this Subclause are applied.

3)

Case:

a)

If at least one of LV and RV is the null value, then the result of CP is Unknown.

b)

Otherwise:

i)

If LV and RV are list values and the cardinalities of LV and RV are NL and NR, then let LEi, 1 (one) ≤ i ≤ NL, denote a <value expression> whose value and declared type is that of the i-th element of LV, and let REi, 1 (one) ≤ i ≤ NR, denote a <value expression>

whose value and declared type is that of the i-th element of RV. The result of CP is

determined as follows:

1)

If <comp op> is <equals operator>, then

Case:

A)

If NL = 0 (zero) and NR = 0 (zero), then CP is True.

B)

If NL = NR and LEi = REi is True for all i, then CP is True.

C)

If NL ≠ NR or NOT ( LEi = REi ) is True for some i, then CP is False.

D)

Otherwise, the result of CP is Unknown.

2)

If <comp op> is <less than operator> , then

Case:

A)

If LEi < REi is Unknown for some i, then CP is Unknown.

B)

Otherwise, the result of CP is implementation-defined (IV002).

319

IWD 39075:202y(E)

19.3 <comparison predicate>

ii)

If LV and RV are records, then:

1)

If LV and RV have the same set of field names FNS, then let n be the cardinality of

FNS, let FNi, 1 (one) ≤ i ≤ n, be the i-th field name in a permutation of FNS, let LFVi denote a <value expression> whose value and declared type is that of the field

with field name FNi of LV, and let RFVi denote a <value expression> whose value and declared type is that of the field with field name FNi of RV. The result of CP

is determined as follows:

A)

If <comp op> is <equals operator>, then

Case:

I)

If LFVi = RFVi is True for all i, then CP is True.

II)

If NOT ( LFVi = RFVi ) is True for some i, then CP is False.

III)

Otherwise, the result of CP is Unknown.

B)

If <comp op> is <less than operator> , then

Case:

I)

If LFVi < RFVi is Unknown for some i, then CP is Unknown.

II)

Otherwise, the result of CP is implementation-defined (IV003).

2)

Otherwise, the result of CP is determined as follows:

A)

If <comp op> is <equals operator>, then CP is False.

B)

If <comp op> is <less than operator> , then CP is implementation-defined

(IV003).

iii)

If LV and RV are paths, then they are compared according to their path element lists.

iv)

Otherwise:

1)

If <comp op> is <equals operator>, then:

A)

If LV and RV are equal, then the result of CP is True.

B)

Otherwise, the result of CP is False.

2)

If <comp op> is <less than operator> , then:

A)

If LV is less than RV, then the result of CP is True.

B)

Otherwise, the result of CP is False.

4)

Numbers are compared with respect to their numeric values.

5)

The comparison of two character strings is defined as follows:

a)

If the length in characters of LV is not equal to the length in characters of RV, then it is imple-

mentation-defined (IA015) if the shorter character string is effectively replaced, for the pur-

poses of comparison, with a copy of itself that has been extended to the length of the longer

character string by concatenation on the right of one or more <space> characters.

b)

The Syntax Rules of Subclause 22.15, “Collation determination” , are applied; let CS be the COLL

returned from the application of those Syntax Rules.

320

IWD 39075:202y(E)

19.3 <comparison predicate>

** Editor’s Note (number 48) **

Consider explicit support for additional collations other than UCS_BASIC and UNICODE (e.g., case insensitive

variants, use of alternative collation tables). See Language Opportunity GQL-012 .

c)

The result of the comparison of LV and RV is given by the collation CS.

6)

The comparison of two byte strings is defined as follows:

a)

Let LENGTH_LV be the length in bytes of LV and let LENGTH_RV be the length in bytes of RV.

Let LVi, 1 (one) ≤ i ≤ LENGTH_LV, be the i-th byte of LV, and let RVi, 1 (one) ≤ i ≤ LENGTH_RV, be the i-th byte of RV.

b)

If LENGTH_LV = LENGTH_RV and LVi = RVi, 1 (one) ≤ i ≤ LENGTH_LV, then LV is equal to RV.

c)

If LENGTH_LV < LENGTH_RV, LVi = RVi for all i ≤ LENGTH_LV, and the right-most LENGTH_RV

− LENGTH_LV bytes of RV are all X'00's, then it is implementation-defined (IA016) whether LV is equal to RV or whether LV is less than RV.

d)

If LENGTH_LV < LENGTH_RV, LVi = RVi for all i ≤ LENGTH_LV, and at least one of the right-most LENGTH_RV − LENGTH_LV bytes of RV is not X'00's, then LV is less than RV.

e)

If LVj < RVj, for some j, 0 (zero) < j ≤ minimum( LENGTH_LV, LENGTH_RV), and LVi = RVi for all i < j, then LV is less than RV.

f)

Otherwise, LV is greater than RV.

« WG3:UTC-117 Deleted 1 (one) GR »

7)

If LV and RV are temporal instants, then let RD be the duration that results from DURA-

TION_BETWEEN( LV, RV) and

Case:

a)

If the <comp op> is <not equals operator> , and RD is not zero, then LC is not equal to RV.

b)

If the <comp op> is <equals operator> , and RD is zero, then LC is equal to RV.

c)

If the <comp op> is <greater than operator> , and RD is positive, then RV is greater than SV.

d)

If the <comp op> is <less than operator>, and RD is negative, then RV is less than SV.

e)

If the <comp op> is <less than or equals operator>, and RD is zero or negative, then RV is less than or equal to SV.

f)

If the <comp op> is <greater than or equals operator> and RD is zero or positive, then LV is greater than or equal to RV.

« WG3:UTC-117 Deleted 1 (one) GR »

« WG3:UTC-117 »

8)

The comparison of two year and month-based durations is determined by the comparison of their

corresponding values after conversion to a duration expressed in months.

9)

The comparison of two day and time based durations is determined by comparison of their corres-

ponding values after conversion to a duration expressed in seconds.

10) In comparisons of Boolean values, True is greater than False

« WG3:UTC-015 »

11) The comparison of two reference values is determined as follows.

321

IWD 39075:202y(E)

19.3 <comparison predicate>

a)

If LV and RV reference the same referent, LV is equal to RV; otherwise, LV is not equal to RV.

b)

Whether LV is less than RV is implementation-dependent (UA003).

12) The comparison of two values of different static base types that are not numbers is determined as

follows.

a)

LV and RV are not equal.

b)

Whether LV is less than RV is implementation-defined (IA024).

Conformance Rules

1)

Without Feature GC02, “Universal comparison”, in conforming GQL language, the two <comparison

predicand> s shall be comparable.

NOTE 211 — If <comp op> is <equals operator> or <not equals operator>, then the Conformance Rules of Subclause 22.12,

“Equality operations”, apply; otherwise, the Conformance Rules of Subclause 22.13, “Ordering operations” , apply.

322





IWD 39075:202y(E)

19.4 <exists predicate>

19.4 <exists predicate>

Function

Specify an existential subquery.

Format

« WG3:UTC-046 »

<exists predicate> ::=

EXISTS {

<left brace> <graph pattern> <right brace>

| <left paren> <graph pattern> <right paren>

| <left brace> <match statement block> <right brace>

| <left paren> <match statement block> <right paren>

| <nested query specification>

}

Syntax Rules

1)

Let EP be the <exists predicate>.

2)

If EP immediately contains the <graph pattern> GP, then:

a)

Let RIA be an implementation-dependent (UV002) identifier.

b)

EP is effectively replaced by:

EXISTS { MATCH GP RETURN TRUE AS RIA }

« WG3:UTC-046 »

3)

If EP immediately contains the <match statement block> MSB, then:

a)

Let RIA2 be an implementation-dependent (UV002) identifier.

b)

EP is effectively replaced by:

EXISTS { MSB RETURN TRUE AS RIA2 }

4)

Let NQS be the <nested query specification> immediately contained in EP.

5)

The declared type of NQS shall be a binding table type.

General Rules

1)

In a new child execution context:

a)

The General Rules of NQS are applied.

b)

If the current execution result is a non-empty table, then the result of EP is True; otherwise,

the result of EP is False.

Conformance Rules

« WG3:UTC-046 »

323

IWD 39075:202y(E)

19.4 <exists predicate>

1)

Without Feature G122, “EXISTS predicate: multiple MATCH statements”, <exists predicate> shall

not directly contain <match statement block>

324





IWD 39075:202y(E)

19.5 <null predicate>

19.5 <null predicate>

Function

Specify a test for a null value.

Format

<null predicate> ::=

<value expression primary> <null predicate part 2>

<null predicate part 2> ::=

IS [ NOT ] NULL

Syntax Rules

None.

General Rules

1)

Let VEP be the <value expression primary>.

2)

Let VEPR be the result of VEP.

3)

Case:

a)

If VEPR is the null value, then “VEP IS NULL” is True and the result of “VEP IS NOT NULL” is

False.

b)

Otherwise, “VEP IS NULL” is False and the result of “VEP IS NOT NULL” is True.

Conformance Rules

None.

« WG3:UTC-015 »

325





IWD 39075:202y(E)

19.6 <value type predicate>

19.6 <value type predicate>

Function

Specify a value type test.

Format

<value type predicate> ::=

<value expression primary> <value type predicate part 2>

<value type predicate part 2> ::=

IS [ NOT ] <typed> <value type>

Syntax Rules

1)

Let VTP be the <value type predicate> .

2)

Let VE be the <value expression primary> simply contained in VTP, let VD be the declared type of VE, and let VT be the <value type> simply contained in VTP.

3)

The declared type of VTP is the Boolean type.

General Rules

1)

Let VALUE be the result of VE and let TYPE be the value type specified by VT.

2)

The result of VTP is determined as follows.

Case:

a)

If VALUE is of TYPE and NOT is not specified, then the result of VTP is True.

b)

If VALUE is not of TYPE and NOT is specified, then the result of VTP is True.

c)

Otherwise, the result of VTP is False.

Conformance Rules

1)

WithoutFeature GD09, “Value type predicate”, conforming GQL language shall not contain <value

type predicate> or <value type predicate part 2> .

326





IWD 39075:202y(E)

19.7 <normalized predicate>

19.7 <normalized predicate>

Function

Determine whether a character string value is normalized.

Format

<normalized predicate> ::=

<string value expression> <normalized predicate part 2>

<normalized predicate part 2> ::=

IS [ NOT ] [ <normal form> ] NORMALIZED

Syntax Rules

1)

Let <string value expression> be SVE.

2)

Case:

a)

If <normal form> is specified, then let NF be <normal form> .

b)

Otherwise, let NF be NFC.

3)

The expression

SVE IS NOT NF NORMALIZED

is equivalent to:

NOT ( SVE IS NF NORMALIZED )

General Rules

1)

The result of SVE IS NF NORMALIZED is

Case:

a)

If the result of SVE is the null value, then Unknown.

b)

If the result of SVE is in the normalization form specified by NF, as defined by Unicode Standard

Annex #15, then True.

c)

Otherwise, False.

Conformance Rules

None.

327





IWD 39075:202y(E)

19.8 <directed predicate>

19.8 <directed predicate>

Function

Determine whether an edge variable is bound to a directed edge.

Format

<directed predicate> ::=

<element variable reference> <directed predicate part 2>

<directed predicate part 2> ::=

IS [ NOT ] DIRECTED

Syntax Rules

« WG3:UTC-0127R1 »

1)

Let DP be the <directed predicate>.

2)

Let EVR be the <element variable reference> simply contained in DP. EVR shall have singleton degree of reference.

3)

The declared type of EVR shall be an edge reference value type.

4)

If NOT is specified, then the <directed predicate> is equivalent to:

NOT ( EVR IS DIRECTED )

General Rules

« WG3:UTC-127R1 Deleted 2 GRs »

« WG3:UTC-127R1 »

1)

Let GE be the result of EVR.

2)

The result of DP is defined as follows.

Case:

a)

If GE is the null value, then the result of DP is Unknown.

b)

If GE is a reference value whose referent is a directed edge, then the result of DP is True.

c)

Otherwise, GE is a reference value whose referent is an undirected edge and the result of DP

is False.

Conformance Rules

« Editorial: Complete CR for part 2 »

1)

Without Feature G110, “IS DIRECTED predicate”, conforming GQL language shall not contain <dir-

ected predicate> or <directed predicate part 2> .

328





IWD 39075:202y(E)

19.9 <labeled predicate>

19.9 <labeled predicate>

Function

Determine whether a graph element satisfies a <label expression>.

Format

<labeled predicate> ::=

<element variable reference> <labeled predicate part 2>

<labeled predicate part 2> ::=

<is labeled or colon> <label expression>

<is labeled or colon> ::=

IS [ NOT ] LABELED

| <colon>

Syntax Rules

« WG3:UTC-127R1 »

1)

Let LP be the <labeled predicate>.

2)

Let EVR be the <element variable reference> simply contained in LP. EVR shall have singleton degree of reference.

3)

Let LE be the <label expression> simply contained in LP.

4)

If NOT is specified, then LP is replaced by:

NOT ( EVR IS LABELED LE )

5)

If LP simply contains an <is labeled or colon> ILOC that is <colon> , then ILOC is replaced by IS

LABELED.

General Rules

« WG3:UTC-127R1 Deleted 2 GRs »

« WG3:UTC-127R1 »

1)

Let GE be the result of EVR.

2)

The result of LP is defined as follows.

Case:

a)

If GE is the null value, then the result of LP is Unknown.

b)

Otherwise, GE is a graph element reference value and:

i)

The Syntax Rules of Subclause 22.5, “Satisfaction of a <label expression> by a label set”,

are applied with LE as LABEL EXPRESSION and the label set of GE as LABEL SET; let TV

be the TRUTH VALUE returned from the application of those Syntax Rules.

ii)

The result of LP is TV.

329

IWD 39075:202y(E)

19.9 <labeled predicate>

Conformance Rules

« Editorial: Complete CR for part 2 »

1)

Without Feature G111, “IS LABELED predicate”, conforming GQL language shall not contain <labeled

predicate> or <labeled predicate part 2>.

330





IWD 39075:202y(E)

19.10 <source/destination predicate>

19.10 <source/destination predicate>

Function

Determine whether a node is the source or destination of an edge.

Format

<source/destination predicate> ::=

<node reference> <source predicate part 2>

| <node reference> <destination predicate part 2>

<node reference> ::=

<element variable reference>

« WG3:UTC-128 »

<source predicate part 2> ::=

IS [ NOT ] SOURCE OF <edge reference>

<destination predicate part 2> ::=

IS [ NOT ] DESTINATION OF <edge reference>

<edge reference> ::=

<element variable reference>

Syntax Rules

« WG3:UTC-127R1 »

1)

Let SDP be the <source/destination predicate> .

« WG3:UTC-127R1 Deleted 2 SRs »

2)

Let NR be the <element variable reference> immediately contained in the <node reference> that is simply contained in SDP. NR shall have singleton degree of reference. The declared type of NR shall

be a node reference value type.

3)

Let ER be the <element variable reference> immediately contained in the <edge reference> that is simply contained in SDP. ER shall have singleton degree of reference. The declared type of ER shall

be an edge reference value type.

4)

Let SOD be the <key word> SOURCE or DESTINATION simply contained in the <source/destination

predicate> .

5)

If NOT is specified, then the <source/destination predicate> is equivalent to:

NOT ( NR IS SOD OF ER )

General Rules

« WG3:UTC-127R1 Deleted 2 SRs »

« WG3:UTC-127R1 »

1)

Let GEN be the result of NR and let GEE be the result of ER.

2)

The result of SDP is defined as follows.

331

IWD 39075:202y(E)

19.10 <source/destination predicate>

Case:

a)

If GEN is the null value or GEE is the null value, then the result of SDP is Unknown.

b)

If the referent of GEE is an undirected edge, then the result of SDP is False.

c)

If SOD is SOURCE and the referent of GEN is the source node of the referent of GEE, then the

result of SDP is True.

d)

If SOD is DESTINATION and the referent of GEN is the destination node of the referent of GEE,

then the result of SDP is True.

e)

Otherwise, the result of SDP is False.

Conformance Rules

« Editorial: Complete CR for part 2 »

1)

Without Feature G112, “IS SOURCE and IS DESTINATION predicate”, conforming GQL language

shall not contain <source/destination predicate> , <source predicate part 2> , or <destination pre-

dicate part 2>.

332





IWD 39075:202y(E)

19.11 <all_different predicate>

19.11 <all_different predicate>

Function

Determine whether all graph elements bound to a list of element references are pairwise different from

one another.

Format

<all_different predicate> ::=

ALL_DIFFERENT <left paren>

<element variable reference> <comma> <element variable reference>

[ { <comma> <element variable reference> }... ]

<right paren>

Syntax Rules

« WG3:UTC-127R1 »

1)

Let ADP be the <all_different predicate> .

2)

The degree of reference of each <element variable reference> simply contained in ADP shall be unconditional singleton.

General Rules

« WG3:UTC-127R1 Deleted 3 GRs »

« WG3:UTC-127R1 »

1)

Let N be the number of <element variable reference>s simply contained in ADP. Let EVR 1, ..., EVRN

be an implementation-dependent (UV013) enumeration of those <element variable reference> s.

2)

The result of ADP is defined as follows.

Case:

a)

If there exists i, 1 (one) ≤ i ≤ N, such that GEi is the null value, then an exception condition is raised: data exception — null value not allowed (22004).

b)

If there exist j and k, 1 (one) ≤ j < k ≤ N, such that GEj and GEk reference the same graph element, then the result of ADP is False.

c)

Otherwise, the result of ADP is True.

Conformance Rules

1)

Without Feature G113, “ALL_DIFFERENT predicate”, conforming GQL language shall not contain

<all_different predicate> .

333





IWD 39075:202y(E)

19.12 <same predicate>

19.12 <same predicate>

Function

Determine whether all element references in a list of element references bind to the same graph element.

Format

<same predicate> ::=

SAME <left paren>

<element variable reference> <comma> <element variable reference>

[ { <comma> <element variable reference> }... ]

<right paren>

Syntax Rules

« WG3:UTC-127R1 »

1)

Let SDP be the <same predicate>.

2)

The degree of reference of each <element variable reference> simply contained in SDP shall be unconditional singleton.

General Rules

« WG3:UTC-127R1 Deleted 3 GRs »

« WG3:UTC-127R1 »

1)

Let N be the number of <element variable reference>s simply contained in SDP. Let EVR 1, ..., EVRN

be an implementation-dependent (UV013) enumeration of those <element variable reference> s.

2)

The result of SDP is defined as follows.

Case:

a)

If there exists i, 1 (one) ≤ i ≤ N, such that GEi is the null value, then an exception condition is raised: data exception — null value not allowed (22004).

b)

If every GE i, 1 (one) ≤ i ≤ N references the same graph element, then the result of SDP is True.

c)

Otherwise, the result of SDP is False.

Conformance Rules

1)

Without Feature G114, “SAME predicate”, conforming GQL language shall not contain <same pre-

dicate>.

19.13 <property_exists predicate>

Function

Determine if a referenced graph element has a property.

334

IWD 39075:202y(E)

19.13 <property_exists predicate>

« WG3:UTC-127R1 »

Format

<property_exists predicate> ::=

PROPERTY_EXISTS

<left paren> <element variable reference> <comma> <property name> <right paren>

Syntax Rules

1)

Let PEP be the <property_exists predicate> .

2)

Let EVR be the <element variable reference> simply contained in PEP. EVR shall have singleton degree of reference.

3)

Let PN be the name specified by the <property name> simply contained in PEP.

General Rules

1)

Let GRV be the result of EVR.

2)

The result of PEP is defined as follows:

Case:

a)

If GRV is the null value, then the result of PEP is Unknown.

b)

If the referent of GRV has a property whose name is PN, then the result of PEP is True.

c)

Otherwise, the result of PEP is False.

Conformance Rules

1)

Without Feature G115, “PROPERTY_EXISTS predicate”, conforming GQL language shall not contain

<property_exists predicate>.

335





IWD 39075:202y(E)

20 Value expressions

20.1 <value specification>

Function

Specify one or more values or parameters.

Format

<value specification> ::=

<literal>

| <parameter value specification>

<unsigned value specification> ::=

<unsigned literal>

| <parameter value specification>

<unsigned integer specification> ::=

<unsigned integer>

| <parameter>

<parameter value specification> ::=

<parameter>

| <predefined parameter>

<predefined parameter> ::=

CURRENT_USER

Syntax Rules

1)

The declared type of CURRENT_USER is character string.

« WG3:UTC-051 »

2)

The declared type of <unsigned integer specification> shall be an implementation-defined (ID062)

exact numeric type.

General Rules

1)

A <value specification> or <unsigned value specification> specifies a value that is not selected from a graph.

2)

A <parameter name> identifies a session parameter or a request parameter.

3)

The value specified by a <literal> is the value represented by that <literal> .

4)

The value specified by CURRENT_USER is

Case:

a)

If there is a current authorization identifier, then the value of that current authorization

identifier.

336

IWD 39075:202y(E)

20.1 <value specification>

b)

Otherwise, the null value.

5)

If a <value specification> evaluates to the null value, then an exception condition is raised: data exception — null value not allowed (22004).

« WG3:UTC-015 deleted 2 GRs »

« WG3:UTC-015 »

6)

If <unsigned integer specification> is specified, then:

a)

Let V be the result of the <unsigned integer specification>.

b)

If V is the null value, then an exception condition is raised: data exception — null value not

allowed (22004).

c)

If V is not an exact number with scale 0 (zero), then an exception condition is raised: data

exception — invalid value type (22G03).

d)

If V is negative, then an exception condition is raised: data exception — negative limit value

(22G02).

Conformance Rules

« WG3:UTC-086R1 »

1)

Without Feature GE04, “Graph reference value expressions”, conforming GQL-language shall not

contain a <value expression> that simply contains a <graph reference value expression> .

2)

Without Feature GE05, “Binding table reference value expressions”, conforming GQL-language shall

not contain a <value expression> that simply contains a <binding table reference value expression>.

337





IWD 39075:202y(E)

20.2 <value expression>

20.2 <value expression>

Function

Specify a constant or a value.

Format

<value expression> ::=

<common value expression>

| <boolean value expression>

<common value expression> ::=

<numeric value expression>

| <string value expression>

| <datetime value expression>

| <duration value expression>

| <list value expression>

| <record value expression>

| <path value expression>

| <reference value expression>

<reference value expression> ::=

<graph reference value expression>

| <binding table reference value expression>

| <node reference value expression>

| <edge reference value expression>

<graph reference value expression> ::=

[ PROPERTY ] GRAPH <graph expression>

| <value expression primary>

<binding table reference value expression> ::=

[ BINDING ] TABLE <binding table expression>

| <value expression primary>

<node reference value expression> ::=

<value expression primary>

<edge reference value expression> ::=

<value expression primary>

<record value expression> ::=

<value expression primary>

« WG3:UTC-081 »

<aggregating value expression> ::=

<value expression>

Syntax Rules

1)

The declared type of a <graph reference value expression> shall be a graph reference value type.

2)

The declared type of a <binding table reference value expression> shall be a binding table reference

value type.

3)

The declared type of a <node reference value expression> shall be a node reference value type.

4)

The declared type of an <edge reference value expression> shall be an edge reference value type.

338

IWD 39075:202y(E)

20.2 <value expression>

5)

The declared type of a <record value expression> shall be a record type.

« WG3:UTC-081 »

« WG3:UTC-123R2 »

6)

If a <value expression> that is not immediately contained in an <aggregating value expression>

directly contains an <aggregate function> AF, then:

« WG3:UTC-123R2 »

a)

The <value expression> or the <dependent value expression> immediately contained in AF

shall contain one or more <binding variable reference> s to exactly one variable whose declared

type is a material group list value type.

b)

All <binding variable reference>s simply contained in AF whose declared type is a group list value type shall have the same name.

General Rules

None.

Conformance Rules

1)

Without Feature GB27, “Record types”, conforming GQL language shall not contain a <record value

expression> .

« WG3:UTC-039R1 »

2)

Without Feature GD07, “Graph reference value types”, conforming GQL language shall not contain

a <graph reference value expression> .

3)

Without Feature GD08, “Binding table reference value types”, conforming GQL language shall not

contain a <binding table reference value expression> .

« WG3:UTC-123R2 »

4)

Without Feature GC29, “Horizontal aggregation”, conforming GQL language shall not contain a

<value expression> not immediately contained in an <aggregating value expression> that directly contains an <aggregate function> .

339





IWD 39075:202y(E)

20.3 <boolean value expression>

20.3 <boolean value expression>

Function

Specify a Boolean value.

Format

<boolean value expression> ::=

<boolean term>

| <boolean value expression> OR <boolean term>

| <boolean value expression> XOR <boolean term>

<boolean term> ::=

<boolean factor>

| <boolean term> AND <boolean factor>

<boolean factor> ::=

[ NOT ] <boolean test>

« WG3:UTC-092 »

<boolean test> ::=

<boolean primary> [ IS [ NOT ] <truth value> ]

<truth value> ::=

TRUE

| FALSE

| UNKNOWN

<boolean primary> ::=

<predicate>

| <boolean predicand>

<boolean predicand> ::=

<parenthesized boolean value expression>

| <non-parenthesized value expression primary>

<parenthesized boolean value expression> ::=

<left paren> <boolean value expression> <right paren>

Syntax Rules

** Editor’s Note (number 49) **

Rules regarding known-not null are ignored for the moment.

** Editor’s Note (number 50) **

Rules regarding known-not null and determinism are ignored for the moment. See Language Opportunity GQL-011 .

1)

The declared type of a <boolean value expression> is a Boolean type.

2)

The declared type of a <parenthesized boolean value expression> is the declared type of the simply

contained <boolean value expression> .

3)

The declared type of a <boolean predicand> that is a <non-parenthesized value expression primary>

shall be a Boolean type.

340

IWD 39075:202y(E)

20.3 <boolean value expression>

4)

X XOR Y is equivalent to the following <boolean value expression>:

( X OR Y ) AND NOT ( X AND Y )

5)

If NOT is specified in a <boolean test> , then let BP be the contained <boolean primary> and let TV

be the contained <truth value> . The <boolean test> is equivalent to:

( NOT ( BP IS TV ) )

General Rules

1)

The result is derived by the application of the specified Boolean operators (“AND”, “OR”, “NOT”,

and “IS”) to the results derived from each <boolean primary> . If Boolean operators are not specified, then the result of the <boolean value expression> is the result of the specified <boolean primary> .

2)

NOT ( True) is False, NOT ( False) is True, and NOT ( Unknown) is Unknown.

3)

Table 4, “Truth table for the AND Boolean operator” , Table 5, “Truth table for the OR Boolean

operator”, and Table 6, “Truth table for the IS Boolean operator” , specify the semantics of AND, OR, and IS, respectively.

Table 4 — Truth table for the AND Boolean operator

AND

True

False

Unknown

True

True

False

Unknown

False

False

False

False

Unknown Unknown

False

Unknown

Table 5 — Truth table for the OR Boolean operator

OR

True

False

Unknown

True

True

True

True

False

True

False

Unknown

Unknown True

Unknown

Unknown

Table 6 — Truth table for the IS Boolean operator

IS

TRUE

FALSE

UNKNOWN

True

True

False

False

False

False

True

False

Unknown False

False

True

341

IWD 39075:202y(E)

20.3 <boolean value expression>

Conformance Rules

None.

342





IWD 39075:202y(E)

20.4 <numeric value expression>

20.4 <numeric value expression>

Function

Specify a numeric value.

Format

<numeric value expression> ::=

<term>

| <numeric value expression> <plus sign> <term>

| <numeric value expression> <minus sign> <term>

<term> ::=

<factor>

| <term> <asterisk> <factor>

| <term> <solidus> <factor>

<factor> ::=

[ <sign> ] <numeric primary>

<numeric primary> ::=

<value expression primary>

| <numeric value function>

Syntax Rules

« WG3:UTC-90R1 deleted an editor's note »

1)

Case:

« WG3:UTC-015 »

a)

If the declared type of either operand of a dyadic arithmetic operator is approximate numeric,

then the declared type of the result is an implementation-defined (ID063) approximate numeric

type.

b)

Otherwise, the declared type of both operands of a dyadic arithmetic operator is exact numeric

and the declared type of the result is an implementation-defined (ID064) exact numeric type,

with precision and scale determined as follows:

i)

Let S1 and S2 be the scale of the first and second operands respectively.

ii)

The precision of the result of addition and subtraction is implementation-defined

(ID065), and the scale is the maximum of S1 and S2.

iii)

The precision of the result of multiplication is implementation-defined (ID066), and

the scale is S1 + S2.

iv)

The precision and scale of the result of division are implementation-defined (ID067).

2)

The declared type of a <factor> is that of the immediately contained <numeric primary> .

3)

The declared type of a <numeric primary> shall be numeric.

4)

If a <numeric value expression> immediately contains a <minus sign> NMS and immediately contains a <term> that is a <factor> that immediately contains a <sign> that is a <minus sign> FMS, then there shall be a <separator> between NMS and FMS.

343

IWD 39075:202y(E)

20.4 <numeric value expression>

General Rules

1)

If the result of any <numeric primary> simply contained in a <numeric value expression> is the null value, then the result of the <numeric value expression> is the null value.

2)

If the <numeric value expression> contains only a <numeric primary>, then the result of the <numeric

value expression> is the result of the specified <numeric primary>.

3)

The monadic arithmetic operators <plus sign> and <minus sign> (+ and −, respectively) specify monadic plus and monadic minus, respectively. Monadic plus does not change its operand. Monadic

minus reverses the sign of its operand.

« WG3:UTC-063 »

4)

The dyadic arithmetic operators <plus sign>, <minus sign> , <asterisk> , and <solidus> (+, −, *, and

/, respectively) specify addition, subtraction, multiplication, and division, respectively. If the value

of a divisor is zero, then

Case:

a)

If a GQL-implementation supports Feature GB50, “IEEE 754 floating point operations”, then

the result is a value as defined by IEEE Std 754:2019.

b)

Otherwise, an exception condition is raised: data exception — division by zero (22012).

« WG3:UTC-015 »

5)

If the result of an arithmetic operation is an exact number, then

Case:

a)

If the operator is not division and the mathematical result of the operation is not exactly

representable with the precision and scale of the declared type of the result, then an exception

condition is raised: data exception — numeric value out of range (22003).

b)

If the operator is division and the approximate mathematical result of the operation repres-

ented with the precision and scale of the declared type of the result loses one or more leading

significant digits after rounding or truncating if necessary, then an exception condition is

raised: data exception — numeric value out of range (22003). The choice of whether to round

or truncate is implementation-defined (IA011).

« WG3:UTC-063 »

« WG3:UTC-015 »

6)

If the result of an arithmetic operation is an approximate number and the exponent of the approx-

imate mathematical result of the operation is not within the implementation-defined (IL023)

exponent range for the declared type of the result, then

Case:

a)

If a GQL-implementation supports Feature GB50, “IEEE 754 floating point operations”, then

the result is a value as defined by IEEE Std 754:2019.

b)

Otherwise, an exception condition is raised: data exception — numeric value out of range

(22003).

Conformance Rules

None.

344





IWD 39075:202y(E)

20.5 <value expression primary>

20.5 <value expression primary>

Function

Specify a value that is syntactically self-delimited.

Format

<value expression primary> ::=

<parenthesized value expression>

| <non-parenthesized value expression primary>

<parenthesized value expression> ::=

<left paren> <value expression> <right paren>

« WG3:UTC-039R1 »

<non-parenthesized value expression primary> ::=

<non-parenthesized value expression primary special case>

| <binding variable reference>

« WG3:UTC-039R1 »

<non-parenthesized value expression primary special case> ::=

<property reference>

« WG3:UTC-015 deleted one alternative »

« WG3:UTC-039R1 Deleted 1 alternative »

« WG3:UTC-100 Deleted 1 (one) alternative »

| <unsigned value specification>

| <aggregate function>

| <collection value constructor>

| <value query expression>

| <case expression>

« WG3:UTC-015 »

| <let value expression>

| <cast specification>

| <element_id function>

<collection value constructor> ::=

<list value constructor>

| <record value constructor>

| <path value constructor>

** Editor’s Note (number 51) **

It needs to be decided if evaluating aggregate functions over the current working table should be supported by occurrence of

a <value expression> . See Language Opportunity GQL-017 .

Syntax Rules

None.

General Rules

None.

345

IWD 39075:202y(E)

20.5 <value expression primary>

Conformance Rules

None.

346





IWD 39075:202y(E)

20.6 <numeric value function>

20.6 <numeric value function>

Function

Specify a function yielding a value of type numeric.

Format

<numeric value function> ::=

<length expression>

| <absolute value expression>

| <modulus expression>

| <trigonometric function>

| <general logarithm function>

| <common logarithm>

| <natural logarithm>

| <exponential function>

| <power function>

| <square root>

| <floor function>

| <ceiling function>

<length expression> ::=

<char length expression>

| <byte length expression>

| <path length expression>

<char length expression> ::=

{ CHAR_LENGTH | CHARACTER_LENGTH }

<left paren> <character string value expression> <right paren>

<byte length expression> ::=

{ BYTE_LENGTH | OCTET_LENGTH }

<left paren> <byte string value expression> <right paren>

<path length expression> ::=

PATH_LENGTH <left paren> <path value expression> <right paren>

<absolute value expression> ::=

ABS <left paren> <numeric value expression> <right paren>

<modulus expression> ::=

MOD <left paren> <numeric value expression dividend> <comma>

<numeric value expression divisor> <right paren>

<numeric value expression dividend> ::=

<numeric value expression>

<numeric value expression divisor> ::=

<numeric value expression>

<trigonometric function> ::=

<trigonometric function name> <left paren> <numeric value expression> <right paren>

<trigonometric function name> ::=

SIN | COS | TAN | COT | SINH | COSH | TANH | ASIN | ACOS | ATAN | DEGREES | RADIANS

<general logarithm function> ::=

LOG <left paren> <general logarithm base> <comma>

<general logarithm argument> <right paren>

347

IWD 39075:202y(E)

20.6 <numeric value function>

<general logarithm base> ::=

<numeric value expression>

<general logarithm argument> ::=

<numeric value expression>

<common logarithm> ::=

LOG10 <left paren> <numeric value expression> <right paren>

<natural logarithm> ::=

LN <left paren> <numeric value expression> <right paren>

<exponential function> ::=

EXP <left paren> <numeric value expression> <right paren>

<power function> ::=

POWER <left paren> <numeric value expression base> <comma>

<numeric value expression exponent> <right paren>

<numeric value expression base> ::=

<numeric value expression>

<numeric value expression exponent> ::=

<numeric value expression>

<square root> ::=

SQRT <left paren> <numeric value expression> <right paren>

<floor function> ::=

FLOOR <left paren> <numeric value expression> <right paren>

<ceiling function> ::=

{ CEIL | CEILING } <left paren> <numeric value expression> <right paren>

** Editor’s Note (number 52) **

SQL contains other possibly relevant numeric value functions such as:

1)

POSITION for character strings and byte strings.

2)

EXTRACT for datetimes and durations. Cypher has a range of functions with similar functionality.

3)

CARDINALITY for collections. See also Cypher function size().

See Language Opportunity GQL-176 .

** Editor’s Note (number 53) **

SQL contains other numeric value functions that are probably not relevant such as:

1)

WIDTH_BUCKET.

2)

MATCH_NUMER

3)

ARRAY_MAX_CARDINALITY.

See Language Opportunity GQL-176 .

** Editor’s Note (number 54) **

Cypher contains other possibly relevant numeric value functions such as:

1)

size() - returns the number of items in a list, the length of a character string, or the number of subgraphs matching the

pattern expression. See also the SQL function CARDINALITY and the current GQL function CHARACTER_LENGTH.

348

IWD 39075:202y(E)

20.6 <numeric value function>

2)

round() - returns the value of a number rounded to the nearest integer.

3)

rand() - returns a random floating point number in the range from 0 (inclusive) to 1 (exclusive); i.e., [0,1). The numbers

returned follow an approximate uniform distribution.

4)

e() - returns the base of the natural logarithm, e.

5)

sign() - returns an indication of the sign of a number: 0 if the number is 0, -1 for any negative number, and 1 for any

positive number.

6)

pi() - returns the mathematical constant pi.

7)

haversin() - returns half the versed sine of a number.

8)

atan2() - returns the arctangent2 of a set of coordinates in radians.

9)

reduce() - returns the value resulting from the application of an expression on each successive element in a list in con-

junction with the result of the computation thus far. This function iterates through each element e in the given list, run

the expression on e - taking into account the current partial result - and store the new partial result in the accumulator.

This function is analogous to the fold or reduce method in functional languages such as Lisp and Scala.

See Language Opportunity GQL-176 .

** Editor’s Note (number 55) **

Cypher contains other numeric value functions that may not be relevant such as:

1)

id() - returns the id of a relationship or node.

See Language Opportunity GQL-176 .

** Editor’s Note (number 56) **

Discussion is required as to whether any of the functions named above should be incorporated into GQL. See Language

Opportunity GQL-176 .

Syntax Rules

« WG3:UTC-90R1 deleted an editor's note »

« WG3:UTC-090R1 »

1)

If <length expression> is specified, then the declared type of the result is the implementation-defined

(ID068) nullable exact numeric type with scale 0 (zero).

2)

If <absolute value expression> is specified, then the declared type of the result is the declared type of the immediately contained <numeric value expression>.

« Editorial: Consolidate implementation-defined codes »

3)

If <trigonometric function> is specified, then the declared type of the result is an implementation-

defined (ID069) approximate numeric type.

4)

The declared type of the result of <general logarithm function> is an implementation-defined

(ID069) approximate numeric type.

5)

The declared type of the result of <natural logarithm> is an implementation-defined (ID069)

approximate numeric type.

6)

The declared type of the result of <exponential function> is an implementation-defined (ID069)

approximate numeric type.

349

IWD 39075:202y(E)

20.6 <numeric value function>

7)

The declared type of the result of <power function> is an implementation-defined (ID069)

approximate numeric type.

8)

If <floor function> or <ceiling function> is specified, then

Case:

a)

If the declared type of the immediately contained <numeric value expression> NVE is exact

numeric, then the declared type of the result is exact numeric with implementation-defined

(ID074) precision, with the radix of NVE, and with scale 0 (zero).

b)

Otherwise, an approximate numeric with implementation-defined (ID075) precision.

9)

If <common logarithm> is specified, then let NVE be the simply contained <numeric value expres-

sion>. The <common logarithm> is equivalent to:

LOG (10, NVE)

10) If <square root> is specified, then let NVE be the simply contained <numeric value expression> .

The <square root> is equivalent to:

POWER ( NVE, 0.5)

General Rules

« Editorial: Added note on character string length »

1)

If the <char length expression> CLX is specified, then let the character string CSV be the result of the <character string value expression> immediately contained in CLX.

Case:

a)

If CSV is material, then the result of CLX is the (character string) length of CSV.

NOTE 212 — The (character string) length of CSV is defined in Subclause 4.15.3.3, “Character string types”

as the number of characters in the sequence of characters comprising CSV.

b)

Otherwise, the result of CLX is the null value.

« Editorial: Added note on byte string length »

2)

If the <byte length expression> BLX is specified, then let the byte string BSV be the result of the

<byte string value expression> immediately contained in BLX.

Case:

a)

If BSV is material, then the result of BLX is the (byte string) length of BSV.

NOTE 213 — The (byte string) length of BSV is defined in Subclause 4.15.3.4, “Byte string types” as the number of bytes in the sequence of bytes comprising BSV.

b)

Otherwise, the result of BL is the null value.

« Editorial: Added note on path value length »

3)

If the <path length expression> PLX is specified, then let the path value PSV be the result of the

<path value expression> immediately contained in PLX.

Case:

a)

If PSV is material, then the result of PLX is the (path value) length of PSV.

350

IWD 39075:202y(E)

20.6 <numeric value function>

NOTE 214 — The (path value) length of PSV is defined in Subclause 4.15.2.4, “Path value types” as the number of edge reference values in the path element list PEL of PSV, if PEL contains at least one node reference value; otherwise the null value.

b)

Otherwise, the result of PLX is the null value.

« WG3:UTC-90R1 moved 7 GRs to become SRs »

4)

If <absolute value expression> is specified, then let N be the result of the immediately contained

<numeric value expression> .

Case:

a)

If N is the null value, then the result is the null value.

b)

If N ≥ 0, then the result is N.

c)

Otherwise, the result is −1 * N. If −1 * N is not representable by the declared type of the result,

then an exception condition is raised: data exception — numeric value out of range (22003).

5)

If <modulus expression> is specified, then let N be the value of the immediately contained <numeric

value expression dividend> and let M be the value of the immediately contained <numeric value

expression divisor>.

Case:

a)

If at least one of N and M is the null value, then the result is the null value.

b)

If M is zero, then an exception condition is raised: data exception — division by zero (22012).

c)

Otherwise, the result is the unique exact numeric value R with scale 0 (zero) such that all of

the following are true:

i)

R has the same sign as N.

ii)

The absolute value of R is less than the absolute value of M.

iii)

N = M * K + R for some exact numeric value K with scale 0 (zero).

6)

If <trigonometric function> is specified, then let V be the result of the immediately contained

<numeric value expression> that represents an angle expressed in radians.

Case:

a)

If V is the null value, then the result is the null value.

b)

Otherwise, let OP be the <trigonometric function name>.

Case:

i)

If OP is ACOS, then

Case:

1)

If V is less than −1 (negative one) or V is greater than 1 (one), then an exception

condition is raised: data exception — numeric value out of range (22003).

2)

Otherwise, the result of the <trigonometric function> is the inverse cosine of V.

ii)

If OP is ASIN, then

Case:

1)

If V is less than −1 (negative one) or V is greater than 1 (one), then an exception

condition is raised: data exception — numeric value out of range (22003).

351

IWD 39075:202y(E)

20.6 <numeric value function>

2)

Otherwise, the result of the <trigonometric function> is the inverse sine of V.

iii)

If OP is ATAN, then the result is the inverse tangent of V.

iv)

If OP is COS, then the result is the cosine of V.

v)

If OP is COSH, then the result is the hyperbolic cosine of V.

vi)

If OP is SIN, then the result is the sine of V.

vii)

If OP is SINH, then the result is the hyperbolic sine of V.

viii)

If OP is TAN, then the result is the tangent of V.

ix)

If OP is TANH, then the result is the hyperbolic tangent of V.

x)

If OP is COT, then the result is the cotangent of V.

xi)

If OP is DEGREES, then the result is the value of V, taken to be in radians, expressed as

degrees.

xii)

If OP is RADIANS, then the result is the value of V, taken to be in degrees, expressed as

radians.

7)

If <general logarithm function> is specified, then let VB be the value of the <general logarithm base>

and let VA be the value of the <general logarithm argument>.

Case:

a)

If at least one of VA and VB is the null value, then the result is the null value.

b)

If VA is negative or 0 (zero), then an exception condition is raised: data exception — numeric

value out of range (22003).

c)

If VB is negative, 0 (zero), or 1 (one), then an exception condition is raised: data exception —

numeric value out of range (22003).

d)

Otherwise, the result is the logarithm with base VB of VA.

8)

If <natural logarithm> is specified, then let V be the value of the immediately contained <numeric

value expression>.

Case:

a)

If V is the null value, then the result is the null value.

b)

If V is 0 (zero) or negative, then an exception condition is raised: data exception — invalid

argument for natural logarithm (2201E).

c)

Otherwise, the result is the natural logarithm of V.

9)

If <exponential function> is specified, then let V be the result of the immediately contained <numeric

value expression>.

Case:

a)

If V is the null value, then the result is the null value.

b)

Otherwise, the result is e (the base of natural logarithms) raised to the power V. If the result

is not representable in the declared type of the result, then an exception condition is raised:

data exception — numeric value out of range (22003).

352

IWD 39075:202y(E)

20.6 <numeric value function>

10) If <power function> is specified, then let NVEB be the <numeric value expression base> , then let VB be the value of NVEB, let NVEE be the <numeric value expression exponent>, and let VE be the value of NVEE.

Case:

a)

If at least one of VB and VE is the null value, then the result is the null value.

b)

If VB is 0 (zero) and VE is negative, then an exception condition is raised: data exception —

invalid argument for power function (2201F).

c)

If VB is 0 (zero) and VE is 0 (zero), then the result is 1 (one).

d)

If VB is 0 (zero) and VE is positive, then the result is 0 (zero).

e)

If VB is negative and VE is not equal to an exact numeric value with scale 0 (zero), then an

exception condition is raised: data exception — invalid argument for power function (2201F).

f)

If VB is negative and VE is equal to an exact numeric value with scale 0 (zero) that is an even

number, then the result is the result of

EXP( NVEE*LN(- NVEB))

g)

If VB is negative and VE is equal to an exact numeric value with scale 0 (zero) that is an odd

number, then the result is the result of

-EXP( NVEE*LN(- NVEB))

h)

Otherwise, the result is the result of

EXP( NVEE*LN( NVEB))

11) If <floor function> is specified, then let V be the result of the immediately contained <numeric value

expression> NVE.

Case:

a)

If V is the null value, then the result is the null value.

b)

Otherwise,

Case:

« WG3:UTC-015 »

i)

If the declared type of NVE is exact numeric, then the result is the greatest exact numeric

value with scale 0 (zero) that is less than or equal to V. If this result is not representable

by the declared type of the result, then an exception condition is raised: data exception

— numeric value out of range (22003).

ii)

Otherwise, the result is the greatest whole number that is less than or equal to V. If this

result is not representable by the declared type of the result, then an exception condition

is raised: data exception — numeric value out of range (22003).

12) If <ceiling function> is specified, then let V be the result of the immediately contained <numeric

value expression> NVE.

Case:

a)

If V is the null value, then the result is the null value.

b)

Otherwise,

353

IWD 39075:202y(E)

20.6 <numeric value function>

Case:

« WG3:UTC-015 »

i)

If the declared type of NVE is exact numeric, then the result is the least exact numeric

value with scale 0 (zero) that is greater than or equal to V. If this result is not repres-

entable by the declared type of the result, then an exception condition is raised: data

exception — numeric value out of range (22003).

ii)

Otherwise, the result is the least whole number that is greater than or equal to V. If this

result is not representable by the declared type of the result, then an exception condition

is raised: data exception — numeric value out of range (22003).

Conformance Rules

1)

Without Feature GF01, “Enhanced numeric functions”, conforming GQL language shall not contain

an <absolute value expression> , a <modulus expression>, a <floor function> , a <ceiling function>,

or a <square root> .

2)

Without Feature GF02, “Trigonometric functions”, conforming GQL language shall not contain a

<trigonometric function> .

3)

Without Feature GF03, “Logarithmic functions”, conforming GQL language shall not contain a

<general logarithm function>, a <common logarithm>, a <natural logarithm> , an <exponential

function>, or a <power function> .

4)

Without Feature GF04, “Enhanced path functions”, conforming GQL language shall not contain a

<path length expression> .

354





IWD 39075:202y(E)

20.7 <string value expression>

20.7 <string value expression>

Function

Specify a character string value or a byte string value.

Format

<string value expression> ::=

<character string value expression>

| <byte string value expression>

<character string value expression> ::=

<character string concatenation>

| <character string factor>

<character string concatenation> ::=

<character string value expression> <concatenation operator> <character string factor>

<character string factor> ::=

<character string primary>

<character string primary> ::=

<value expression primary>

| <string value function>

<byte string value expression> ::=

<byte string concatenation>

| <byte string factor>

<byte string factor> ::=

<byte string primary>

<byte string primary> ::=

<value expression primary>

| <string value function>

<byte string concatenation> ::=

<byte string value expression> <concatenation operator> <byte string factor>

Syntax Rules

« WG3:UTC-009 P00-USA-169 »

1)

If a <character string concatenation> CSC is specified, then let CSVE be the <character string value

expression> immediately contained in CSC and let CSF be the <character string factor> immediately contained in CSC. Let D1 be the declared type of CSVE and let D2 be the declared type of CSF. Let M

be the maximum length in characters of D1 plus the maximum length in characters of D2. Let L be

the implementation-defined (IL013) maximum length of character strings. The declared type of

<character string concatenation> is character string with maximum length equal to the lesser of M

and L.

2)

The declared type of a <character string primary> shall be a character string type.

3)

The declared type of a <byte string concatenation> BSC is a byte string type. Let BSVE be the <byte

string value expression> immediately contained in BSC and let BSF be the <byte string factor>

immediately contained in BSC. Let B1 be the declared type of BSVE and let B2 be the declared type 355

IWD 39075:202y(E)

20.7 <string value expression>

of BSF. Let M be the length in bytes of B1 plus the length in bytes of B2. Let VL be the implementation-

defined (IL014) maximum length of byte strings.

Case:

a)

If either B1 or B2 is a variable-length byte string, then BSC is a variable-length byte string. The

minimum length of BSC is an implementation-defined (IL009) non-negative exact number

that is less than or equal to the sum of the minimum lengths of B1 and B2, and the maximum

length of BSC is equal to the lesser of M and VL.

« WG3:UTC-009 P00-USA-169 »

b)

If both B1 and B2 are fixed-length byte strings, then BSC is a fixed-length byte string. The

minimum and maximum lengths of BSC are equal to M and M shall not be greater than VL.

4)

The declared type of a <byte string primary> shall be a byte string type.

General Rules

1)

If the result of any <character string primary> or <byte string primary>simply contained in a <string

value expression> is the null value, then the result of the <string value expression> is the null value.

2)

If <character string concatenation> is specified, then:

a)

In the remainder of this General Rule, the term “length” is taken to mean “length in characters”.

b)

Let S1 and S2 be the result of the <character string value expression> and <character string

factor> , respectively.

Case:

i)

If at least one of S1 and S2 is the null value, then the result of the <character string

concatenation> is the null value.

ii)

Otherwise:

1)

Let S be the character string comprising S1 followed by S2 and let M be the length

of S.

2)

S is replaced by

Case:

A)

If the <search condition> S1 IS NORMALIZED AND S2 IS NORMALIZED

evaluates to True, then:

NORMALIZE ( S)

B)

Otherwise, an implementation-defined (IW017) character string.

3)

Let VL be the implementation-defined (IL013) maximum length of character

strings.

Case:

A)

If M is less than or equal to VL, then the result of the <character string con-

catenation> is S with length M.

B)

If M is greater than VL and the right-most M− VL characters of S are all the

<whitespace> characters, then the result of the <character string concaten-

ation> is the first VL characters of S with length VL.

356

IWD 39075:202y(E)

20.7 <string value expression>

C)

Otherwise, an exception condition is raised: data exception — string data,

right truncation (22001).

« WG3:UTC-015 »

3)

If <byte string concatenation> is specified, then let S1 and S2 be the result of the <byte string value

expression> SE1 and <byte string factor> SE2, respectively.

Case:

a)

If at least one of S1 and S2 is the null value, then the result of the <byte string concatenation>

is the null value.

b)

Otherwise, let S be the byte string comprising S1 followed by S2; and let M be the length in bytes of S.

Case:

« WG3:UTC-015 »

i)

If the declared type of at least one of SE1 and SE2 is a variable-length byte string type,

then let VL be the implementation-defined (IL014) maximum length of byte strings.

Case:

1)

If M is less than or equal to VL, then the result of the <byte string concatenation>

is S with length M.

2)

If M is greater than VL and the right-most M− VL bytes of S are all X'00', then the

result of the <byte string concatenation> is the first VL bytes of S with length VL.

3)

Otherwise, an exception condition is raised: data exception — string data, right

truncation (22001).

« WG3:UTC-015 »

ii)

Otherwise, the declared types of both S1 and S2 are fixed-length byte string types, and

the result of the <byte string concatenation> is S.

Conformance Rules

None.

357





IWD 39075:202y(E)

20.8 <string value function>

20.8 <string value function>

Function

Specify a function yielding a character string value or a byte string value.

Format

<string value function> ::=

<character string function>

| <byte string function>

<character string function> ::=

« WG3:UTC-90R1 deleted one alternative »

<fold>

| <trim function>

| <normalize function>

« WG3:UTC-90R1 deleted one production »

« WG3:UTC-043 »

<fold> ::=

{ UPPER | LOWER } <left paren> <character string value expression> <right paren>

« WG3:UTC-090R1 »

<trim function> ::=

<single-character trim function>

| <multi-character trim function>

<single-character trim function> ::=

TRIM <left paren> <trim operands> <right paren>

<multi-character trim function> ::=

{ BTRIM | LTRIM | RTRIM } <left paren> <trim source> [ <comma> <trim character string>

] <right paren>

<trim operands> ::=

[ [ <trim specification> ] [ <trim character string> ] FROM ] <trim source>

<trim source> ::=

<character string value expression>

<trim specification> ::=

LEADING

| TRAILING

| BOTH

<trim character string> ::=

<character string value expression>

<normalize function> ::=

NORMALIZE <left paren> <character string value expression>

[ <comma> <normal form> ] <right paren>

<normal form> ::=

NFC

| NFD

| NFKC

| NFKD

<byte string function> ::=

358

IWD 39075:202y(E)

20.8 <string value function>

« WG3:UTC-90R1 deleted one alternative »

<byte string trim function>

« WG3:UTC-90R1 deleted one production »

« WG3:UTC-090R1 »

<byte string trim function> ::=

TRIM <left paren> <byte string trim operands> <right paren>

<byte string trim operands> ::=

[ [ <trim specification> ] [ <trim byte string> ] FROM ] <byte string trim source>

<byte string trim source> ::=

<byte string value expression>

<trim byte string> ::=

<byte string value expression>

« WG3:UTC-90R1 deleted one production »

<string length> ::=

<numeric value expression>

** Editor’s Note (number 57) **

SQL contains other possibly relevant string value functions such as:

1)

OVERLAY for character strings.

See Language Opportunity GQL-032 .

** Editor’s Note (number 58) **

SQL contains other string value functions that are probably not relevant such as:

1)

CONVERT.

2)

TRANSLITERATE.

3)

CLASSIFIER.

Discussion is requires as to whether any of the functions named above should be incorporated into GQL.

See Language Opportunity GQL-032 .

** Editor’s Note (number 59) **

Cypher contains other possibly relevant string value functions such as:

1)

replace() - returns a string in which every occurrence of a specified string in the original string has been replaced by

another (specified) string.

2)

reverse() - returns a string in which the order of every character in the original string have been reversed.

3)

type() - returns the string representation of the edge label. Note: that this would need modification for GQL that allows

multiple labels on an edge that Cypher does not.

4)

randomUUID() - returns a string value corresponding to a randomly generated UUID.

Discussion is requires as to whether any of the functions named above should be incorporated into GQL.

See Language Opportunity GQL-032 .

Syntax Rules

« WG3:UTC-90R1 deleted an editor's note »

359

IWD 39075:202y(E)

20.8 <string value function>

« WG3:UTC-90R1 deleted two SRs »

« WG3:UTC-090R1 »

1)

If <fold> is specified, then the declared type of the result is the declared type of the immediately

contained <character string value expression> .

2)

If <single-character trim function> SCTF is specified, then:

a)

The declared type of the result is the declared type of the <trim source> simply contained in

SCTF.

b)

Case:

i)

If FROM is specified, then:

1)

At least one of <trim specification> and <trim character string> shall be specified.

2)

If a <trim character string> is specified, then <trim character string> and <trim

source> shall be comparable.

3)

If <trim specification> is not specified, then BOTH is implicit.

4)

If <trim character string> is not specified, then <space> is implicit.

ii)

Otherwise, let SRC be <trim source>. TRIM ( SRC ) is equivalent to:

TRIM ( BOTH ' ' FROM SRC )

3)

If <multi-character trim function> MCTF is specified, then:

a)

The declared type of the result is the declared type of the <trim source> TS immediately contained in MCTF.

b)

Case:

i)

If a <trim character string> TC is specified, then TS and TC shall be comparable.

ii)

Otherwise, let TC be <space>.

c)

If BTRIM is specified, then BTRIM ( TS ) is equivalent to:

RTRIM ( LTRIM ( TS ) )

4)

If <normalize function> is specified, then

a)

The declared type of the result is character string.

b)

Case:

i)

If <normal form> is specified, then let NF be <normal form> .

ii)

Otherwise, let NF be NFC.

« WG3:UTC-90R1 deleted two SRs »

General Rules

« WG3:UTC-90R1 deleted 13 GRs »

1)

If <normalize function> is specified, then:

a)

Let S be the result of <character string value expression>.

360

IWD 39075:202y(E)

20.8 <string value function>

b)

If S is the null value, then the result of the <normalize function> is the null value.

c)

Let NR be S in the normalized form specified by NF in accordance with Unicode Standard

Annex #15.

d)

If the length in characters of NR is less than or equal to the implementation-defined (IL013)

maximum length of a character string, then the result of the <normalize function> is NR; oth-

erwise, an exception condition is raised: data exception — string data, right truncation (22001).

2)

If <fold> is specified, then:

a)

Let S be the result of the <character string value expression>.

b)

If S is the null value, then the result of the <fold> is the null value.

c)

Case:

i)

If UPPER is specified, then let FR be a copy of S in which every lower-case character

that has a corresponding upper-case character or characters and every title case

character that has a corresponding upper-case character or characters is replaced by

that upper-case character or characters.

ii)

If LOWER is specified, then let FR be a copy of S in which every upper-case character

that has a corresponding lower-case character or characters and every title case char-

acter that has a corresponding lower-case character or characters is replaced by that

lower-case character or characters.

d)

FR is replaced by

Case:

i)

If the <search condition> S IS NORMALIZED evaluated to True, then:

NORMALIZE ( FR)

ii)

Otherwise, FR.

e)

Let FRL be the length in characters of FR and let FRML be the implementation-defined (IL013)

maximum length of a character string.

f)

Case:

i)

If FRL is less than or equal to FRML, then the result of the <fold> is FR.

ii)

Otherwise, the result of the <fold> is the first FRML characters of FR. If any of the rightmost ( FRL − FRML) characters of FR are not <whitespace> characters, then a completion condition is raised: data exception — string data, right truncation (22001).

« WG3:UTC-090R1 »

3)

If SCTF is specified, then:

a)

Let S be the result of the <trim source> .

b)

Let SC be the value of the <trim character string>.

c)

If at least one of S and SC is the null value, then the result of SCTF is the null value and no further General Rules of this Subclause are applied.

d)

If the length in characters of SC is not 1 (one), then an exception condition is raised: data

exception — trim error (22027).

e)

Case:

361

IWD 39075:202y(E)

20.8 <string value function>

i)

If BOTH is specified or if no <trim specification> is specified, then the result of SCTF is

the value of S with every leading or trailing character equal to SC removed.

ii)

If TRAILING is specified, then the result of SCTF is the value of S with every trailing

character equal to SC removed.

iii)

If LEADING is specified, then the result of SCTF is the value of S with every leading

character equal to SC removed.

4)

If MCTF is specified, then:

a)

Let S be the result of the <trim source> .

b)

Let SC be the value of the <trim character string>.

c)

If at least one of S and SC is the null value, then the result of MCTF is the null value and no

further General Rules of this Subclause are applied.

d)

If S is the zero-length character string or SC is the zero-length character string, then the result

of MCTF is S and no further General Rules of this Subclause are applied.

e)

Case:

i)

If RTRIM is specified:

1)

Let P be the length in characters of S.

2)

Let C be the P-th character of S.

3)

While C is contained in SC, do:

A)

Let P be P − 1 (one).

B)

Let C be the P-th character of S.

4)

The result of MCTF is a character string containing the first P characters of S.

ii)

If LTRIM is specified:

1)

Let P be 1 (one).

2)

Let C be the P-th character of S.

3)

While C is contained in SC, do:

A)

Let P be P + 1 (one).

B)

Let C be the P-th character of S.

4)

The result of MCTF is a character string containing the last P characters of S.

« WG3:UTC-90R1 deleted two GRs »

« WG3:UTC-090R1 »

5)

If <byte string trim function> BSTF is specified, then:

a)

Let S be the result of the <byte string trim source> .

b)

Let SO be the value of <trim byte string>.

c)

If at least one of S and SO is the null value, then the result of BSTF is the null value.

d)

If the length in bytes of SO is not 1 (one), then an exception condition is raised: data exception

— trim error (22027).

362

IWD 39075:202y(E)

20.8 <string value function>

e)

Case:

i)

If BOTH is specified or if no <trim specification> is specified, then the result of BSTF is

the value of S with any leading or trailing bytes equal to SO removed.

ii)

If TRAILING is specified, then the result of BSTF is the value of S with any trailing bytes

equal to SO removed.

iii)

If LEADING is specified, then the result of BSTF is the value of S with any leading bytes

equal to SO removed.

Conformance Rules

« WG3:UTC-090R1 »

1)

Without Feature GF05, “Multi-character TRIM function”, conforming GQL language shall not contain

a <multi-character trim function> .

2)

Without Feature GF06, “Explicit TRIM function”, conforming GQL language shall not contain a

<single-character trim function> that simply contains FROM.

3)

Without Feature GF07, “Byte string TRIM function”, conforming GQL language shall not contain a

<byte string trim function> .

363





IWD 39075:202y(E)

20.9 <datetime value expression>

20.9 <datetime value expression>

Function

Specify a datetime value.

Format

<datetime value expression> ::=

<datetime term>

| <duration value expression> <plus sign> <datetime term>

| <datetime value expression> <plus sign> <duration term>

| <datetime value expression> <minus sign> <duration term>

<datetime term> ::=

<datetime factor>

<datetime factor> ::=

<datetime primary>

<datetime primary> ::=

<value expression primary>

| <datetime value function>

Syntax Rules

« WG3:UTC-117 Deleted 1 (one) editor's note »

« WG3:UTC-117 »

1)

If the declared type of <datetime term> is ZONED DATETIME, then the declared type of <datetime

value expression> is ZONED DATETIME; otherwise, the declared type of <datetime value expression>

is LOCAL DATETIME.

General Rules

« WG3:UTC-015 »

1)

If the result of a <datetime primary> is not a datetime, then an exception condition is raised: data exception — invalid value type (22G03).

2)

If the result of any <datetime primary>, <duration value expression>, <datetime value expression> , or <duration term> simply contained in a <datetime value expression> is the null value, then the result of the <datetime value expression> is the null value.

3)

The result of a <datetime primary> is the result of the immediately contained <value expression

primary> or <datetime value function>.

4)

If a <datetime value expression> immediately contains the operator <plus sign> or <minus sign>,

then the result is evaluated as specified in clause 14, “Date and time arithmetic” of ISO 8601-2:2019.

Conformance Rules

« WG3:UTC-117 »

364

IWD 39075:202y(E)

20.9 <datetime value expression>

1)

Without Feature GC23, “Date and time support”, conforming GQL language shall not contain a

<datetime value expression> .

365





IWD 39075:202y(E)

20.10 <datetime value function>

20.10 <datetime value function>

Function

Specify a function yielding a value of type datetime.

Format

<datetime value function> ::=

<date function>

| <time function>

| <datetime function>

| <local time function>

| <local datetime function>

<date function> ::=

CURRENT_DATE

| DATE <left paren> [ <date function parameters> ] <right paren>

<time function> ::=

CURRENT_TIME

| ZONED_TIME <left paren> [ <time function parameters> ] <right paren>

« WG3:UTC-117 »

<local time function> ::=

LOCAL_TIME [ <left paren> [ <time function parameters> ] <right paren> ]

« WG3:UTC-117 »

<datetime function> ::=

CURRENT_TIMESTAMP

| ZONED_DATETIME <left paren> [ <datetime function parameters> ] <right paren>

<local datetime function> ::=

LOCAL_TIMESTAMP

| LOCAL_DATETIME <left paren> [ <datetime function parameters> ] <right paren>

<date function parameters> ::=

<date string>

| <record value constructor>

<time function parameters> ::=

<time string>

| <record value constructor>

<datetime function parameters> ::=

<datetime string>

| <record value constructor>

** Editor’s Note (number 60) **

Cypher has a raft of datetime functions, some of which may not be already incorporated into GQL. These should be checked

for suitability of inclusion. See Language Opportunity GQL-196 .

Syntax Rules

« WG3:UTC-117 Deleted 1 (one) editor's note »

« WG3:UTC-117 »

366

IWD 39075:202y(E)

20.10 <datetime value function>

1)

CURRENT_DATE is equivalent to:

DATE()

2)

CURRENT_TIME is equivalent to:

ZONED_TIME()

3)

LOCAL_TIME is equivalent to:

LOCAL_TIME()

4)

CURRENT_TIMESTAMP is equivalent to:

ZONED_DATETIME()

5)

LOCAL_TIMESTAMP is equivalent to:

LOCAL_DATETIME()

« WG3:UTC-117 »

6)

The declared type of a <date function> is DATE.

7)

The declared type of a <time function> is ZONED TIME.

8)

The declared type of a <datetime function> is ZONED DATETIME.

9)

The declared type of a <local time function> is LOCAL TIME.

10) The declared type of a <local datetime function> is LOCAL DATETIME.

General Rules

« WG3:UTC-117 Deleted 1 (one) GR »

« WG3:UTC-132 »

1)

If the current request timestamp is “not set”, then set the current request timestamp to the current

date and time.

NOTE 215 — This can happen at any implementation-dependent (US009) point in time after the setting of the request timestamp to “not set”; the determination of the request timestamp need not wait for evaluation of a <datetime value

function> .

2)

If the set of <field name> s simply contained in a <date function parameters> is not one of: a)

'year'

b)

'year' and 'month'

c)

'year', 'month', and 'day'

d)

'year' and 'week'

e)

'year', 'week', and 'dayOfWeek'

f)

'year' and 'ordinalDay'

then an exception is raised: data exception — invalid datetime function field name (22G05).

3)

If the set of <field name> s simply contained in a <time function parameters> is not one of: a)

'hour'

367

IWD 39075:202y(E)

20.10 <datetime value function>

b)

'hour' and 'minute'

c)

'hour', 'minute', and 'second'

« WG3:UTC-117 Deleted 2 duplicate items »

d)

'hour', 'minute', 'second' and one or more of 'millisecond', 'microsecond', and 'nanosecond'.

« WG3:UTC-117 »

e)

If <time function parameters> is simply contained in a <time function>, then the set of permitted <field name> s also includes 'timezone'.

then an exception is raised: data exception — invalid datetime function field name (22G05).

4)

If the set of <field name> s contained in a <datetime function parameters> is not one of: a)

'year', 'month', 'day', and any of the set of <field name>s permitted in a <time function para-

meters> .

b)

'year', 'week', 'dayOfWeek', and any of the set of <field name> s permitted in a <time function

parameters> .

c)

'year', 'ordinalDay', and any of the set of <field name> s permitted in a <time function paramet-

ers> .

« WG3:UTC-117 omitted to include »

d)

If <datetime function parameters> is simply contained in a <datetime function>, then the set of permitted <field name>s also includes 'timezone'; otherwise, the set of permitted <field

name> s excludes 'timezone'.

then an exception is raised: data exception — invalid datetime function field name (22G05).

« Editorial: Deleted 1 (one) GR obsolete with WG3:UTC-117 »

« WG3:UTC-117 »

5)

Case:

a)

If the value of each <value expression> associated with the <field name> 'millisecond' is not between 0 (zero) and 999, or the value associated with 'microsecond', not between 0 (zero)

and 999999 and the value for 'nanosecond' not between 0 (zero) and 999999999, or, if more

than one of 'millisecond', 'microsecond', and 'nanosecond' is specified, any value exceeds 999,

then an exception is raised: data exception — invalid datetime function value (22G06).

b)

If the values associated with other <field name>s do not conform to the range of values specified

in clause 4.3, “Time scale components and units” of ISO 8601-1:2019, then an exception is

raised: data exception — invalid datetime function value (22G06).

« WG3:UTC-117 Deleted 1 (one) editor's note »

« WG3:UTC-009 P00-USA-169 »

« WG3:UTC-117 »

6)

If <date function parameters>, <time function parameters>, or <datetime function parameters>

are specified, then the record specified by the immediately contained <record value constructor>

is transformed, respectively, into an equivalent <date string>, <time string> , or <datetime string> .

7)

Case:

« WG3:UTC-132 »

a)

If the <datetime value function> s DATE(), ZONED_TIME(), ZONED_DATETIME(), LOCAL_TIME(),

and LOCAL_DATETIME() have no parameters, then they respectively return the current date,

zoned time, zoned datetime, local time, and local datetime from the current request timestamp.

368

IWD 39075:202y(E)

20.10 <datetime value function>

« WG3:UTC-117 Implied the deletion of 1 (one) paragraph »

« WG3:UTC-117 »

For ZONED_TIME() and ZONED_DATETIME(), the returned value has a time zone displacement

equal to the current time zone displacement.

b)

Otherwise, they return respectively the date, zoned time, zoned datetime, local time and local

datetime values associated with the representation as defined by ISO 8601-1:2019 and ISO

8601-2:2019.

Conformance Rules

« WG3:UTC-117 »

1)

Without Feature GC23, “Date and time support”, conforming GQL language shall not contain a

<datetime value function> .

369





IWD 39075:202y(E)

20.11 <duration value expression>

20.11 <duration value expression>

Function

Specify a duration value.

Format

« WG3:UTC-117 »

<duration value expression> ::=

<duration term>

| <duration value expression 1> <plus sign> <duration term 1>

| <duration value expression 1> <minus sign> <duration term 1>

| <datetime subtraction>

<datetime subtraction> ::=

DURATION_BETWEEN <left paren> <datetime subtraction parameters> <right paren>

« Editorial: Extracted parameters »

<datetime subtraction parameters> ::=

<datetime value expression 1> <comma> <datetime value expression 2>

<duration term> ::=

<duration factor>

| <duration term 2> <asterisk> <factor>

| <duration term 2> <solidus> <factor>

| <term> <asterisk> <duration factor>

<duration factor> ::=

[ <sign> ] <duration primary>

<duration primary> ::=

<value expression primary>

| <duration value function>

<duration value expression 1> ::=

<duration value expression>

<duration term 1> ::=

<duration term>

<duration term 2> ::=

<duration term>

« WG3:UTC-117 »

<datetime value expression 1> ::=

<datetime value expression>

<datetime value expression 2> ::=

<datetime value expression>

Syntax Rules

« WG3:UTC-117 Deleted 1 (one) editor's note »

1)

If <duration term>, DT immediately contains <solidus> , then let DT2 be the <duration term 2>

immediately contained in DT and F be the <factor> immediately contained in DT. DT is effectively replaced by:

370

IWD 39075:202y(E)

20.11 <duration value expression>

DT2 * ( 1 / F )

« WG3:UTC-117 »

2)

The declared type of a <duration value expression> is DURATION.

General Rules

« WG3:UTC-117 Deleted 1 (one) GR »

« WG3:UTC-015 »

1)

If the result of a <value expression primary> immediately contained in a <duration primary> is not a duration, then an exception condition is raised: data exception — invalid value type (22G03).

« WG3:UTC-117 »

2)

If the most specific types of <datetime value expression 1> and <datetime value expression 2>are not not datetimes, then an exception condition is raised: data exception — invalid value type (22G03).

3)

If <datetime value expression> is specified, then if <datetime value expression> and <datetime

term> are not comparable, then an exception condition is raised: data exception — values not

comparable (22G04).

4)

If <duration term> immediately contains <asterisk> , then let V be the result of the immediately contained <term> or <factor> . The result of the <duration term> is the duration specified by clause 14.3, “Multiplication” of ISO 8601-2:2019 with V as the coefficient, and <duration term 2> or

<duration factor> as durationA.

5)

The result of <duration value expression> DVE is defined as follows.

Case:

« WG3:UTC-117 »

a)

If the result of a <datetime primary> , <duration value expression>, or <duration term> simply contained in DVE is the null value, then the result of DVE is the null value.

b)

If DVE immediately contains <duration term>, then the result of DVE is the result of <duration

term> .

c)

If DVE immediately contains <duration value expression 1>, then

Case:

i)

If the two operands of DVE are of the same unit group, then the result of DVE is as

specified by clause 14, “Date and time arithmetic” of ISO 8601-2:2019.

ii)

Otherwise, the two operands of DVE are not of the same unit group and an exception

condition is raised: data exception — incompatible temporal instant unit groups (22G14).

« WG3:UTC-117 »

d)

If DVE immediately contains a <datetime subtraction> DS, then:

i)

Let DVE1 be the <datetime value expression 1> simply contained in DS.

ii)

Let DVE2 be the <datetime value expression 2> simply contained in DS.

iii)

Let MSP be the implementation-defined (IL024) maximum value of fractional seconds

precision for a temporal duration.

371

IWD 39075:202y(E)

20.11 <duration value expression>

iv)

Let the units Y be defined as follows: If DVE1 and DVE2 are dates, then Y is Days; other-

wise, Y is Seconds with a precision of MSP.

v)

DVE1 and DVE2 are converted to integer scalars DVE1IS and DVE2IS, respectively, in

units Y as displacements from some implementation-dependent (UV015) start datetime.

vi)

The result of DVE is determined by effectively computing DVE1IS minus DVE2IS,

rounding or truncating if necessary. The choice of whether to round or truncate is

implementation-defined (IA009).

If the required number of significant digits of the resulting duration exceeds MSP, then

an exception condition is raised: data exception — interval field overflow (22015).

It is implementation-defined (IA026) whether the resulting duration reflects leap

seconds.

e)

Otherwise, the result of DVE is the temporal duration that if added, as specified by clause 14,

“Date and time arithmetic” of ISO 8601-2:2019, to the <datetime term> would yield the same value as the <datetime value expression> .

Conformance Rules

« WG3:UTC-117 »

1)

Without Feature GC24, “Durations and temporal arithmetic support”, conforming GQL language

shall not contain a <duration value expression> .

372





IWD 39075:202y(E)

20.12 <duration value function>

20.12 <duration value function>

Function

Specify a function yielding a value of type duration.

Format

<duration value function> ::=

<duration function>

| <duration absolute value function>

<duration function> ::=

DURATION <left paren> <duration function parameters> <right paren>

<duration function parameters> ::=

<duration string>

| <record value constructor>

<duration absolute value function> ::=

ABS <left paren> <duration value expression> <right paren>

** Editor’s Note (number 61) **

Cypher has a raft of duration functions, some of which may not be already incorporated into GQL. These should be checked

for suitability of inclusion. See Language Opportunity GQL-197 .

Syntax Rules

« WG3:UTC-117 Deleted 1 (one) editor's note by implication »

None.

General Rules

1)

The declared type of a <duration function> is DURATION.

2)

If a <field name>s contained in a <duration function parameters> is not one of 'years', 'months',

'days', 'weeks', 'days', 'hours', 'minutes', 'seconds', 'milliseconds', 'microseconds', or 'nanoseconds',

then an exception condition is raised: data exception — invalid duration function field name (22G07).

« WG3:UTC-009 P00-USA-169 »

3)

If <duration function parameters> is specified, then the record is transformed into an equivalent

<duration string> .

4)

The result of a <duration function> is the duration specified for the <duration string> defined in clause 5.5.2, “Duration” of ISO 8601-1:2019 as extended by clauses 4.3, “Additional explicit forms”

and 4.4, “Numerical extensions” of ISO 8601-2:2019.

5)

If <duration absolute value function> is specified, then let N be the result of the <duration value

expression> .

Case:

a)

If N is the null value, then the result is the null value.

b)

If N ≥ 0 (zero), then the result is N.

373

IWD 39075:202y(E)

20.12 <duration value function>

c)

Otherwise, the result is −1 * N.

Conformance Rules

None.

374





IWD 39075:202y(E)

20.13 <list value expression>

20.13 <list value expression>

Function

Specify a list value.

Format

<list value expression> ::=

<list concatenation>

| <list primary>

<list concatenation> ::=

<list value expression 1> <concatenation operator> <list primary>

<list value expression 1> ::=

<list value expression>

<list primary> ::=

<list value function>

| <value expression primary>

Syntax Rules

1)

The declared type of a <list primary> shall be a list type.

2)

If <list concatenation> is specified, then:

« WG3:UTC-015 »

a)

The Syntax Rules of Subclause 22.16, “Result of value type combinations”, are applied with

the declared types of <list value expression 1> and <list primary> as DTSET; let DT be the

RESTYPE returned from the application of those Syntax Rules.

b)

Let IDMC be the implementation-defined (IL015) maximum cardinality of a list type.

« WG3:UTC-123R2 »

« WG3:UTC-096R1 »

c)

The declared type of <list concatenation> is the regular variant of DT.

General Rules

1)

If <list concatenation> is specified, then let LV1 be the result of <list value expression 1> and let LV2 be the value of <list primary>.

Case:

a)

If at least one of LV1 and LV2 is the null value, then the result of the <list concatenation> is the null value.

b)

If the sum of the cardinality of LV1 and the cardinality of LV2 is greater than IDMC, then an

exception condition is raised: data exception — list data, right truncation (22G0B).

c)

Otherwise, the result is the list comprising every element of LV1 followed by every element

of LV2.

375

IWD 39075:202y(E)

20.13 <list value expression>

Conformance Rules

1)

Without Feature GB28, “List value types”, conforming GQL language shall not contain a <list value

expression> .

376





IWD 39075:202y(E)

20.14 <list value function>

20.14 <list value function>

Function

Specify a function yielding a value of a list type.

Format

« WG3:UTC-015 »

<list value function> ::=

<trim list function> <elements function>

<trim list function> ::=

TRIM <left paren> <list value expression> <comma> <numeric value expression> <right paren>

<elements function> ::=

ELEMENTS <left paren> <path value expression> <right paren>

Syntax Rules

1)

If <trim list function> is specified, then:

a)

The declared type of the <numeric value expression> shall be an exact numeric type with

scale 0 (zero).

« WG3:UTC-123R2 »

b)

The declared type of the <trim list function> is the regular variant of the declared type of the

immediately contained <list value expression>.

2)

If <elements function> is specified, then the declared type of <elements function> is an implemen-

tation-defined (ID005) list value type that includes all node and edge reference values.

General Rules

1)

The result of <trim list function> is defined as follows:

a)

Let NV be the result of the <numeric value expression>.

b)

If NV is the null value, then the result is the null value and no further General Rules of this

Subclause are applied.

c)

If NV is less than 0 (zero), then an exception condition is raised: data exception — list element

error (22G0C).

d)

Let AV be the result of the <list value expression> .

e)

If AV is the null value, then the result is the null value and no further General Rules of this

Subclause are applied.

f)

Let AC be the cardinality of AV.

g)

If NV is greater than AC, then an exception condition is raised: data exception — list element

error (22G0C).

h)

Let N be AC − NV.

377

IWD 39075:202y(E)

20.14 <list value function>

i)

Case:

i)

If N = 0 (zero), then the result is a list whose cardinality is 0 (zero).

ii)

Otherwise, the result is a list of N elements such that for every i, 1 (one) ≤ i ≤ N, the

value of the i-th element of the result is the value of the i-th element of AV.

2)

The result of <elements function> EF is determined as follows.

a)

Let PV be the result of the <path value expression>.

b)

If PV is the null value, then the result of EF is the null value; otherwise, the result of EF is the path element list of PV.

Conformance Rules

1)

Without Feature GB28, “List value types”, conforming GQL language shall not contain a <list value

function>.

2)

Without Feature GF04, “Enhanced path functions”, conforming GQL language shall not contain an

<elements function>.

378





IWD 39075:202y(E)

20.15 <list value constructor>

20.15 <list value constructor>

Function

Specify construction of a list.

Format

<list value constructor> ::=

<list value constructor by enumeration>

<list value constructor by enumeration> ::=

[ <list value type name> ] <left bracket> [ <list element list> ] <right bracket>

<list element list> ::=

<list element> [ { <comma> <list element> }... ]

<list element> ::=

<value expression>

Syntax Rules

1)

The declared type of <list value constructor> is the declared type of the immediately contained <list

value constructor by enumeration>.

2)

Let LVCE be the <list value constructor by enumeration> . Let C be the number of <list element>s

simply contained in LVCE.

NOTE 216 — If <list value constructor by enumeration> does not simply contain a <list element list> , then C is equal to 0 (zero).

3)

If C is greater than 0 (zero), then the Syntax Rules of Subclause 22.16, “Result of value type combin-

ations” , are applied with the declared types of the <list element> s immediately contained in the

<list element list> of LVCE as DTSET; let DT be the RESTYPE returned from the application of those Syntax Rules. The declared type of LVCE is the regular list value type with element type DT and a

maximum cardinality C. Otherwise, C is equal to 0 (zero) and the declared type of LVCE is a list value type with an implementation-defined (ID004) list element type and a maximum cardinality of C.

4)

C shall be less or equal than the implementation-defined (IL015) maximum cardinality for list value types whose list element type is DT.

General Rules

1)

The result of <list value constructor by enumeration> is a list value whose i-th element is the value of the i-th <list element> simply contained in the <list value constructor by enumeration> , cast as the value type of DT.

NOTE 217 — If <list value constructor by enumeration> does not simply contain a <list element list> , then the result is a list value that is an empty list value.

Conformance Rules

1)

Without Feature GD02, “List value types”, conforming GQL language shall not contain a <list value

constructor> .

379





IWD 39075:202y(E)

20.16 <record value constructor>

20.16 <record value constructor>

Function

Specify construction of a record.

Format

<record value constructor> ::=

[ RECORD ] <fields specification>

<fields specification> ::=

<left brace> [ <field list> ] <right brace>

<field list> ::=

<field> [ { <comma> <field> }... ]

Syntax Rules

1)

Let RVC be the <record value constructor>.

2)

Every <fields specification> specifies the fields specified by the immediately contained <field list>.

3)

Every <field list> FL specifies the fields defined by the <field> s simply contained in FL.

4)

Let FS be the <fields specification> immediately contained in RVC, let n be the number of fields specified by FS. n shall be less or equal than the implementation-defined (IL019) maximum number of record fields. For every i, 1 (one) ≤ i ≤ n, let Fi be the i-th field specified by FS, and let FTi be the field type of Fi.

5)

Let RT be determined as follows:

a)

Let RT 0 be determined as follows:

i)

If n is 0 (zero), then RT 0 is:

RECORD {}

ii)

Otherwise, RT 0 is

RECORD { FT 1, ..., FTn }

b)

RT is the <record type> obtained by the application of Syntax Rules for <record type> to RT 0.

6)

The declared type of RVC is the record type specified by RT.

General Rules

1)

The General Rules of <record type> are applied to RT.

2)

The value of RVC is the record whose set of fields are the fields defined by the <field>s specified by FS.

380

IWD 39075:202y(E)

20.16 <record value constructor>

Conformance Rules

1)

Without Feature GD03, “Record types”, conforming GQL language shall not contain a <record value

constructor> .

2)

Without Feature GD04, “Closed record types”, the declared type of the <record value constructor>

is the record type specified by OPEN RECORD.

381





IWD 39075:202y(E)

20.17 <field>

20.17 <field>

Function

Specify a field.

Format

<field> ::=

<field name> <colon> <value expression>

Syntax Rules

1)

Let FL be the <field list> that simply contains a <field> F.

2)

The <field name> shall not be equivalent to the <field name> of any other <field> simply contained in FL.

3)

The <field name> specifies the field name of the field defined by F.

4)

The <value expression> specifies the field value expression of F.

5)

The field type of F is the pair comprising the field name of the field defined by F and the declared

type of the field value expression of F.

General Rules

1)

The field value of the field defined by F is the value of the field value expression of F.

Conformance Rules

1)

Without Feature GD01, “Nested record types”, conforming GQL language shall not contain a <field>

that simply contains a <record value constructor> .

382





IWD 39075:202y(E)

20.18 <path value expression>

20.18 <path value expression>

Function

Specify a path value.

Format

<path value expression> ::=

<path value concatenation>

| <path value primary>

<path value concatenation> ::=

<path value expression 1> <concatenation operator> <path value primary>

<path value expression 1> ::=

<path value expression>

<path value primary> ::=

<value expression primary>

Syntax Rules

« Correction to W24-035R1 »

1)

The declared type of a <path value concatenation> is the path value type.

2)

The declared type of a <path value primary> shall be a path value type.

General Rules

1)

If <path value concatenation> is specified, then let PV1 be the result of <path value expression 1>

and let PV2 be the result of <path value primary> .

Case:

a)

If either PV1 or PV2 is the null value, then the result of the <path value concatenation> is the null value.

b)

Otherwise:

i)

Let PEL1 and PEL2 be the path element lists of PV1 and PV2, respectively.

« WG3:UTC-080 »

ii)

If the last element of PEL1 and the first element of PEL2 are not node reference values

whose referent is the same node, then an exception condition is raised: data exception

— malformed path (22G0Z).

iii)

Let PELF be PEL1 without its last element.

NOTE 218 — If PEL1 is a single-node path value, then PELF is the empty sequence.

iv)

Let IDMC be the implementation-defined (IL022) maximum cardinality of path element

lists of path value types. If the sum of the cardinality of PELF and the cardinality of

PEL2 is greater than IDMC, then an exception condition is raised: data exception —

path data, right truncation (22G10).

383

IWD 39075:202y(E)

20.18 <path value expression>

v)

Let NPEL be the list value comprising every element of PELF followed by every element

of PEL2.

vi)

The result of the <path value concatenation> is the path value whose path element list

is NPEL.

Conformance Rules

1)

Without Feature GD06, “Path value types”, conforming GQL language shall not contain a <path value

expression> .

2)

Without Feature GB31, “Path value construction”, conforming GQL language shall not contain a

<path value concatenation> .

384





IWD 39075:202y(E)

20.19 <path value constructor>

20.19 <path value constructor>

Function

Specify construction of a path value.

Format

<path value constructor> ::=

<path value constructor by enumeration>

« WG3:UTC-080 »

<path value constructor by enumeration> ::=

PATH <left bracket> <path element list> <right bracket>

<path element list> ::=

<path element list start> [ <path element list step> ... ]

<path element list start> ::=

<node reference value expression>

<path element list step> ::=

<comma> <edge reference value expression> <comma> <node reference value expression>

Syntax Rules

« Correction to W24-035R1 »

1)

The declared type of the <path value constructor by enumeration> is the path value type.

General Rules

1)

If the <path value constructor by enumeration> PVCBE is specified, then:

a)

Let PEL be the list of results of all <node reference value expression>s and <edge reference

value expression>s simply contained in PVCBE.

b)

If PEL contains the null value or does not identify a path, then an exception condition is raised:

data exception — malformed path (22G0Z)

c)

The result of PVCBE is the path value whose path element list is PEL.

Conformance Rules

1)

Without Feature GB31, “Path value construction”, conforming GQL language shall not contain a

<path value constructor> .

385





IWD 39075:202y(E)

20.20 <property reference>

20.20 <property reference>

Function

« WG3:UTC-015 »

Reference a property of a graph element or record.

Format

« WG3:UTC-015 »

<property reference> ::=

<property source> <period> <property name>

<property source> ::=

<node reference value expression>

| <edge reference value expression>

| <record value expression>

Syntax Rules

« WG3:UTC-015 deleted an editor's note »

« WG3:UTC-015 »

1)

Let PR be the <property reference> , let PS be the <property source> immediately contained in PR, let PSD be the declared type of PS, and let PN be the <property name>, immediately contained in PR.

2)

If PS is the <record value expression>, then

Case:

a)

If PSD is a closed record type, then PN shall identify a field FIELD in PSD and the declared type of PR is the field value type of FIELD.

b)

Otherwise, PSD is the open record type and the declared type of PR is the open dynamic union

type.

3)

If PS is a <node reference value expression> or an <edge reference value expression> , then Case:

« WG3:UTC-086R1 »

a)

If PSD is a closed graph element reference value type, then PN shall identify a property type

PT in the constraining object type of PSD and the declared type of PR is the property value

type of PT.

b)

Otherwise, PSD is an open graph element reference value type and the declared type of PR is

the dynamic property value type.

General Rules

« WG3:UTC-015 deleted 3 GRs and an editor's note »

« WG3:UTC-015 »

386

IWD 39075:202y(E)

20.20 <property reference>

1)

Let SOURCE be the result of PS.

2)

Let PRD be the declared type of PR.

3)

Case:

a)

If SOURCE is the null value, then

Case:

i)

If PRD is nullable, then the result of PR is the null value and no further General Rules

of this Subclause are applied.

ii)

Otherwise, the following exception is raised: data exception — invalid value type (22G12).

b)

If SOURCE is a record and PN identifies a field FIELD in SOURCE, then the result of PR is the field value of FIELD.

c)

If SOURCE is a reference to a graph element GE and PN identifies a property PROP in GE, then: i)

Let PV be the property value of PROP.

ii)

If PV is not a value of PRD, then an exception condition is raised: data exception —

invalid value type (22G12); otherwise, the result of PR is PV.

d)

Otherwise,

i)

If PRD is nullable, then the result of PR is the null value.

ii)

Otherwise, PRD is material and an exception condition is raised: data exception —

invalid value type (22G12).

Conformance Rules

None.

387





IWD 39075:202y(E)

20.21 <value query expression>

20.21 <value query expression>

Function

Specify a scalar value derived from a <nested query specification>.

« WG3:UTC-064 Deleted 1 (one) editor's note by implication »

Format

<value query expression> ::=

VALUE <nested query specification>

Syntax Rules

« WG3:UTC-064 Deleted 1 (one) editor's note »

« WG3:UTC-064 »

1)

Let VQE be the <value query expression> .

2)

Let NQS be the <nested query specification> simply contained in VQE.

3)

The declared type of NQS shall be a binding table type with a single column SC.

4)

The emitting result statement of a <nested query specification> NQSX is defined as follows: a)

The emitting statement of a <nested query specification> NQSXX is the last <statement> simply contained in NQSXX.

b)

The emitting statement of NQSX shall be a <linear query statement>.

c)

Case:

i)

If the emitting statement of NQSX implicitly or explicitly simply contains a <primitive

result statement> PRSX, then the emitting result statement of NQSX is PRSX.

ii)

If the emitting statement of NQSX is a <focused nested query specification> or an

<ambient linear query statement> that immediately contains a <nested query specific-

ation> NNQSX and the emitting result statement of NNQSX is defined, then the emitting

result statement of NQSX is the emitting result statement of NNQSX.

** Editor’s Note (number 62) **

WG3:UTC-064 specified <ambient nested query specification> which does not exist. The editor corrected

to use <ambient linear query statement>.

iii)

Otherwise, the emitting statement of NQSX is undefined.

NOTE 219 — This is a recursive definition.

5)

The emitting result statement of NQS shall be defined.

6)

Let PRS be the emitting result statement of NQS.

7)

PRS shall implicitly or explicitly simply contain the <return statement> RS.

NOTE 220 — The emitting statement of NQS can be a <select statement> as long as the syntax transformation specified in Subclause 14.12, “<select statement>” yields a <linear query statement> TSS that fulfills the Syntax Rules of this Subclause if it is taken as the emitting statement of NQS.

388

IWD 39075:202y(E)

20.21 <value query expression>

8)

Let RI be the only <return item> simply contained in RS.

NOTE 221 — To fulfill SR 3), RS can only contain a single <return item>.

9)

One of the following shall be true:

a)

PRS shall contain an <order by and page statement> that simply contains a <limit clause>

LIMIT 1.

b)

PRS shall not simply contain a <group by clause> and RI shall directly contain an <aggregate

function>.

10) The declared type of the incoming working record of NQS is the declared type of the incoming

working record of VQE.

11) The declared type of the incoming working table of NQS is the material unit binding table type.

12) The declared type of VQE is the column type of the column SC.

NOTE 222 — To fulfill SR 3), the declared type of NQS is a binding table type with a single column SC.

General Rules

« WG3:UTC-064 »

1)

In a new child execution context, apply the General Rules of Subclause 9.1, “<procedure specifica-

tion>” for a <nested query specification> to NQS; let RNQS be the result of NQS.

2)

Case:

a)

If RNQS is an empty binding table, then the result of VQE is the null value.

b)

Otherwise, RNQS is a binding table comprising a single record with a single field F and the

result of VQE is the value of F.

Conformance Rules

« WG3:UTC-064 »

1)

Without Feature GC27, “Scalar subqueries”, conforming GQL language shall not contain a <value

query expression> .

389





IWD 39075:202y(E)

20.22 <case expression>

20.22 <case expression>

Function

Specify a conditional value.

Format

<case expression> ::=

<case abbreviation>

| <case specification>

<case abbreviation> ::=

NULLIF <left paren> <value expression> <comma> <value expression> <right paren>

| COALESCE <left paren> <value expression>

{ <comma> <value expression> }... <right paren>

<case specification> ::=

<simple case>

| <searched case>

<simple case> ::=

CASE <case operand> <simple when clause> ... [ <else clause> ] END

<searched case> ::=

CASE <searched when clause>... [ <else clause> ] END

<simple when clause> ::=

WHEN <when operand list> THEN <result>

<searched when clause> ::=

WHEN <search condition> THEN <result>

<else clause> ::=

ELSE <result>

<case operand> ::=

<non-parenthesized value expression primary>

| <element variable reference>

<when operand list> ::=

<when operand> [ { <comma> <when operand> }... ]

<when operand> ::=

<non-parenthesized value expression primary>

| <comparison predicate part 2>

| <null predicate part 2>

« WG3:UTC-015 »

| <value type predicate part 2>

| <directed predicate part 2>

| <labeled predicate part 2>

| <source predicate part 2>

| <destination predicate part 2>

<result> ::=

<result expression>

| NULL

<result expression> ::=

<value expression>

390

IWD 39075:202y(E)

20.22 <case expression>

Syntax Rules

1)

If a <case expression> specifies a <case abbreviation>, then:

a)

NULLIF ( V 1, V 2) is equivalent to the following <case specification>:

CASE WHEN

V 1= V 2 THEN

NULL ELSE V 1

END

b)

COALESCE ( V 1, V 2) is equivalent to the following <case specification> :

CASE

WHEN NOT V 1 IS NULL THEN V 1

ELSE V 2

END

c)

COALESCE ( V 1, V 2, ..., Vn), for n ≥ 3, is equivalent to the following <case specification> : CASE

WHEN NOT V 1 IS NULL THEN V 1

ELSE COALESCE ( V 2, ..., Vn)

END

2)

If a <case specification> specifies a <simple case> , then let CO be the <case operand> .

a)

If any <when operand> is <directed predicate part 2>, <labeled predicate part 2> , <source

predicate part 2> or <destination predicate part 2> , then CO shall be <element variable refer-

ence> and every <when operand> shall be <directed predicate part 2> , <labeled predicate

part 2>, <source predicate part 2> or <destination predicate part 2> ; otherwise, CO shall not be <element variable reference> and no <when operand> shall be <directed predicate part

2> , <labeled predicate part 2>, <source predicate part 2> or <destination predicate part 2> .

b)

Let N be the number of <simple when clause> s.

c)

For each i between 1 (one) and N, let WOLi be the <when operand list> of the i-th <simple

when clause>. Let M( i) be the number of <when operand> s simply contained in WOLi. For each j between 1 (one) and M( i), let WOi, j be the j-th <when operand> simply contained in WOLi.

d)

For each i between 1 (one) and N, and for each j between 1 (one) and M( i),

Case:

i)

If WOi, j is a <non-parenthesized value expression primary>, then let EWOi, j be:

= WOi, j

ii)

Otherwise, let EWOi, j be WOi, j.

e)

Let Ri be the <result> of the i-th <simple when clause> .

f)

If <else clause> is specified, then let CEEC be that <else clause>; otherwise, let CEEC be the zero-length character string.

g)

The <simple case> is equivalent to a <searched case> in which the i-th <searched when clause>

takes the form:

391

IWD 39075:202y(E)

20.22 <case expression>

WHEN ( CO EWOi,1 ) OR

... OR

( CO EWOi, M( i) )

THEN Ri

h)

The <else clause> of the equivalent <searched case> takes the form:

CEEC

i)

The Conformance Rules of the Subclauses of Clause 19, “Predicates” , are applied to the result

of this syntactic transformation.

NOTE 223 — The specific Subclauses of Clause 19, “Predicates”, are determined by the predicates that are

created as a result of the syntactic transformation.

3)

At least one <result> in a <case specification> shall specify a <result expression> .

4)

If an <else clause> is not specified, then ELSE NULL is implicit.

5)

The Syntax Rules of Subclause 22.16, “Result of value type combinations”, are applied with the set

of declared types of all <result expression>s in the <case specification> as DTSET; let DT be the

RESTYPE returned from the application of those Syntax Rules. The declared type of the <case spe-

cification> is RT.

General Rules

1)

Case:

a)

If a <result> specifies NULL, then its value is the null value.

b)

If a <result> specifies a <value expression> , then its value is the result of that <value expres-

sion>.

2)

Case:

a)

If the result of the <search condition> of some <searched when clause> in a <case specification>

is True, then the result of the <case expression> is the result of the <result> of the first (leftmost) <searched when clause> whose <search condition> evaluates to True, cast as the declared type of the <case specification>.

b)

If no <search condition> in a <case specification> evaluates to True, then the result of the

<case expression> is the result of the <result> of the explicit or implicit <else clause> , cast as the declared type of the <case specification>.

« Editorial: Add missing Conformance Rules section »

Conformance Rules

None.

392





IWD 39075:202y(E)

20.23 <cast specification>

20.23 <cast specification>

Function

Specify a data conversion.

Format

<cast specification> ::=

CAST <left paren> <cast operand> AS <cast target> <right paren>

<cast operand> ::=

<value expression>

« WG3:UTC-015 deleted one alternative »

<cast target> ::=

<value type>

Syntax Rules

« WG3:UTC-015 »

1)

Let CS be the <cast specification>.

2)

Let CO be the <cast operand> .

3)

Let TD be the data type identified by <value type>.

« WG3:UTC-015 »

4)

If CO specifies NULL, then TD shall be nullable, the declared type of CS is TD and no further Syntax Rules of this Subclause are applied.

« WG3:UTC-096R1 »

5)

The declared type of CS is TD.

6)

If CO is a <value expression> , then let SD be the declared type of the <value expression> .

7)

If CO is a <value expression> , then the valid combinations of TD and SD in CS are given by the following table. “Y” indicates that the combination is syntactically valid without restriction; “M”

indicates that the combination is valid subject to other Syntax Rules in this Subclause being satisfied;

and “N” indicates that the combination is invalid. The combination of TD and SD shall not be invalid

according to this classification.

SD

TD

EN UN AN C D T DT DU BO B L R P DY GR NR ER TR

EN Y Y Y Y N N N N N N N N N M N N N N

UN Y Y Y Y N N N N N N N N N M N N N N

AN Y Y Y Y N N N N N N N N N M N N N N

C Y Y Y Y Y Y Y Y Y N N N N M N N N N

D N N N Y Y N Y N N N N N N M N N N N

T N N N Y N Y Y N N N N N N M N N N N

DT N N N Y Y Y Y N N N N N N M N N N N

DU N N N Y N N N Y N N N N N M N N N N

BO N N N Y N N N N Y N N N N M N N N N

B N N N N N N N N N Y N N N M N N N N

L N N N N N N N N N N M N Y M N N N N

R N N N N N N N N N N N M N M N N N N

P N N N N N N N N N N N N Y M N N N N

DY M M M M M M M M M M M M M M M M M M

393

IWD 39075:202y(E)

20.23 <cast specification>

GR N N N N N N N N N N N N N M Y N N N

NR N N N N N N N N N N N N Y M N Y N N

ER N N N N N N N N N N N N Y M N N Y N

TR N N N N N N N N N N N N Y M N N N Y

Where:

EN = Signed Exact Numeric

UN = Unsigned Exact Numeric

AN = Approximate Numeric

C = Character String

D = Date

T = Zoned Time & Local Time

DT = Zoned Datetime & Local Datetime

DU = Duration

BO = Boolean

B = Byte String

L = List Value

R = Record

P = Path Value

DY = Dynamic Union

GR = Graph Reference Value

NR = Node Reference Value

ER = Edge Reference Value

TR = Binding Table Reference Value

8)

If TD is a dynamic union type, then SD shall be a subtype of TD.

9)

If SD is a dynamic union type and TD is a static value type, then there shall be a component type

SCT of SD such that

CAST ( VALUE AS TD )

where VALUE is a <value expression> whose declared type is SCT, shall be a valid <cast specification>.

10) If SD is a list value type, then:

« WG3:UTC-123R2 »

a)

If SD is a regular list value type, then TD shall be a regular list value type.

b)

Let ESD be the list element type of SD.

c)

Let ETD be the list element type of TD.

CAST ( VALUE AS ETD )

where VALUE is a <value expression> of declared type ESD, shall be a valid <cast specification>.

11) If SD is a closed record type, then:

a)

Let TFNS be the set of field names of TD.

« Editorial: Correct application »

b)

The set of field names of SD shall be TFNS.

c)

For every field name FN in TFNS:

i)

Let SFVT be the field value type of the field with the field name FN in SD.

ii)

Let TFVT be the field value type of the field with the field name FN in TD.

CAST ( VALUE AS TFVT )

where VALUE is a <value expression> of declared type SFVT, shall be a valid <cast

specification> .

394

IWD 39075:202y(E)

20.23 <cast specification>

General Rules

« WG3:UTC-015 »

1)

If CO is a <value expression> VE, then let SV be the result of VE.

2)

Case:

a)

If CO is NULL, then the result of CS is the null value and no further General Rules of this Sub-

clause are applied.

b)

If SV is the null value, then

Case:

i)

If TD is nullable, then the result of CS is the null value and no further General Rules of

this Subclause are applied.

ii)

Otherwise, TD is material and the following exception condition is raised: data exception

— invalid value type (22G03).

3)

If TD is a dynamic union type, then TV is SV.

4)

If SD is a dynamic union type and TD is not a dynamic union type, then:

a)

Let MST be the most specific static value type of SV.

NOTE 224 — MST is never a dynamic union type.

b)

If CAST ( VALUE AS TD ), where VALUE is a <value expression> of declared type MST, is not

a valid <cast specification> , then an exception condition is raised: data exception — invalid

value type (22G03).

c)

For the remaining General Rules of this Subclause, SD is effectively replaced by MST.

5)

If TD is a reference value type, then:

Case:

« WG3:UTC-086R1 »

a)

If TD is a closed reference value type and the GQL-object referenced by SV is not an object of

the constraining object type of TD, then an exception condition is raised: data exception —

invalid value type (22G03).

b)

Otherwise, TV is SV.

6)

If TD is a list value type and SD is a list value type, then:

a)

Let NS be the cardinality of SV.

b)

Let VEi, 1 (one) ≤ i ≤ NS, be the i-th element of SV.

c)

Let TLET be the list element type of TD.

d)

For i, 1 (one) ≤ i ≤ NS, the following <cast specification> is applied:

CAST ( VEi AS TLET )

yielding value TVEi.

e)

Let NT be the maximum cardinality of TD.

f)

Case:

395

IWD 39075:202y(E)

20.23 <cast specification>

i)

If NS is greater than NT, then an exception condition is raised: data exception — list

data, right truncation (22G0B).

ii)

Otherwise, TV is the list value with elements TVEi, 1 (one) ≤ i ≤ NS.

« Editorial »

7)

If TD is a record type and SD is a record type, then

Case:

a)

If TD is a closed record type, then:

i)

If SV and TD have the same set of field names, then:

1)

Let n be the number of field names in TD.

2)

For i, 1 (one) ≤ i ≤ n, let FNi be the i-th field name in a permutation of the set of

field names of TD, let SFVi be the field value of the field with the field name FNi

of SV and let TFVTi be the field value type of the field with the field name FNi of

TD.

3)

TV is the record resulting from the evaluation of:

RECORD { CAST ( SFV 1 AS TFVT 1 ),

CAST ( SFV 2 AS TFVT 2 )

...

CAST ( SFVn AS TFVTn ) }

ii)

Otherwise, an exception condition is raised: data exception — record fields do not match

(22G0U).

b)

Otherwise, TV is SV.

8)

If TD is a path value type and SD is a list value type, then

Case:

a)

If SV includes the null value or does not identify a path, then an exception condition is raised:

data exception — malformed path (22G0Z).

« Correction to W24-035R1 »

b)

Otherwise, TV is the path value whose path element list is SV.

9)

If TD is a signed exact numeric type, then

Case:

a)

If SD is a numeric type, then

Case:

i)

If there is a representation of SV in the value type TD that does not lose any leading

significant digits after rounding or truncating if necessary, then TV is that representation.

The choice of whether to round or truncate is implementation-defined (IA005).

ii)

Otherwise, an exception condition is raised: data exception — numeric value out of

range (22003).

b)

If SD is character string type, then SV is replaced by SV with any leading or trailing <whitespace>

removed.

Case:

396

IWD 39075:202y(E)

20.23 <cast specification>

i)

If SV does not comprise a <signed numeric literal> as defined by the rules for <literal>

in Subclause 21.1, “<literal>” , then an exception condition is raised: data exception —

invalid character value for cast (22018).

ii)

Otherwise, let LT be that <signed numeric literal>. The <cast specification> is equivalent to CAST ( LT AS TD ).

10) If TD is an unsigned exact numeric type, then

Case:

a)

If SD is a numeric type, then

Case:

i)

If there is a representation of SV in the value type TD that does not lose any leading

significant digits or the sign after rounding or truncating if necessary, then TV is that

representation. The choice of whether to round or truncate is implementation-defined

(IA005).

ii)

Otherwise, an exception condition is raised: data exception — numeric value out of

range (22003).

b)

If SD is character string type, then SV is replaced by SV with any leading or trailing <whitespace>

removed.

Case:

i)

If SV does not comprise an <unsigned numeric literal> as defined by the rules for <lit-

eral> in Subclause 21.1, “<literal>” , then an exception condition is raised: data exception

— invalid character value for cast (22018).

« Editorial »

ii)

Otherwise, let LT be that <unsigned numeric literal> . The <cast specification> is equivalent to CAST ( LT AS TD ).

11) If TD is an approximate numeric type, then

Case:

a)

If SD is a numeric type, then

Case:

i)

If there is a representation of SV in the value type TD that does not lose any leading

significant digits after rounding or truncating if necessary, then TV is that representation.

The choice of whether to round or truncate is implementation-defined (IA005).

ii)

Otherwise, an exception condition is raised: data exception — numeric value out of

range (22003).

b)

If SD is a character string type, then SV is replaced by SV with any leading or trailing

<whitespace> removed.

Case:

i)

If SV does not comprise a <signed numeric literal> as defined by the rules for <literal>

in Subclause 21.1, “<literal>” , then an exception condition is raised: data exception —

invalid character value for cast (22018).

ii)

Otherwise, let LT be that <signed numeric literal>. The <cast specification> is equivalent to CAST ( LT AS TD ).

397

IWD 39075:202y(E)

20.23 <cast specification>

« WG3:UTC-015 deleted one GR »

« WG3:UTC-015 »

12) If TD is a character string type, then let MLTD be the maximum length in characters of TD.

Case:

a)

If SD is an exact numeric type, then:

« WG3:UTC-074 »

i)

Let YP be the shortest character string that conforms to the definition of <exact numeric

literal> in Subclause 21.1, “<literal>” that does not simply contain an <exact number

suffix>, whose scale is the same as the scale of SD, whose interpreted value is the

absolute value of SV, and that is not an <unsigned hexadecimal integer> .

ii)

Case:

1)

If SV is less than 0 (zero), then let Y be the result of '−' || YP.

2)

Otherwise, let Y be YP.

iii)

Case:

1)

If the length in characters LY of Y is less than or equal to MLTD, then TV is Y.

2)

Otherwise, an exception condition is raised: data exception — string data, right

truncation (22001).

b)

If SD is an approximate numeric type, then:

i)

Let YP be a character string determined as follows.

Case:

1)

If SV equals 0 (zero), then YP is '0E0'.

« WG3:UTC-074 »

2)

Otherwise, YP is the shortest character string that conforms to the definition of

<approximate numeric literal> in Subclause 21.1, “<literal>” that does not simply contain an <approximate number suffix>, whose interpreted value is equal to the

absolute value of SV and whose <mantissa> consists of a single <digit> that is not

'0', followed by a <period> and an <unsigned integer>.

ii)

Case:

1)

If SV is less than 0 (zero), then let Y be the result of'−' || YP.

2)

Otherwise, let Y be YP.

iii)

Case:

1)

If the length in characters LY of Y is less than or equal to MLTD, then TV is Y.

2)

Otherwise, an exception condition is raised: data exception — string data, right

truncation (22001).

« WG3:UTC-015 »

c)

If SD is a character string type, then

Case:

i)

If the length in characters of SV is less than or equal to MLTD, then TV is SV.

398

IWD 39075:202y(E)

20.23 <cast specification>

ii)

If the length in characters of SV is larger than MLTD, then TV is the first MLTD characters

of SV. If any of the remaining characters of SV are non-<whitespace> characters, then a completion condition is raised: warning — string data, right truncation (01004).

« WG3:UTC-117 »

d)

If SD is a temporal instant type or a temporal duration type, then:

i)

Let Y be the shortest character string that conforms to the definition of <literal> in

Subclause 21.1, “<literal>”, and such that the interpreted value of Y is SV, and such that Case:

« WG3:UTC-009 P00-USA-169 »

1)

If SD is a date type, then the character string includes the time scale components:

[year], [month], and [day].

« Editorial »

2)

If SD is a local time type, then the character string includes the time scale compon-

ents: [hour], [min], and [sec], but does not include the 'T' time designator.

3)

If SD is a zoned time type, then the character string includes the time scale com-

ponents: [hour], [min], [sec], and [shift], but does not include the 'T' time desig-

nator.

4)

If SD is a local datetime type, then the character string includes the time scale

components: [year], [month], [day], [hour], [min], and [sec].

5)

If SD is a zoned datetime type, then the character string includes the time scale

components: [year], [month], [day], [hour], [min], [sec], and [shift].

ii)

Case:

1)

If the length in characters LY of Y is less than or equal to MLTD, then TV is Y.

2)

Otherwise, an exception condition is raised: data exception — string data, right

truncation (22001).

e)

If SD is a Boolean type, then

Case:

i)

If SV is True and MLTD is not less than 4, then TV is 'TRUE'.

ii)

If SV is False and MLTD is not less than 5, then TV is 'FALSE'.

iii)

Otherwise, an exception condition is raised: data exception — invalid character value

for cast (22018).

13) If TD is the date type, then

Case:

a)

If SD is character string type, then SV is replaced by SV with any leading or trailing <whitespace>

removed.

Case:

i)

If the rules for <literal> in Subclause 21.1, “<literal>” , can be applied to SV to determine a valid value of the value type TD, then let TV be that value.

399

IWD 39075:202y(E)

20.23 <cast specification>

ii)

Otherwise, an exception condition is raised: data exception — invalid datetime format

(22007).

b)

If SD is the date type, then TV is SV.

« WG3:UTC-090R1 »

« WG3:UTC-117 and WG3:UTC-099 »

c)

If SD is a datetime type, then let DS be the character string obtained by extracting the first 8

characters from the result of:

CAST ( VE AS STRING )

TV is the result of:

DATE ( DS )

.

14) Let STZ be the current time zone displacement. If STZ is 'Z', then let STZD be:

DURATION ( 'P0000' )

Otherwise:

a)

Let H be the character string obtained by extracting the first 3 characters from STZ.

b)

Let M be the character string obtained by extracting the 4th and 5th characters from STZ.

c)

Let STZD be:

DURATION ( 'P' || H || 'H' || M || 'M' )

15) If TD is a local time type, then

Case:

a)

If SD is a character string type, then SV is replaced by SV with any leading or trailing

<whitespace> removed.

Case:

i)

If the rules for <literal> in Subclause 21.1, “<literal>” , can be applied to SV to determine a valid value of the value type TD, then let TV be that value.

ii)

Otherwise, an exception condition is raised: data exception — invalid datetime format

(22007).

b)

If SD is a local time type, then TV is SV.

c)

If SD is a zoned time type, then:

« WG3:UTC-090R1 »

i)

Let TIME be the result of:

CAST ( VE AS STRING )

If the last character of TIME is 'Z', then the last character of TIME is replaced by '+0000'.

Let TZ be the character string obtained by extracting the last 5 characters from TIME.

Let H be the character string obtained by extracting the first 3 characters from TZ. Let

M be the character string obtained by extracting the 4th and 5th characters from TZ.

Let TZD be:

DURATION ( 'P' || H || 'H' || M || 'M' )

Let TL be the result of CHARACTER_LENGTH ( TIME ). Let T be the character string

obtained by extracting the first TL − 5 characters from TIME.

ii)

TV is the result of:

LOCAL_TIME ( T ) + TZD

400

IWD 39075:202y(E)

20.23 <cast specification>

.

d)

If SD is a local datetime type, then:

« WG3:UTC-090R1 »

i)

Let T be the character string obtained by extracting the first 10 characters from the

result of:

CAST ( VE AS STRING )

ii)

TV is the result of:

LOCAL_TIME ( T )

e)

If SD is a zoned datetime type, then:

« WG3:UTC-090R1 »

i)

Let TIME be the character string obtained by extracting the first 10 characters from

the result of:

CAST ( VE AS STRING )

If the last character of TIME is 'Z', then the last character of TIME is replaced by '+0000'.

Let TZ be the character string obtained by extracting the last 5 characters from TIME.

Let H be the character string obtained by extracting the first 3 characters from TZ. Let

M be the character string obtained by extracting the 4th and 5th characters from TZ.

Let TZD be:

DURATION ( 'P' || H || 'H' || M || 'M' )

Let TL be the result of:

CHARACTER_LENGTH ( TIME )

Let T be the character string obtained by extracting the first TL − 5 characters from

TIME.

ii)

TV is the result of LOCAL_TIME ( T ) + TZD.

16) If TD is a zoned time type, then

Case:

a)

If SD is a character string type, then SV is replaced by SV with any leading or trailing

<whitespace> removed.

Case:

i)

If the rules for <literal> in Subclause 21.1, “<literal>” , can be applied to SV to determine a valid value of the value type TD, then let TV be that value.

ii)

Otherwise, an exception condition is raised: data exception — invalid datetime format

(22007).

b)

If SD is a zoned time type, then TV is SV.

c)

If SD is a local time type, then:

i)

Let T be the result of:

CAST ( VE AS STRING )

ii)

TV is the result of:

ZONED_TIME ( T || STZ )

d)

If SD is zoned datetime type, then:

« WG3:UTC-090R1 »

401

IWD 39075:202y(E)

20.23 <cast specification>

i)

Let ZDT be the result of:

CAST ( VE AS STRING )

ii)

Let LZDT be the result of:

CHARACTER_LENGTH ( ZDT )

iii)

T be the character string obtained by extracting the last LZDR − 10 characters from

ZDT.

iv)

TV is the result of:

ZONED_TIME ( T )

e)

If SD is local datetime type, then:

« WG3:UTC-090R1 »

i)

Let ZDT be the result of:

CAST ( VE AS STRING )

ii)

Let LZDT be the result of:

CHARACTER_LENGTH ( ZDT )

iii)

T be the character string obtained by extracting the last LZDR − 10 characters from

ZDT.

iv)

TV is the result of ZONED_TIME ( T || STZ ).

17) If TD is a local datetime type, then

Case:

a)

If SD is a character string type, then SV is replaced by SV with any leading or trailing

<whitespace> removed.

Case:

i)

If the rules for <literal> in Subclause 21.1, “<literal>” , can be applied to SV to determine a valid value of the value type TD, then let TV be that value.

ii)

Otherwise, an exception condition is raised: data exception — invalid datetime format

(22007).

« Editorial »

b)

If SD is a date type, then let D be the result of:

CAST ( VE AS STRING )

TV is the result of:

LOCAL_DATETIME ( D || 'T000000' )

c)

If SD is a local time type, then:

i)

Let CD be the result of:

CAST ( DATE() AS STRING )

ii)

Let T be the result of:

CAST ( VE AS STRING )

« Editorial »

iii)

TV is the result of:

LOCAL_DATETIME ( CD || 'T' || T )

402

IWD 39075:202y(E)

20.23 <cast specification>

d)

If SD is a zoned time type, then:

« WG3:UTC-090R1 »

i)

Let DATETIME be the result of:

CAST ( VE AS STRING )

If the last character of DATETIME is 'Z', then the last character of DATETIME is replaced

by '+0000'. Let TZ be the character string obtained by extracting the last 5 characters

from DATETIME. Let H be the character string obtained by extracting the first 3 char-

acters from TZ. Let M be the character string obtained by extracting the 4th and 5th

characters from TZ. Let TZD be:

DURATION ( 'P' || H || 'H' || M || 'M' )

ii)

Let T be the character string obtained by extracting the first 6 characters from DATE-

TIME.

iii)

Let CD be the result of:

CAST ( DATE() AS STRING )

iv)

Let TA be the result of:

CAST ( LOCAL_TIME ( T ) + TZD ) AS STRING )

« Editorial »

v)

TV is the result of LOCAL_DATETIME ( CD || 'T' || TA ).

e)

If SD is a local datetime type, then TV is SV.

f)

If SD is zoned datetime type, then:

« WG3:UTC-090R1 »

i)

Let ZDT be the result of:

CAST ( VE AS STRING )

If the last character of ZDT is 'Z', then the last character of TIME is replaced by '+0000'.

Let TZ be the character string obtained by extracting the last 5 characters from ZDT.

Let H be the character string obtained by extracting the first 3 characters from TZ. Let

M be the character string obtained by extracting the 4th and 5th characters from TZ.

Let TZD be:

DURATION ( 'P' || H || 'H' || M || 'M' )

Let TL be the result of:

CHARACTER_LENGTH ( TIME )

ii)

Let DT be the character string obtained by extracting the first 15 characters from the

result of:

CAST ( VE AS STRING )

iii)

TV is the result of:

LOCAL_DATETIME ( DT ) + TZD

18) If TD is a zoned datetime type, then

Case:

a)

If SD is a character string type, then SV is replaced by SV with any leading or trailing

<whitespace> removed.

Case:

403

IWD 39075:202y(E)

20.23 <cast specification>

i)

If the rules for <literal> in Subclause 21.1, “<literal>” , can be applied to SV to determine a valid value of the value type TD, then let TV be that value.

ii)

Otherwise, an exception condition is raised: data exception — invalid datetime format

(22007).

« Editorial »

b)

If SD is a date type, then let D be the result of:

CAST ( VE AS STRING )

TV is the result of:

ZONED_DATETIME ( D || 'T000000' || STZ )

c)

If SD is a local time type, then:

i)

Let CD be the result of:

CAST ( DATE() AS STRING )

ii)

Let T be the result of:

CAST ( VE AS STRING )

« Editorial »

iii)

TV is the result of

ZONED_DATETIME ( CD || 'T' || T || STZ )

d)

If SD is a zoned time type, then:

i)

Let CD be the result of:

CAST ( DATE() AS STRING )

ii)

Let T be the result of:

CAST ( VE AS STRING )

« Editorial »

iii)

TV is the result of:

ZONED_DATETIME ( CD || 'T' || T )

e)

If SD is local datetime type, then:

i)

Let DT be the result of:

CAST ( VE AS STRING )

ii)

TV is the result of:

ZONED_DATETIME ( DT || STZ )

f)

If SD is a zoned datetime type, then TV is SV.

19) If TD is a temporal duration type, then

Case:

a)

If SD is a character string type, then SV is replaced by SV with any leading or trailing

<whitespace> removed.

Case:

i)

If the rules for <literal> in Subclause 21.1, “<literal>” , can be applied to SV to determine a valid value of the value type TD, then let TV be that value.

ii)

Otherwise, an exception condition is raised: data exception — invalid duration format

(22G0H).

404

IWD 39075:202y(E)

20.23 <cast specification>

b)

If SD is a temporal duration type, then TV is SV.

20) If TD is Boolean type, then

Case:

a)

If SD is a character string type, then SV is replaced by SV with any leading or trailing

<whitespace> removed.

Case:

i)

If the rules for <literal> in Subclause 21.1, “<literal>” , can be applied to SV to determine a valid value of the value type TD, then let TV be that value.

ii)

Otherwise, an exception condition is raised: data exception — invalid character value

for cast (22018).

b)

If SD is a Boolean type, then TV is SV.

21) If TD and SD are byte string types, then:

a)

If TD is a byte string type, then let MINLTD be the minimum length in bytes of TD and let

MAXLTD be the maximum length in bytes of TD.

b)

Case:

i)

If the length in bytes of SV is equal to LTD, then TV is SV.

ii)

If the length in bytes of SV is larger than MAXLTD, then TV is the first MAXLTD bytes of

SV and a completion condition is raised: warning — string data, right truncation (01004).

iii)

If the length in bytes M of SV is smaller than MINLTD, then TV is SV extended on the right by MINLTD− M X'00's.

22) The result of CS is TV.

Conformance Rules

1)

Without Feature GB12, “Cast specification”, conforming GQL language shall not contain a <cast

specification> .

405





IWD 39075:202y(E)

20.24 <element_id function>

20.24 <element_id function>

Function

Generate a unique identifier for a graph element.

Format

<element_id function> ::=

ELEMENT_ID <left paren> <element variable reference> <right paren>

Syntax Rules

« WG3:UTC-127R1 »

1)

Let EIF be the <element_id function>.

« WG3:UTC-127R1 Deleted 1 SR »

« WG3:UTC-127R1 »

2)

Let EVR be the <element variable reference> simply contained in EIF. EIF shall have singleton degree of reference.

3)

The declared type of <element_id function> is an implementation-defined (ID076) type that is permitted as the declared type of an operand of an equality operation according to the Syntax Rules

of Subclause 22.12, “Equality operations” .

** Editor’s Note (number 63) **

This rule differs from that in SQL/PGQ. The SQL/PGQ text adds “and as the declared type of an operand of a grouping

operation according to the Syntax Rules of Subclause 9.12, “Grouping operations” ”. Since GQL currently does not have any of the data types excluded by the above Subclause and only one active collation, there appears to be no need for

the additional restriction. This should be kept under review.

General Rules

« WG3:UTC-127R1 Deleted 2 GRs »

1)

Let GRV be the result of EVR.

2)

The result of EIF is defined as follows:

Case:

« Editorial: Move note outside to make it easier to quote the GR »

a)

If GRV is the null value, then result of EIF is the null value.

b)

Otherwise, the result of EIF is an implementation-dependent (UV004) value that encapsulates

the identity of the referent of GRV for the duration of the currently executing GQL-request.

NOTE 225 — The result of EIF can be but is not guaranteed to be the global object identifier of GE.

406

IWD 39075:202y(E)

20.24 <element_id function>

Conformance Rules

1)

Without Feature G100, “ELEMENT_ID function”, conforming GQL language shall not contain an

<element_id function> .

« WG3:UTC-015 »

407





IWD 39075:202y(E)

20.25 <let value expression>

20.25 <let value expression>

Function

« Editorial: Provide a Function text »

Evaluate a value expression using an amended working record.

« Editorial: Deleted 1 (one) editor's note »

Format

<let value expression> ::=

LET <let variable definition list> IN <value expression> END

Syntax Rules

1)

Let LVE be the <let value expression> and let WRT be the declared type of the incoming working record of LVE.

2)

Let LVDL be the <let variable definition list>, let N be the number of elements of LVDL, and let LVDi be the i-th element of LVDL, for 1 (one) ≤ i ≤ N.

3)

For 1 (one) ≤ i ≤ N:

a)

Let FNi be the name specified by the <value variable> contained in LVDi without an intervening instance of <value initializer> or <value expression> .

b)

FNi shall not identify of a field type of WRT.

c)

Let FEi be the outermost <value expression> contained in LVDi.

4)

For all pairs of i, j such that 1 (one) ≤ i < j ≤ N: FNi shall not be equal to FNj.

5)

Let NRT be a record types whose field types are determined as follows, for 1 (one) ≤ i ≤ N: The field

type whose field name is FNi and whose field value type is the declared type of FEi is included in

NRT.

6)

Let RHS be the <value expression> immediately contained in LVE.

7)

The declared type of the incoming working record of RHS is WRT amended with NRT.

8)

The declared type of LVE is the declared type of RHS.

General Rules

1)

Let NR be a record whose fields are determined as follows, for 1 (one) ≤ i ≤ N: The field whose field

name is FNi and whose field value type is the result of FEi is included in RT.

2)

In a new child execution context amended with NR, let RESULT be the result of RHS.

3)

The result of LVE is RESULT.

408

IWD 39075:202y(E)

20.25 <let value expression>

Conformance Rules

1)

Without Feature GB40, “Let-binding of variables in expressions”, conforming GQL language shall

not contain <let value expression>.